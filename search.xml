<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMake使用</title>
      <link href="/2023/11/02/cmakenote/"/>
      <url>/2023/11/02/cmakenote/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake使用"><a href="#CMake使用" class="headerlink" title="CMake使用"></a>CMake使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>ProjectName<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>executable_name src.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>cmake_minimum_required：指定使用的 cmake 的最低版本</p></li><li><p>project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言）</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">project</span><span class="token punctuation">(</span>project_name    [<span class="token property">VERSION</span> version]    [LANGUAGES CXX C]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>add_executable：创建一个可执行文件，指定了可执行文件的名称以及编译时需要的源文件。</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>target_name source1.cpp source2.cpp ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="set用法"><a href="#set用法" class="headerlink" title="set用法"></a>set用法</h2><p><code>set</code> 命令用于在 CMake 中定义变量，它创建变量并为其赋值。可以使用 <code>set</code> 命令来定义各种类型的变量，包括普通字符串、路径、列表、布尔值等。</p><p><code>set</code> 命令的基本语法如下：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>variable_name value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>variable_name</code> 是要定义的变量的名称，通常是一个字符串。</p></li><li><p><code>value</code> 是要为变量设置的值。这可以是一个普通字符串、路径、列表等，具体取决于的需求。</p></li></ul><p>以下是一些示例：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>my_string_variable <span class="token string">"Hello, CMake!"</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>my_path_variable <span class="token string">"/path/to/some/directory"</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>my_list_variable <span class="token string">"item1"</span> <span class="token string">"item2"</span> <span class="token string">"item3"</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>my_boolean_variable <span class="token boolean">TRUE</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这些示例中，我们使用 <code>set</code> 命令分别定义了字符串变量、路径变量、列表变量和布尔变量，并为它们分配了不同的值。</p><h3 id="设置C-标准"><a href="#设置C-标准" class="headerlink" title="设置C++标准"></a>设置C++标准</h3><p>要在 CMake 中设置 C++ 标准，可以使用 <code>set</code> 命令来定义 <code>CMAKE_CXX_STANDARD</code> 变量，该变量表示所使用的 C++ 标准。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>  <span class="token comment"># 设置C++标准为C++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>  <span class="token comment"># 强制使用所设置的标准</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上述示例中，我们将 C++ 标准设置为 C++17，同时通过将 <code>CMAKE_CXX_STANDARD_REQUIRED</code> 设置为 <code>ON</code>，强制使用所设置的标准。可以将 <code>CMAKE_CXX_STANDARD</code> 设置为任何受支持的C++标准，如C++98、C++11、C++14、C++17、C++20等，具体取决于的项目需求和编译器支持。</p><h3 id="设置可执行文件输出目录"><a href="#设置可执行文件输出目录" class="headerlink" title="设置可执行文件输出目录"></a>设置可执行文件输出目录</h3><p>要在CMake中指定可执行文件的输出目录，可以使用<code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>变量。这将设置所有可执行文件的输出路径。以下是如何设置可执行文件输出目录的示例：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在上述示例中，我们将可执行文件的输出路径设置为<code>${PROJECT_SOURCE_DIR}/bin</code>，其中<code>${PROJECT_SOURCE_DIR}</code>表示工程的根目录。<code>bin</code>是一个子目录，可以将可执行文件放在其中。</p><p>将这个设置放在的CMakeLists.txt文件中，通常是在顶层的CMakeLists.txt文件中，以确保所有的可执行文件都输出到指定的目录。</p><h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><ul><li><p>aux_source_directory<br>  <code>aux_source_directory</code> 用于将指定目录中的所有源文件自动添加到CMake变量中，以便稍后将这些文件编译到可执行文件或其他目标中。这个命令通常用于简化项目中源文件的管理，特别是在有大量源文件的情况下。</p><p>  <code>aux_source_directory</code> 命令的基本语法如下：</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>directory variable<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>directory</code> 是包含源文件的目录的路径。</li><li><code>variable</code> 是一个CMake变量的名称，用于存储发现的源文件列表。</li></ul><p>  示例：</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>src DIR_SRCS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  在这个示例中，<code>aux_source_directory</code> 命令将 <code>src</code> 目录中的所有源文件的文件名（包括相对路径）自动添加到名为 <code>DIR_SRCS</code> 的CMake变量中。</p><p>  然后，可以使用 <code>add_executable</code> 命令将这些源文件编译为可执行文件，例如：</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_app <span class="token punctuation">${</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这将创建一个名为 <code>my_app</code> 的可执行文件，包括 <code>src</code> 目录中的所有源文件。</p><p>  虽然 <code>aux_source_directory</code> 命令方便，但请注意它具有一定的局限性，特别是在大型项目中，更好的做法是明确列出所有源文件，以更好地控制构建过程。</p></li><li><p>file<br>  <code>file</code> 是一个用于操作文件和目录的CMake命令。它提供了各种功能，如查找文件、创建目录、复制文件、删除文件、文件属性查询等，用于处理文件系统操作。<code>file</code> 命令非常灵活，可以用于许多不同的文件操作任务。</p><p>  以下是一些 <code>file</code> 命令的示例用法：</p><ol><li>查找文件并将结果存储在变量中：</li></ol>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB MY_SOURCE_FILES <span class="token string">"src/*.cpp"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  上述示例中，<code>file</code> 命令使用 <code>GLOB</code> 模式查找 <code>src</code> 目录下的所有 <code>.cpp</code> 文件，并将结果存储在 <code>MY_SOURCE_FILES</code> 变量中。</p><ol start="2"><li>创建目录：</li></ol>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>MAKE_DIRECTORY <span class="token string">"<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span></span>/mydir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这将在构建目录中创建一个名为 <code>mydir</code> 的目录。</p><ol start="3"><li>复制文件：</li></ol>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>COPY <span class="token string">"source_file.txt"</span> DESTINATION <span class="token string">"<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span></span>/destination_dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这将复制 <code>source_file.txt</code> 文件到 <code>destination_dir</code> 目录中。</p><ol start="4"><li>删除文件：</li></ol>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>REMOVE <span class="token string">"file_to_delete.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这将删除 <code>file_to_delete.txt</code> 文件。</p><ol start="5"><li>查询文件属性：</li></ol>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>READ <span class="token string">"file_to_read.txt"</span> CONTENT<span class="token punctuation">)</span><span class="token keyword">file</span><span class="token punctuation">(</span>READ <span class="token string">"file_to_read.txt"</span> CONTENT HEX<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  这将读取文件的内容并存储在 <code>CONTENT</code> 变量中。可以选择读取文本内容或十六进制内容，具体取决于需要。</p></li></ul><h2 id="设置头文件搜索路径"><a href="#设置头文件搜索路径" class="headerlink" title="设置头文件搜索路径"></a>设置头文件搜索路径</h2><ul><li><p>include_directories</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <code>include_directories</code> 命令用于设置头文件搜索路径，将<code>${CMAKE_SOURCE_DIR}/include</code>添加到搜索路径中，以确保能够正确包含位于<code>include</code> 目录下的头文件。</p></li><li><p>target_include_directories<br>  <code>target_include_directories</code> 命令用于在CMake中为特定的目标（通常是可执行文件或库）设置包含头文件的搜索路径。这使可以为每个目标配置不同的包含路径，以确保特定目标可以找到所需的头文件。</p><p>  示例代码如下：</p>  <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>my_target <span class="token namespace">PRIVATE</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  在这个示例中，<code>my_target</code> 是目标的名称，<code>${CMAKE_SOURCE_DIR}/include</code> 是要添加到该目标的包含路径。<code>PRIVATE</code> 表示这个包含路径仅适用于 <code>my_target</code> 目标，而不会影响其他目标。</p><p>  这意味着在编译 <code>my_target</code> 时，CMake将在 <code>${CMAKE_SOURCE_DIR}/include</code> 目录中查找头文件，以便正确包含它们。</p><p>  这种方式非常有用，因为可以为不同的目标设置不同的包含路径，以满足项目的特定需求。这提供了更大的灵活性和可配置性。</p></li></ul><h2 id="生成依赖库"><a href="#生成依赖库" class="headerlink" title="生成依赖库"></a>生成依赖库</h2><h3 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h3><p>要在CMake中生成静态库，可以使用<code>add_library</code>命令，指定目标类型为<code>STATIC</code>。以下是生成静态库的基本语法：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>library_name <span class="token namespace">STATIC</span> source1.cpp source2.cpp ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>library_name</code> 是要创建的静态库的名称，通常是一个字符串。</li><li><code>source1.cpp</code>、<code>source2.cpp</code> 等是的静态库的源文件，这些源文件将被编译成库。</li></ul><p>示例：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>my_static_lib <span class="token namespace">STATIC</span> source1.cpp source2.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将生成一个名为 <code>my_static_lib</code> 的静态库，并编译 <code>source1.cpp</code> 和 <code>source2.cpp</code> 这两个源文件到该库中。</p><p>如果需要将多个源文件编译成静态库，可以列出它们，或者使用<code>aux_source_directory</code>命令来自动查找并包括源文件，如下所示：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>src DIR_SRCS<span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span>my_static_lib <span class="token namespace">STATIC</span> <span class="token punctuation">${</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个示例中，<code>aux_source_directory</code> 命令用于自动查找<code>src</code>目录中的所有源文件，并将它们编译成<code>my_static_lib</code> 静态库。</p><h3 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h3><p>使用 <code>add_library</code> 命令，指定目标类型为 <code>SHARED</code>，其余同静态库</p><h3 id="设置依赖库生成路径"><a href="#设置依赖库生成路径" class="headerlink" title="设置依赖库生成路径"></a>设置依赖库生成路径</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 设置静态库的生成路径</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span class="token comment"># 设置共享库的生成路径</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链接依赖库"><a href="#链接依赖库" class="headerlink" title="链接依赖库"></a>链接依赖库</h3><p>在CMake中，可以使用 <code>target_link_libraries</code> 命令来链接依赖库，这些依赖库可以是静态库、动态库或其他目标。以下是如何链接依赖库的示例：</p><p>假设有一个可执行文件 <code>my_app</code>，它依赖于两个库：<code>my_static_lib</code>（静态库）和 <code>my_dynamic_lib</code>（动态库）。可以使用 <code>target_link_libraries</code> 命令来链接这些库：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_app main.cpp<span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>my_app my_static_lib my_dynamic_lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个示例中，<code>target_link_libraries</code> 命令用于将 <code>my_static_lib</code> 静态库和 <code>my_dynamic_lib</code> 动态库链接到 <code>my_app</code> 可执行文件中。这将确保在构建 <code>my_app</code> 时，CMake将自动链接这两个库，以便在运行 <code>my_app</code> 时可以使用它们的功能。</p><p>还可以链接其他目标，不仅限于库文件，以满足的项目需求。这个命令非常灵活，允许指定多个依赖项，以确保项目的正确构建和链接。</p><h2 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h2><p><code>set_target_properties</code> 命令可以用来设置目标（如可执行文件、静态库或共享库）的各种属性。以下是一些常见的目标属性，可以使用 <code>set_target_properties</code> 来设置它们：</p><ol><li><code>COMPILE_DEFINITIONS</code>：设置目标的编译定义（预处理器宏）。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">COMPILE_DEFINITIONS</span> DEBUG<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><code>COMPILE_FLAGS</code>：设置目标的编译选项。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">COMPILE_FLAGS</span> <span class="token string">"-O2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><code>LINK_FLAGS</code>：设置目标的链接选项。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">LINK_FLAGS</span> <span class="token string">"-Wl,--as-needed"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><code>INCLUDE_DIRECTORIES</code>：设置目标的头文件搜索路径。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">INCLUDE_DIRECTORIES</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li><code>RUNTIME_OUTPUT_DIRECTORY</code>：设置目标的可执行文件输出目录。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">RUNTIME_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span>/bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li><code>LIBRARY_OUTPUT_DIRECTORY</code>：设置目标的共享库输出目录。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">LIBRARY_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li><code>ARCHIVE_OUTPUT_DIRECTORY</code>：设置目标的静态库输出目录。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>my_target <span class="token namespace">PROPERTIES</span> <span class="token property">ARCHIVE_OUTPUT_DIRECTORY</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这只是一些常见的目标属性示例，还有其他属性可用，取决于的项目需求。可以根据需要使用 <code>set_target_properties</code> 命令来设置目标的属性，以满足特定的编译和构建需求。</p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><ul><li>系统平台简写变量：<code>WIN32</code>, <code>APPLE</code>, <code>UNIX</code><br><code>WIN32</code>：32 位 Windows 和 64 位 Windows 。<br><code>APPLE</code>：所有苹果产品（MacOS 或 iOS）<br><code>UNIX</code>：所有 Unix 类系统（FreeBSD, Linux, Android, MacOS, iOS）</li></ul><p>示例：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">WIN32</span><span class="token punctuation">)</span>  <span class="token comment"># Windows-specific code</span>  <span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-DWINDOWS<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Linux-specific code</span>  <span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-DLINUX<span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>编译器简写变量：<code>GNU</code>, <code>MSVC</code>, <code>Clang</code></li></ul><h2 id="编译类型（CMAKE-BUILD-TYPE）"><a href="#编译类型（CMAKE-BUILD-TYPE）" class="headerlink" title="编译类型（CMAKE_BUILD_TYPE）"></a>编译类型（CMAKE_BUILD_TYPE）</h2><ul><li><code>Debug</code></li><li><code>Release</code></li><li><code>MinSizeRel</code></li><li><code>RelWithDebInfo</code></li></ul><h3 id="判断编译类型（STREQUAL）"><a href="#判断编译类型（STREQUAL）" class="headerlink" title="判断编译类型（STREQUAL）"></a>判断编译类型（STREQUAL）</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 判断</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">CMAKE_BUILD_TYPE</span><span class="token punctuation">}</span> <span class="token operator">STREQUAL</span> <span class="token string">"Debug"</span><span class="token punctuation">)</span><span class="token comment"># Debug 配置</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">CMAKE_BUILD_TYPE</span><span class="token punctuation">}</span> <span class="token operator">STREQUAL</span> <span class="token string">"Release"</span><span class="token punctuation">)</span><span class="token comment"># Release 配置</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 其他配置</span><span class="token keyword">endif</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加预处理宏定义"><a href="#添加预处理宏定义" class="headerlink" title="添加预处理宏定义"></a>添加预处理宏定义</h2><ul><li><code>add_definitions</code></li><li><code>add_compile_definitions</code></li><li><code>target_compile_definitions</code></li></ul><blockquote><p>顶层添加的预处理宏定义在子目录不生效</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++小技巧</title>
      <link href="/2023/10/15/cppskills/"/>
      <url>/2023/10/15/cppskills/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的一些小技巧"><a href="#C-的一些小技巧" class="headerlink" title="C++的一些小技巧"></a>C++的一些小技巧</h1><h2 id="处理多返回值"><a href="#处理多返回值" class="headerlink" title="处理多返回值"></a><a href="https://www.bilibili.com/video/BV1By4y1n7NA/?spm_id_from=333.788&amp;vd_source=0a3e5759a1072cc76091a2b54f770f13">处理多返回值</a></h2><ol><li>结构体<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span> <span class="token keyword">struct</span> <span class="token class-name">ShaderProgramSource</span> <span class="token punctuation">{</span>     std<span class="token double-colon punctuation">::</span>string VertexSource<span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string FragmentSource<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">static</span> ShaderProgramSource <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>     <span class="token punctuation">{</span>         NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span>         <span class="token punctuation">{</span>             ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token punctuation">{</span>ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>引用<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> vertexSource<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> fragmentSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>     <span class="token punctuation">{</span>         NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span>         <span class="token punctuation">{</span>             ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     vertexSource <span class="token operator">=</span> vs<span class="token punctuation">;</span>     fragmentSource <span class="token operator">=</span> fs<span class="token punctuation">;</span> <span class="token punctuation">}</span> std<span class="token double-colon punctuation">::</span>string vs<span class="token punctuation">,</span> fs<span class="token punctuation">;</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token string">"../res/shaders/basic.shader"</span><span class="token punctuation">,</span> vs<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>指针<br>传入指针：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span> <span class="token keyword">static</span> ShaderProgramSource <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> outVertexSource<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> outFragmentSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>     <span class="token punctuation">{</span>         NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span>         <span class="token punctuation">{</span>             ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>outVertexSource<span class="token punctuation">)</span>         <span class="token operator">*</span>outVertexSource <span class="token operator">=</span> vs<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>outFragmentSource<span class="token punctuation">)</span>         <span class="token operator">*</span>outFragmentSource <span class="token operator">=</span> fs<span class="token punctuation">;</span> <span class="token punctuation">}</span> std<span class="token double-colon punctuation">::</span>string vs<span class="token punctuation">,</span> fs<span class="token punctuation">;</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token string">"../res/shaders/basic.shader"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>返回指针：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span> <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>     <span class="token punctuation">{</span>         NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                 type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span>         <span class="token punctuation">{</span>             ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> vs<span class="token punctuation">,</span> fs <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>数组<blockquote><p>在变量类型相同时才能使用</p></blockquote>array:<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array&gt;</span></span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span> result<span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> vs<span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> fs<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>vector:<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> vs<span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> fs<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>元组<blockquote><p>可返回不同类型的变量</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>string vs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string fs <span class="token operator">=</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span>vs<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token double-colon punctuation">::</span>string vs<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string fs<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span>vs<span class="token punctuation">,</span> fs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token string">"../res/shaders/basic.shader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// auto[vs, fs] = ParseShader("../res/shaders/basic.shader");   // C++17之后生效</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader <span class="token operator">=</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span>vs<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="面向过程的static"><a href="#面向过程的static" class="headerlink" title="面向过程的static"></a>面向过程的static</h3><ul><li><p>静态全局变量<br>  静态全局变量是在文件作用域内声明的全局变量，并使用 <code>static</code> 修饰。与普通全局变量不同，静态全局变量的作用域限于当前文件，其他文件无法访问它。静态全局变量在整个程序的生命周期内保持其值，只在声明它的文件中可见。</p><p>  以下是一个示例，演示如何定义和使用静态全局变量：</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// File1.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">static</span> <span class="token keyword">int</span> globalVariable <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 静态全局变量</span><span class="token keyword">void</span> <span class="token function">functionInFile1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"globalVariable in File1: "</span> <span class="token operator">&lt;&lt;</span> globalVariable <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// File2.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">extern</span> <span class="token keyword">int</span> globalVariable<span class="token punctuation">;</span> <span class="token comment">// 声明外部静态全局变量，告诉编译器它在另一个文件中定义</span><span class="token keyword">void</span> <span class="token function">functionInFile2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"globalVariable in File2: "</span> <span class="token operator">&lt;&lt;</span> globalVariable <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// main.cpp</span><span class="token keyword">void</span> <span class="token function">functionInFile1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">functionInFile2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">functionInFile1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "globalVariable in File1: 42"</span>    <span class="token function">functionInFile2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 错误</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在这个示例中，<code>globalVariable</code> 是一个静态全局变量，它在 <code>File1.cpp</code> 文件中定义。 <code>extern</code> 声明可以告诉编译器该变量在另一个文件中定义，这允许不同文件中的函数访问并共享 数据，但<code>extern</code> 不能访问其他文件定义的 <code>static</code> 变量。</p><blockquote><p>使用静态全局变量有助于将相关数据封装在一个文件中，减少全局命名冲突，提高模块化和代码维护性。但要注意，过度使用全局变量可能会导致代码复杂性和可维护性问题，因此应该谨慎使用。</p></blockquote></li><li><p>静态函数<br>  在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p></li><li><p>静态局部变量<br>  静态局部变量（Static Local Variables）是在函数内部声明的局部变量，但使用 <code>static</code> 修饰。这种类型的变量与常规局部变量不同，因为它们在函数调用之间保持其值。静态局部变量只在首次进入函数时初始化一次，之后保持其值，即使函数退出也保持。</p><p>  示例：</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 静态局部变量</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"count: "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "count: 1"</span>    <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "count: 2"</span>    <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "count: 3"</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在这个示例中，<code>myFunction</code> 函数包含一个静态局部变量 <code>count</code>。每次调用函数时，<code>count</code> 增加 1，但它在函数退出后不会被销毁，而是保持其值。这使得 <code>count</code> 在多次函数调用之间保持状态。</p><blockquote><p>需要注意的是，静态局部变量仍然具有局部作用域，只能在声明它们的函数内部访问，无法在函数外部直接访问。但它们是持久的，不会在函数退出后销毁，这是它们与普通局部变量的主要区别。</p></blockquote><blockquote><p>函数内的静态变量需要定义之后才能使用</p></blockquote></li></ul><h3 id="面向对象的static"><a href="#面向对象的static" class="headerlink" title="面向对象的static"></a>面向对象的static</h3><ul><li><p>静态成员变量<br>  静态成员变量（Static Member Variables），也叫类变量。与普通成员变量不同，静态成员变量只有一个实例，无论创建多少个类的实例。这些变量在整个类的所有实例之间共享，如果一个实例改变了静态成员变量，那在所有实例中都会发生改变。</p><blockquote><p>静态成员变量是类的一部分，不依赖于类的任何实例，因此它们的值在所有实例之间共享和保持一致。</p></blockquote></li><li><p>静态方法<br>  静态方法（Static Methods）是属于类而不是类的实例的方法。它们与静态成员变量类似，不依赖于类的实例，可以直接通过类名来调用。静态方法在整个类的所有实例之间共享，通常用于执行与类相关的操作，而不需要访问特定实例的状态。</p><blockquote><p>静态方法不能访问非静态成员变量或非静态方法，因为它们不依赖于特定实例的状态。非静态方法可以访问静态方法和静态成员变量。</p></blockquote></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> staticVar<span class="token punctuation">;</span> <span class="token comment">// 静态类成员变量</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"staticVar in staticMethod: "</span> <span class="token operator">&lt;&lt;</span> staticVar <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">nonStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"staticVar in nonStaticMethod: "</span> <span class="token operator">&lt;&lt;</span> staticVar <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> MyClass<span class="token double-colon punctuation">::</span>staticVar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 静态类成员变量的定义和初始化</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过类名调用静态方法</span>    MyClass obj<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token function">nonStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过类实例调用非静态方法</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>静态成员变量的定义通常需要在类的外部进行，类的内部往往只包含静态成员变量的声明。这是因为静态成员变量不是类的一部分，它们实际上是独立于类的全局变量，只是与类相关联</p></blockquote><blockquote><p>将静态成员变量的定义放在类的外部是为了管理声明和定义的分离，确保适当的初始化，实现全局可见性，并避免多次定义的问题。</p></blockquote><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a><a href="https://www.bilibili.com/video/BV1qy4y1e7ds/?spm_id_from=333.788&amp;vd_source=0a3e5759a1072cc76091a2b54f770f13">const关键字</a></h2><p><code>const</code> 是C++中的一个关键字，用于指定变量、成员函数、函数参数等的属性。它表示“常量”或“不可变”，具体作用取决于它所修饰的对象。以下是 <code>const</code> 关键字的不同用法和含义：</p><ol><li><p><strong>常量变量</strong>：如果将一个变量声明为 <code>const</code>，则该变量的值不能被修改。这意味着它是只读的。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> myConstant <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>myConstant <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 这将导致编译错误，因为myConstant是常量，不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>常量指针</strong>：<code>const</code> 也可以用于指针，表示指针指向的数据不能被修改。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>myConstant<span class="token punctuation">;</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 这将导致编译错误，因为ptr指向的数据是常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>指向常量的指针</strong>：在这种情况下，指针本身是可变的，但它指向的数据是不可变的。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> anotherConstant <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> constantPtr <span class="token operator">=</span> <span class="token operator">&amp;</span>anotherConstant<span class="token punctuation">;</span><span class="token operator">*</span>constantPtr <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 合法，可以修改anotherConstant的值</span>constantPtr <span class="token operator">=</span> <span class="token operator">&amp;</span>myConstant<span class="token punctuation">;</span> <span class="token comment">// 这将导致编译错误，因为constantPtr本身是常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>常量成员函数</strong>：在类中，成员函数可以声明为 <code>const</code>，这表示它们不会修改类的成员变量。这使得编译器能够在常量对象上调用这些函数。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">ModifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 修改成员变量 */</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">AccessData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* 不修改成员变量 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> MyClass myObj<span class="token punctuation">;</span>myObj<span class="token punctuation">.</span><span class="token function">ModifyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误，不能在常量对象上调用修改成员的函数</span>myObj<span class="token punctuation">.</span><span class="token function">AccessData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合法，可以在常量对象上调用不修改成员的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>常量引用参数</strong>：<code>const</code> 也可以用于函数参数，表示函数不会修改传递给它的参数。这使得函数可以接受常量对象作为参数。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ProcessData</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// data 是常量，不能被修改</span><span class="token punctuation">}</span><span class="token keyword">int</span> myValue <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> myConstant <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">ProcessData</span><span class="token punctuation">(</span>myValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合法，myValue作为参数不会被修改</span><span class="token function">ProcessData</span><span class="token punctuation">(</span>myConstant<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合法，myConstant作为参数不会被修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="类成员变量初始化列表"><a href="#类成员变量初始化列表" class="headerlink" title="类成员变量初始化列表"></a><a href="https://www.bilibili.com/video/BV1Zi4y1F7o1/?spm_id_from=pageDriver&amp;vd_source=0a3e5759a1072cc76091a2b54f770f13">类成员变量初始化列表</a></h2><p>类成员初始化列表（Class Member Initialization List）是C++中用于初始化类的成员变量的一种方式。通常，成员变量在类的构造函数中进行初始化，但初始化列表提供了一种更有效和直接的方式来初始化成员变量，特别是对于复杂类型的成员变量。</p><p>初始化列表以冒号<code>:</code>开始，后面跟随成员变量的初始化。以下是一个示例，演示了如何在类的构造函数中使用成员初始化列表：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> intValue<span class="token punctuation">;</span>    <span class="token keyword">double</span> doubleValue<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">intValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 构造函数体</span>        <span class="token comment">// 在这里可以执行其他初始化操作</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">PrintValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"intValue: "</span> <span class="token operator">&lt;&lt;</span> intValue <span class="token operator">&lt;&lt;</span> <span class="token string">", doubleValue: "</span> <span class="token operator">&lt;&lt;</span> doubleValue <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyClass <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用初始化列表初始化成员变量</span>    obj<span class="token punctuation">.</span><span class="token function">PrintValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>MyClass</code> 类有两个私有成员变量 <code>intValue</code> 和 <code>doubleValue</code>。构造函数使用成员初始化列表来初始化这两个成员变量，而不是在构造函数体中执行初始化。这提供了更高效的初始化方式，特别是对于复杂类型的成员变量。</p><p>使用成员初始化列表的优点包括：</p><ol><li><p><strong>效率</strong>: 初始化列表允许在对象构造时直接初始化成员变量，而不需要额外的赋值操作。这可以减少不必要的临时对象的创建和销毁。</p></li><li><p><strong>确保初始化</strong>: 初始化列表确保成员变量在进入构造函数体之前得到了初始化。这对于某些成员变量的初始化很重要，特别是对于const成员变量或引用成员变量。</p></li><li><p><strong>直接初始化</strong>: 初始化列表支持直接初始化语法，使代码更清晰和紧凑。</p></li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。它允许在运行时动态地选择要调用的函数，这对于实现回调函数、插件系统和函数指针数组等情况非常有用。在C++中，函数指针的语法与普通指针类似，但需要特别注意函数的参数和返回类型。</p><p>函数指针的基本语法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">return_type</span> <span class="token punctuation">(</span><span class="token operator">*</span>function_ptr_name<span class="token punctuation">)</span><span class="token punctuation">(</span>parameter_types<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>return_type</code>：指定了被指向函数的返回类型。</li><li><code>function_ptr_name</code>：函数指针的名称。</li><li><code>parameter_types</code>：指定了被指向函数的参数类型。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">void</span> <span class="token function">HelloWorld</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World! value: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PrintValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value : "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">ForEach</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span>        <span class="token function">func</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> HelloWorld<span class="token punctuation">;</span>    <span class="token comment">// 获取HelloWorld函数的指针</span>    <span class="token function">function</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> values <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">ForEach</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> PrintValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>Lambda函数是C++11标准引入的一项重要特性，能够在代码中定义匿名的、临时的函数，通常用于简化函数对象（Function Object）的创建，以便在STL算法、标准库函数以及其他上下文中方便地传递和使用。</p><p>Lambda函数的基本语法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span> capture_clause <span class="token punctuation">]</span> <span class="token punctuation">(</span> parameters <span class="token punctuation">)</span> <span class="token operator">-&gt;</span> return_type <span class="token punctuation">{</span>    <span class="token comment">// Lambda函数体</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>capture_clause</code>：这部分用于捕获外部变量，可以为空，或者使用<code>=</code>捕获所有外部变量，或使用<code>&amp;</code>捕获所有外部变量的引用。还可以指定具体的外部变量进行捕获。</li><li><code>parameters</code>：这部分定义了Lambda函数的参数，可以为空或包含一个或多个参数。</li><li><code>return_type</code>：指定Lambda函数的返回类型，可以省略（由编译器自动推导）。</li></ul><ul><li><p>捕获：</p><ul><li><code>[=]</code>：以值（拷贝）方式捕获所有外部变量。</li><li><code>[&amp;]</code>：以引用方式捕获所有外部变量。</li><li><code>[x, &amp;y]</code>：以值方式捕获变量<code>x</code>，以引用方式捕获变量<code>y</code>。</li></ul><blockquote><p>捕获的方式会影响Lambda函数内部对变量的访问权限和修改能力。值捕获将变量拷贝到Lambda函数内部，而引用捕获将直接引用外部变量。</p></blockquote></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span><span class="token keyword">void</span> <span class="token function">ForEach</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> func<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span>        <span class="token function">func</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> values <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value:"</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" , variable"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">ForEach</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> lambda<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token comment">// 找到了满足条件的元素</span>        <span class="token keyword">int</span> foundValue <span class="token operator">=</span> <span class="token operator">*</span>it<span class="token punctuation">;</span> <span class="token comment">// 通过迭代器获取元素的值</span>        <span class="token comment">// 现在可以对 foundValue 进行操作</span>    <span class="token punctuation">}</span>     <span class="token keyword">else</span>     <span class="token punctuation">{</span>        <span class="token comment">// 没有找到满足条件的元素</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"未找到符合条件的元素。"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::function</code> 是C++标准库中的一个函数包装器，它允许将函数、函数指针、成员函数指针、Lambda函数等各种可调用对象包装成一个统一的函数对象。</p><p>在这里，<code>std::function&lt;void(int)&gt;</code> 表示一个可以接受一个整数参数并且不返回任何值的可调用对象。</p><p><code>function&lt;void(int)&gt;&amp; func</code> 引用了这个可调用对象，允许通过 func 来调用它。</p><p>C++ 标准库的 <code>std::find_if</code> 算法，用于在一个容器（如 <code>values</code>）中查找满足特定条件的元素。具体来说，它查找 <code>values</code> 容器中的第一个满足 Lambda 函数条件的元素，并返回该元素的位置。</p><p><code>std::find_if(values.begin(), values.end(), ... )</code>: 这部分使用了 <code>std::find_if</code> 算法来在容器 <code>values</code> 的范围内查找元素。<code>values.begin()</code> 返回容器的起始迭代器，<code>values.end()</code> 返回容器的结束迭代器，因此这个算法会搜索整个容器。</p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>C++ 中的 <code>union</code> 是一种数据结构，它允许在相同的内存位置存储不同的数据类型。与 <code>struct</code> 或 <code>class</code> 不同，<code>union</code> 中的成员共享相同的内存空间，而不是各自占用不同的内存空间。这意味着在任何给定时间点，一个 <code>union</code> 只能包含其中一个成员的值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">Vector2</span><span class="token punctuation">{</span>    <span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Vector4</span><span class="token punctuation">{</span>    <span class="token keyword">union</span>    <span class="token punctuation">{</span>        <span class="token keyword">struct</span>        <span class="token punctuation">{</span>            <span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span>        <span class="token punctuation">{</span>            Vector2 a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">PrintVector2</span><span class="token punctuation">(</span>Vector2<span class="token operator">&amp;</span> vector2<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> vector2<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> vector2<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Vector4 vector <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token number">3.0f</span><span class="token punctuation">,</span> <span class="token number">4.0f</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">PrintVector2</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PrintVector2</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"--------"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    vector<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">5.0f</span><span class="token punctuation">;</span>    <span class="token function">PrintVector2</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PrintVector2</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>虚析构函数（Virtual Destructor）是C++中的一种重要概念，它通常用于处理继承关系中的多态性和资源管理。虚析构函数是在基类中声明为虚函数的析构函数，它允许在基类指针指向派生类对象时正确地释放资源和执行派生类的析构函数。</p><p>通常，在继承关系中，如果基类的析构函数不是虚函数，当通过基类指针删除指向派生类对象的对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致资源泄漏和不正确的对象清理。</p><p>为了解决这个问题，通常将基类的析构函数声明为虚函数。以下是一个示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base destructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived destructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Base<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>Base</code> 类的析构函数被声明为虚函数，而 <code>Derived</code> 类继承了它。在 <code>main</code> 函数中，我们使用 <code>Base</code> 指针指向 <code>Derived</code> 类的对象，并使用 <code>delete</code> 来释放内存。由于基类析构函数是虚函数，当我们删除指针时，将调用正确的析构函数。这将依次调用 <code>Derived</code> 类的析构函数，然后是 <code>Base</code> 类的析构函数。</p><p>如果不将基类析构函数声明为虚函数，那么在删除指针时只会调用 <code>Base</code> 类的析构函数，而不会调用 <code>Derived</code> 类的析构函数，这可能导致资源泄漏。虚析构函数是确保在多态情况下正确释放资源和执行析构函数的重要工具。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在C++中，类型转换是将一个数据类型的值转换为另一个数据类型的过程，以适应不同的操作和需求。C++提供了多种类型转换方法，包括隐式类型转换（自动类型转换）和显式类型转换（强制类型转换）。</p><ol><li><p><strong>隐式类型转换（自动类型转换）</strong>：</p><ul><li><strong>隐式类型转换</strong>是在不需要明确指定的情况下由编译器自动执行的类型转换。</li><li>例如，将一个整数赋值给一个浮点数，或将一个较小的整数类型赋值给较大的整数类型，都是隐式类型转换。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 隐式将int转换为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>显式类型转换（强制类型转换）</strong>：<br> 显式指定的类型转换，用于强制将一个类型转换为另一个类型。</p><ul><li><p>C语言风格：</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span> <span class="token comment">// 显式将int转换为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>C++风格：<br>   C++提供了几种显式类型转换操作符，包括<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。</p><ul><li><code>static_cast</code>：用于基本类型之间的类型转换，以及用户自定义类型之间的转换。它是最常用的类型转换操作符。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将double转换为int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>dynamic_cast</code>：用于在继承关系中进行安全的向下转型（downcasting），通常与多态一起使用。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>Derived<span class="token operator">*</span> derivedPtr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>derivedPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 安全地将Base指针转换为Derived指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>const_cast</code>：用于添加或删除<code>const</code>限定符，用于常量对象和非常量对象之间的转换。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从const int转换为int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>reinterpret_cast</code>：用于执行低级别的指针类型转换，通常用于处理底层的硬件操作或特殊情况。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0x12345678</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将整数转换为指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><h3 id="子类和父类转换问题"><a href="#子类和父类转换问题" class="headerlink" title="子类和父类转换问题"></a>子类和父类转换问题</h3><p>在 C++ 中，将派生类（子类）对象转化为基类（父类）对象是允许的，这通常发生在多态性和继承关系中。这种转化不需要显式类型转换，它是隐式的，因为派生类对象可以被看作基类对象的一部分。这种行为被称为”向上转型”（Upcasting）。</p><p>例如以下的类继承关系：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Animal speaks"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Animal</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Dog barks"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以将 <code>Dog</code> 对象转化为 <code>Animal</code> 对象，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Dog myDog<span class="token punctuation">;</span>Animal<span class="token operator">&amp;</span> animalRef <span class="token operator">=</span> myDog<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里，<code>myDog</code> 是 <code>Dog</code> 类的对象，但它可以被看作 <code>Animal</code> 类的对象。可以调用 <code>speak</code> 方法，它会调用 <code>Dog</code> 类的 <code>speak</code> 方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">animalRef<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Dog类的speak方法，输出"Dog barks"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种”向上转型”是多态性的一部分，可以处理派生类对象，同时保持对基类的引用或指针，以实现多态行为。这通常用于传递和操作多种类型的派生类对象，而不需要知道具体的派生类类型。</p><p>需要注意的是，虽然可以将派生类对象转化为基类对象，但反之不是隐式的，即不能将基类对象转化为派生类对象，这通常需要使用显式类型转换。这种操作通常被称为”向下转型”（Downcasting），要确保对象确实是派生类的实例，以避免运行时错误。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是C++中的一种高级数据结构，用于管理动态分配的内存，以避免内存泄漏和资源泄漏。智能指针自动管理内存的生命周期，包括分配和释放内存，不需要手动使用 <code>delete</code> 释放内存，从而简化了内存管理任务。C++标准库提供了以下主要的智能指针类：</p><ol><li><p>**<code>std::shared_ptr</code>**：共享指针</p><ul><li><code>std::shared_ptr</code> 允许多个智能指针共享相同的动态分配内存，当最后一个引用离开作用域时，内存将被释放。</li><li><code>std::shared_ptr</code> 的工作方式是通过引用计数，追踪一个指针有多少个引用计数，一旦引用计数为零，指针被删除。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sharedPtr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>**<code>std::unique_ptr</code>**：独占指针</p><ul><li><code>std::unique_ptr</code> 表示唯一的所有权，一旦 <code>std::unique_ptr</code> 离开作用域，它将自动释放内存。</li><li>用于处理独占所有权的情况，例如在函数中返回动态分配的对象。</li><li>不能复制独占指针</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> uniquePtr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>**<code>std::weak_ptr</code>**：弱指针</p><ul><li><code>std::weak_ptr</code> 是一种辅助 <code>std::shared_ptr</code> 的智能指针，它不增加引用计数，用于解决循环引用的问题。</li><li>通常与 <code>std::shared_ptr</code> 一起使用，用于监视对象的生命周期。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sharedPtr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> weakPtr <span class="token operator">=</span> sharedPtr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Entity</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Entity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Created Entity"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Entity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destroyed Entity"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"unique_ptr: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Entity<span class="token operator">&gt;</span> entity <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Entity<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// std::unique_ptr&lt;Entity&gt; e0 = entity;    // 独占指针不能够复制</span>        entity<span class="token operator">-&gt;</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"shared_ptr: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Entity<span class="token operator">&gt;</span> e0<span class="token punctuation">;</span>        <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Entity<span class="token operator">&gt;</span> sharedEntity <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Entity<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e0 <span class="token operator">=</span> sharedEntity<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数是C++中的一种特殊构造函数，用于创建一个新对象，其内容是另一个已存在对象的副本。拷贝构造函数通常用于初始化一个对象，使其成为另一个对象的拷贝。拷贝构造函数的目的是复制对象的数据成员，而不是与原始对象共享资源。</p><p>拷贝构造函数通常有以下特点：</p><ol><li>参数是同类型的对象的引用（通常是<code>const</code>引用），表示要拷贝的对象。</li><li>它通常在对象创建时自动调用，例如通过赋值、传递参数给函数时，或在返回对象的过程中。</li><li>如果不自定义拷贝构造函数，C++会提供一个默认的浅拷贝（memberwise copy）的拷贝构造函数。</li></ol><p><strong>深拷贝构造函数示例：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 构造函数用于创建对象</span>        <span class="token comment">// 分配内存并复制字符串</span>        str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 拷贝构造函数</span>    <span class="token function">MyString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建一个新对象，拷贝其他对象的内容</span>        str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> other<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 析构函数用于释放分配的内存</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyString <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MyString s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">// 调用拷贝构造函数</span>    s1<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s2<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，<code>MyString</code> 类有一个拷贝构造函数，用于在创建 <code>s2</code> 时将其初始化为 <code>s1</code> 的副本。拷贝构造函数会分配新的内存并复制字符串。这确保了 <code>s1</code> 和 <code>s2</code> 不共享相同的内存。</p><p>拷贝构造函数是C++中重要的概念，特别是在处理自定义类对象时。可以根据需要自定义拷贝构造函数来确保对象的正确拷贝行为。在某些情况下，也可以使用移动构造函数来实现更高效的对象拷贝。</p><h2 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h2><p>预编译头文件（Precompiled Header）是一种优化编译过程的技术，它允许编译器预先处理常用的头文件，以加快编译速度。预编译头文件通常包含项目中经常使用的标准库头文件、自定义头文件以及其他常见依赖，以减少编译时间。</p><p>以下是使用预编译头文件的一般步骤：</p><ol><li><p>创建预编译头文件：</p><ul><li>创建一个头文件，通常使用 <code>.h</code> 或 <code>.hpp</code> 扩展名，例如 <code>stdafx.h</code>。</li><li>在该头文件中包含所有经常使用的标准库头文件和自定义头文件。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// stdafx.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"my_custom_header.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在项目设置中启用预编译头文件：<br> // TODO: </p><ul><li>打开项目的构建系统配置（如 Visual Studio 的项目属性或 CMake 的 CMakeLists.txt 文件）。</li><li>启用预编译头文件功能，并将预编译头文件的路径指定为 <code>stdafx.h</code> 或的预编译头文件名称。</li></ul></li><li><p>在源文件中包含预编译头文件：</p><ul><li>在的源文件中，包含预编译头文件。这可以在文件的开头执行。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// main.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdafx.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用预编译头文件中包含的库和自定义头文件</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> numbers<span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译项目：</p><ul><li>构建项目时，编译器将首先编译预编译头文件，然后在编译源文件之前使用已经编译好的预编译头文件。这可以显著提高编译速度，特别是对于大型项目。</li></ul></li></ol><p>使用预编译头文件的主要目标是减少编译时间，尤其对于大型项目和频繁编译的场景来说非常有用。预编译头文件通常包含不经常更改的头文件，因此可以在不需要重新编译这些头文件的情况下编译源文件。注意，预编译头文件的具体实现和配置可能因编译器和开发环境而异。</p><h2 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h2><p>在C++中，可以使用标准库中的 <code>&lt;chrono&gt; </code>头文件来进行计时操作。这提供了一个跨平台的方法来测量代码执行时间，以便进行性能分析或优化。<br><strong>简单的计时器类示例：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">start_time_point</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        start_time_point <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">elapsedMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> end_time_point <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">time_point_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>microseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>start_time_point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">time_point_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>microseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>end_time_point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.001</span><span class="token punctuation">;</span> <span class="token comment">// 转换为毫秒</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">elapsedSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">elapsedMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.001</span><span class="token punctuation">;</span> <span class="token comment">// 转换为秒</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token operator">&gt;</span> start_time_point<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Timer timer<span class="token punctuation">;</span>    <span class="token comment">// 执行需要计时的代码</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 一些计算或操作</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> elapsed_time_ms <span class="token operator">=</span> timer<span class="token punctuation">.</span><span class="token function">elapsedMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> elapsed_time_s <span class="token operator">=</span> timer<span class="token punctuation">.</span><span class="token function">elapsedSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"执行时间（毫秒）: "</span> <span class="token operator">&lt;&lt;</span> elapsed_time_ms <span class="token operator">&lt;&lt;</span> <span class="token string">" 毫秒"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"执行时间（秒）: "</span> <span class="token operator">&lt;&lt;</span> elapsed_time_s <span class="token operator">&lt;&lt;</span> <span class="token string">" 秒"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例定义了一个名为<code>Timer</code>的计时器类，它允许开始计时，重置计时器，然后获取经过的时间（以毫秒或秒为单位）。可以在需要计时的代码块周围使用<code>Timer</code>类来测量执行时间，使代码更具可读性和可维护性。</p><p>这个计时器类是一个简单的示例，可以根据需要扩展它，以支持更多的时间单位或提供更多的计时信息。</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="读取文件并"><a href="#读取文件并" class="headerlink" title="读取文件并"></a>读取文件并</h3><ul><li>运用optional(C++17)处理文件是否存在问题  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;optional&gt;</span></span>std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">ReadFileAsString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">readFile</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>readFile<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>string result<span class="token punctuation">;</span>        <span class="token comment">// read file</span>        std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>readFile<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        readFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> data <span class="token operator">=</span> <span class="token function">ReadFileAsString</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string value <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">value_or</span><span class="token punctuation">(</span><span class="token string">"File not present!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FIle read successfully!\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"File read failed!\n"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="单一变量存放多种数据"><a href="#单一变量存放多种数据" class="headerlink" title="单一变量存放多种数据"></a>单一变量存放多种数据</h2><ul><li><p><a href="#union">union</a></p></li><li><p>variant</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;variant&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>variant<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> data<span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token string">"amazing!"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>any</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点以获取该实例。这意味着无论在应用程序的任何地方都可以访问相同的单例对象。单例模式通常在需要共享资源、控制全局配置或限制某些资源访问时使用。</p><p><strong>单例模式的主要特点包括：</strong></p><ol><li><p><strong>一个唯一实例</strong>：单例模式确保一个类只有一个实例对象。</p></li><li><p><strong>全局访问点</strong>：它提供了一个全局的访问点，以便其他对象可以获取该实例。</p></li><li><p><strong>延迟初始化</strong>：单例对象通常在首次访问时被创建，而不是在应用程序启动时立即创建。</p></li><li><p><strong>全局状态共享</strong>：适用于需要全局共享状态或资源的情况，如配置管理、日志记录、数据库连接池等。</p></li></ol><p><strong>经典的单例模式实现通常包括以下元素：</strong></p><ul><li><p><strong>私有构造函数</strong>：确保只有单例类内部可以创建该类的实例。</p></li><li><p><strong>私有静态成员变量</strong>：用于存储单例实例。</p></li><li><p><strong>公有静态方法</strong>：用于获取单例实例。这个方法通常包括了延迟初始化的逻辑，以确保只有在首次访问时创建实例。</p></li></ul><p><strong>使用单例模式：</strong></p><ol><li><p><strong>创建单例类：</strong><br> 首先，创建一个类，将其设计为单例类。这通常涉及到将构造函数、拷贝构造函数和赋值运算符声明为私有，以防止外部代码创建多个实例。同时，需要在类中添加一个静态方法和一个静态成员变量来维护单一实例。</p></li><li><p><strong>实现单例模式：</strong><br> 在单例类中，实现一个静态方法（通常命名为 getInstance()）来获取单例实例。这个方法将负责创建实例（如果尚未创建）并返回它。</p></li><li><p><strong>使用单例实例：</strong><br> 在的应用程序中，通过调用单例类的 getInstance() 方法来获取单例实例。一旦获得了单例实例，可以使用它来执行操作或访问数据。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 获取单例实例</span>    <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, I am the Singleton!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 私有构造函数，防止外部创建实例</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 禁用拷贝构造函数</span>    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 禁用赋值运算符</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>instance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 静态成员变量初始化为nullptr</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Singleton<span class="token operator">&amp;</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取单例实例</span>    singleton<span class="token punctuation">.</span><span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用单例实例的方法</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>构造函数 Singleton() 被声明为私有，防止外部代码创建多个实例。同时，拷贝构造函数和赋值运算符被禁用，确保实例不会被复制。</p></blockquote><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>在C++中，左值（lvalue）和右值（rvalue）是用于描述表达式的两个关键概念，它们在语言中扮演着重要的角色，特别在移动语义和完美转发等方面。</p><p><strong>左值（lvalue）</strong>：</p><ol><li>左值表示具有标识符的表达式，通常可以出现在赋值语句的左边。例如，变量、对象成员和数组元素都是左值。</li><li>左值通常表示可以被引用和修改的内存位置。</li><li>左值有生命周期，通常在程序中持续存在一段时间。</li></ol><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// x 是左值</span><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment">// ptr 是指向左值 x 的指针</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// arr 是左值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>右值（rvalue）</strong>：</p><ol><li>右值表示临时值或不具备标识符的表达式，通常出现在赋值语句的右边。例如，字面常数、临时对象和表达式的结果都是右值。</li><li>右值通常表示临时性的值，可以用于移动语义，以减少不必要的拷贝操作。</li><li>右值的生命周期通常较短，可能在表达式求值后立即销毁。</li></ol><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 5 + 3 是右值</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 10 是右值，r 是右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>左值和右值在C++中的区分对于理解赋值、引用、移动语义和模板元编程等方面非常重要。C++11引入了右值引用和移动语义，允许有效地管理资源和减少不必要的拷贝操作，提高了性能。C++11之后，右值引用和右值引用相关的概念变得更加显著，例如左值引用和右值引用，以及引入的 <code>std::move</code> 和 <code>std::forward</code> 等工具，用于处理右值引用和完美转发。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用（Rvalue reference）是C++11引入的特性，用于标识和处理右值。右值引用允许我们更有效地管理资源、实现移动语义，以及在函数中进行完美转发。右值引用的语法通常使用双引号 <code>&amp;&amp;</code>。</p><p>右值引用的主要特点包括：</p><ol><li><p><strong>标识右值</strong>：右值引用是用于标识右值的，右值是临时值、不具备标识符的值，或者将被移动的值。通常右值出现在赋值操作的右侧。</p></li><li><p><strong>移动语义</strong>：右值引用允许实现移动构造函数和移动赋值运算符，从而能够将资源从一个对象有效地转移到另一个对象，而不需要进行深拷贝。这对于提高性能和减少内存开销非常有用。</p></li><li><p><strong>完美转发</strong>：右值引用还用于实现完美转发，允许将参数以原样传递给其他函数。这在泛型编程中特别有用，因为它可以将参数的左值或右值特性保留下来。</p></li></ol><p>下面是一些右值引用的示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment">// x 是一个右值引用，引用右值 42</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> y <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 std::move 将左值 x 转换为右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>右值引用通常用于以下情况：</p><ul><li>实现移动语义，以提高效率并减少拷贝操作。</li><li>接受右值参数的构造函数和赋值运算符。</li><li>在模板函数中实现完美转发。</li></ul><p>例如，标准库中的移动构造函数和移动赋值运算符使用右值引用来实现资源的有效转移，从而提高了容器和其他数据结构的性能。</p><p>需要注意的是，右值引用是一个强大但潜在危险的特性，因为它要求程序员更仔细地管理资源和对象的生命周期。不当使用右值引用可能导致不确定的行为和资源泄漏。因此，在使用右值引用时，需要谨慎考虑对象的生命周期和资源管理。</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p><code>std::move</code> 是C++标准库中的一个函数模板，用于将对象转换为右值引用，从而标记它们可以被移动。这对于实现移动语义非常有用，因为它允许在移动操作中使用对象的资源而不进行深拷贝。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 std::move 将 x 转换为右值引用</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// x 现在的值是未定义的，虽然能继续访问变量，但不保证其准确性</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// y 等于 42</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，使用 <code>std::move</code> 将 <code>x</code> 转换为右值引用，然后将其值移动到 <code>y</code>。注意，一旦使用 <code>std::move</code> 标记后，<code>x</code> 的值变得未定义，因为它的资源可能已经被移动到 <code>y</code>。这展示了如何使用 <code>std::move</code> 来有效地执行资源的转移，而不进行资源复制。这对于管理大型数据结构或资源密集型对象非常有用。但要小心不要重复使用已经被移动的对象，因为它们可能处于无效状态。</p><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>移动构造函数和移动赋值运算符是C++中用于实现移动语义的特殊成员函数。它们用于将资源从一个对象转移到另一个对象，而不进行资源复制，从而提高了性能和资源管理效率。这对于处理大型数据结构或管理资源密集型对象非常有用。</p><p><strong>移动构造函数</strong>：</p><p>移动构造函数是一个特殊的构造函数，用于从一个已存在的对象（通常是右值）创建一个新对象，并在创建新对象时接管原始对象的资源。它的语法通常如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Type</span><span class="token punctuation">(</span>Type<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 在此处接管资源，将 other 对象的资源转移到新对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>移动构造函数接受一个右值引用作为参数，允许在新对象中移动资源而不复制它们。这对于临时对象的创建和资源管理非常有用。</p><p><strong>移动赋值运算符</strong>：</p><p>移动赋值运算符是一个特殊的赋值运算符，用于将一个已存在的对象（通常是右值）的值和资源转移到另一个对象，同时释放原始对象的资源。它的语法通常如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Type<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Type<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 在此处释放当前对象的资源</span>        <span class="token comment">// 将 other 对象的资源移动到当前对象</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>移动赋值运算符接受一个右值引用作为参数，允许将资源从一个对象移动到另一个对象，并在需要时释放原始对象的资源。这对于对象的赋值操作和资源管理非常有用。</p><p>在使用移动构造函数和移动赋值运算符时，通常需要小心处理资源的释放，以避免资源泄漏。这包括在移动之前和之后正确管理资源，并确保不会使用已移动对象的资源。</p><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 移动构造函数</span>    <span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>        size_ <span class="token operator">=</span> other<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>        other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        other<span class="token punctuation">.</span>size_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 移动赋值运算符</span>    MyString<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>  <span class="token comment">// 释放当前对象的资源</span>            data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>            size_ <span class="token operator">=</span> other<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>            other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            other<span class="token punctuation">.</span>size_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>    size_t size_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>MyString</code> 类，其中实现了移动构造函数和移动赋值运算符，用于管理字符串的资源。这允许有效地转移字符串的内容而不需要进行深拷贝。</p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><p><strong>移动构造函数和移动赋值运算符共同使用的情况</strong>：</p><ul><li>当你的类需要支持有效的资源管理和移动语义时，通常会同时定义移动构造函数和移动赋值运算符。</li><li>这是特别有用的，因为它允许你在创建新对象和在对象之间执行赋值操作时都能够充分利用移动语义，从而提高性能。</li></ul><p><strong>只定义移动构造函数的情况</strong>：</p><ul><li>如果你的类通常是在对象的创建时进行资源管理，而不需要在对象已经存在的情况下进行资源管理（赋值），那么你只需要定义移动构造函数即可。</li><li>这种情况下，你的类可能不支持移动赋值操作，但支持移动构造操作。</li></ul><p><strong>只定义移动赋值运算符的情况</strong>：</p><ul><li>如果你的类通常是在对象已经存在的情况下进行资源管理，而不需要在对象的创建时进行资源管理，那么你只需要定义移动赋值运算符。</li><li>这种情况下，你的类可能不支持移动构造操作，但支持移动赋值操作。</li></ul><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL</title>
      <link href="/2023/10/15/opengl/"/>
      <url>/2023/10/15/opengl/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>C++编译工具链：MinGW</li><li>编辑器：VSCode</li><li>项目构建：VSCode配置文件\Cmake</li><li>依赖库：GLFW, GLEW</li></ul><h3 id="vscode构建项目"><a href="#vscode构建项目" class="headerlink" title="vscode构建项目"></a>vscode构建项目</h3><p><strong>目录结构</strong>：</p><ul><li>src: 源代码存放路径</li><li>build: 生成文件存放路径</li><li>include: 头文件存放路径</li><li>libraries: 依拉库存放路径</li></ul><h4 id="launch-json文件配置"><a href="#launch-json文件配置" class="headerlink" title="launch.json文件配置"></a>launch.json文件配置</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C/C++: g++.exe build and debug active file"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"${fileDirname}\\..\\build\\${fileBasenameNoExtension}.exe"</span><span class="token punctuation">,</span>     <span class="token comment">// debug时检测exe文件位置</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"${fileDirname}"</span><span class="token punctuation">,</span>        <span class="token comment">// 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>       <span class="token comment">// 调试时是否显示控制台窗口</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"miDebuggerPath"</span><span class="token operator">:</span> <span class="token string">"C:\\msys64\\ucrt64\\bin\\gdb.exe"</span><span class="token punctuation">,</span>       <span class="token comment">// debug编译器路径</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Enable pretty-printing for gdb"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Set Disassembly Flavor to Intel"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-gdb-set disassembly-flavor intel"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"C/C++: g++.exe build active file"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="c-cpp-properties-json文件配置"><a href="#c-cpp-properties-json文件配置" class="headerlink" title="c_cpp_properties.json文件配置"></a>c_cpp_properties.json文件配置</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Win32"</span><span class="token punctuation">,</span>            <span class="token property">"includePath"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"${workspaceFolder}/**"</span><span class="token punctuation">,</span>                <span class="token string">"${workspaceFolder}\\include"</span>       <span class="token comment">// 包含项目存放头文件位置的文件夹</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"defines"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token string">"GLEW STATIC"</span><span class="token punctuation">,</span>      <span class="token comment">// 预处理宏定义</span>                <span class="token string">"_DEBUG"</span><span class="token punctuation">,</span>                <span class="token string">"UNICODE"</span><span class="token punctuation">,</span>                <span class="token string">"_UNICODE"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"cStandard"</span><span class="token operator">:</span> <span class="token string">"c17"</span><span class="token punctuation">,</span>            <span class="token property">"cppStandard"</span><span class="token operator">:</span> <span class="token string">"gnu++17"</span><span class="token punctuation">,</span>       <span class="token comment">// c++版本</span>            <span class="token property">"intelliSenseMode"</span><span class="token operator">:</span> <span class="token string">"windows-gcc-x64"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="task-json文件配置"><a href="#task-json文件配置" class="headerlink" title="task.json文件配置"></a>task.json文件配置</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppbuild"</span><span class="token punctuation">,</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"C/C++: g++.exe build active file"</span><span class="token punctuation">,</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"C:\\msys64\\ucrt64\\bin\\g++.exe"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"-fdiagnostics-color=always"</span><span class="token punctuation">,</span>                <span class="token string">"-g"</span><span class="token punctuation">,</span>                <span class="token string">"${file}"</span><span class="token punctuation">,</span>      <span class="token comment">// 编译单文件，编译多文件时{fileDirname}\\*.cpp</span>                <span class="token comment">// "-fexec-charset=GBK",   // 处理mingw中文编码问题</span>                <span class="token comment">// "-finput-charset=UTF-8",// 处理mingw中文编码问题，没有这俩中文显示会乱码</span>                <span class="token string">"-o"</span><span class="token punctuation">,</span>                <span class="token string">"${fileDirname}\\..\\build\\${fileBasenameNoExtension}.exe"</span><span class="token punctuation">,</span>        <span class="token comment">// 编译后.exe文件生成的位置</span>                <span class="token string">"-I"</span><span class="token punctuation">,</span>                <span class="token string">"${fileDirname}\\..\\include"</span><span class="token punctuation">,</span>          <span class="token comment">// 头文件存放位置</span>                <span class="token string">"-L"</span><span class="token punctuation">,</span>                <span class="token string">"${fileDirname}\\..\\Libraries\\lib-glfw"</span><span class="token punctuation">,</span>      <span class="token comment">// 依赖库文件存放位置</span>                <span class="token string">"-l"</span><span class="token punctuation">,</span>                <span class="token string">"glfw3"</span><span class="token punctuation">,</span>        <span class="token comment">// 库文件名称（静态库名称去除前面的lib，且不加文件类型.a）</span>                <span class="token string">"-lgdi32"</span><span class="token punctuation">,</span>      <span class="token comment">// mingw编译glfw必须包含的库</span>                <span class="token string">"-lopengl32"</span>        <span class="token comment">// 编译glfw必须包含的库</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"${fileDirname}"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"problemMatcher"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"$gcc"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span>                <span class="token property">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"Task generated by Debugger."</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Cmake构建项目"><a href="#Cmake构建项目" class="headerlink" title="Cmake构建项目"></a>Cmake构建项目</h3><h2 id="OpenGL基础使用"><a href="#OpenGL基础使用" class="headerlink" title="OpenGL基础使用"></a>OpenGL基础使用</h2><h3 id="GLFW-GLEW初始化"><a href="#GLFW-GLEW初始化" class="headerlink" title="GLFW&amp;GLEW初始化"></a>GLFW&amp;GLEW初始化</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"GL/glew.h"</span>        <span class="token comment">// glew头文件导入必须在glfw前面</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"GLFW/glfw3.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">;</span>    <span class="token comment">/* Initialize the library */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* Create a windowed mode window and its OpenGL context */</span>    window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>window<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Make the window's context current */</span>    <span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK <span class="token punctuation">)</span>     <span class="token comment">// glew初始化位置</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">glGetString</span><span class="token punctuation">(</span>GL_VERSION<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">/* Loop until the user closes the window */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/* Render here */</span>        <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Traditional OpenGL draws triangles */</span>        <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Draw triangles when there is no index buffer */</span>        <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Swap front and back buffers */</span>        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Poll for and process events */</span>        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="顶点缓冲区（Vertex-Buffer）"><a href="#顶点缓冲区（Vertex-Buffer）" class="headerlink" title="顶点缓冲区（Vertex Buffer）"></a>顶点缓冲区（Vertex Buffer）</h3><p>顶点缓冲区是一个用于存储顶点数据的OpenGL缓冲区对象。它通常用于存储顶点的坐标、颜色、法线和其他属性。使用顶点缓冲区可以有效地管理和渲染大量顶点数据，提高图形渲染的性能。</p><p>以下是使用OpenGL顶点缓冲区的一般步骤：</p><ol><li><p>创建顶点缓冲区对象（Vertex Buffer Object，VBO）：VBO用于存储实际的顶点数据。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">GLuint VBO<span class="token punctuation">;</span><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>将顶点数据上传到VBO：</p><p> <code>glBufferData</code>是OpenGL用于将数据传递到指定缓冲区的函数。这个函数允许将数据从一个数组或内存块复制到一个缓冲区对象中。<br> 以下是<code>glBufferData</code>的基本用法：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBufferData</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> size<span class="token punctuation">,</span> data<span class="token punctuation">,</span> usage<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 参数说明：</p><ul><li><p><code>target</code>：指定缓冲区的类型，通常为以下之一：</p></li><li><p><code>GL_ARRAY_BUFFER</code>：用于顶点数据。</p></li><li><p><code>GL_ELEMENT_ARRAY_BUFFER</code>：用于索引数据。</p></li><li><p>其他类型，如<code>GL_UNIFORM_BUFFER</code>等，用于不同的数据类型。</p></li><li><p><code>size</code>：指定要复制的数据的字节数。如果数据是一个数组，可以使用<code>sizeof</code>运算符来计算大小。</p></li><li><p><code>data</code>：指向包含要复制的数据的指针。可以是一个数组或其他内存块。</p></li><li><p><code>usage</code>：指定缓冲区的使用模式，通常为以下之一：</p></li><li><p><code>GL_STATIC_DRAW</code>：数据很少改变，用于传递一次的情况。</p></li><li><p><code>GL_DYNAMIC_DRAW</code>：数据会在渲染循环中更改。</p></li><li><p><code>GL_STREAM_DRAW</code>：数据频繁更改，用于每帧更新的情况。</p></li></ul><p> 示例代码如下，将数据传递到<code>GL_ARRAY_BUFFER</code>：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>    <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>    <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GLuint VBO<span class="token punctuation">;</span> <span class="token comment">// 创建一个顶点缓冲区对象</span><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定缓冲区对象</span><span class="token comment">// 使用glBufferData将顶点数据传递到VBO</span><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 现在VBO包含了顶点数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置顶点属性指针：告诉OpenGL如何解释顶点数据。</p><p> 配置顶点属性指针是告诉OpenGL如何解释顶点数据的重要一步。它定义了顶点数据在顶点缓冲区中的布局和每个顶点包含的属性，例如坐标、颜色、法线等。</p><p> <strong>使用函数：</strong></p><ol><li><p>使用<code>glVertexAttribPointer</code>函数配置顶点属性指针。该函数的参数如下：</p><ul><li><code>index</code>：指定顶点属性的索引，通常从0开始递增。</li><li><code>size</code>：指定属性的大小，例如，如果是三维坐标，它应该是3。</li><li><code>type</code>：指定属性数据的类型，例如<code>GL_FLOAT</code>表示浮点数。</li><li><code>normalized</code>：指定是否对数据进行归一化。通常为<code>GL_FALSE</code>。</li><li><code>stride</code>：指定相邻顶点数据之间的偏移量（字节数）。</li><li><code>pointer</code>：指定顶点数据在缓冲区中的偏移位置。</li></ul></li><li><p>使用<code>glEnableVertexAttribArray</code>函数启用顶点属性数组。这一步是可选的，但通常都会启用它。</p></li></ol><p> <strong>示例</strong>：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 假设vertices数组包含顶点数据，其中包括坐标和纹理</span>GLfloat vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 顶点1坐标 (x, y, z) 和纹理</span>    <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 顶点2坐标 (x, y, z) 和纹理</span>    <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span>   <span class="token comment">// 顶点3坐标 (x, y, z) 和纹理</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 配置顶点属性指针</span><span class="token comment">// 顶点坐标属性</span><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 纹理属性</span><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在这个示例中，我们将顶点坐标和纹理数据分别配置为两个不同的顶点属性（索引0和1）。每个顶点属性包括大小、数据类型、偏移量和指针。然后，我们启用了这两个属性数组。</p><blockquote><p>注意：要正确渲染这些数据，还需要在渲染循环中设置相应的着色器程序，以处理顶点属性数据。这通常涉及到在顶点着色器中定义相应的输入变量，并在片段着色器中使用它们来进行渲染。</p></blockquote></li><li><p>解绑VBO和VAO（在渲染后可选，但建议）：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在渲染循环中绑定VAO并绘制：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 例如，绘制一个三角形</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="着色器（shader）"><a href="#着色器（shader）" class="headerlink" title="着色器（shader）"></a>着色器（shader）</h3><p>着色器（Shader）是一种用于在图形渲染管线中执行特定任务的计算程序。它们通常用于图形编程中，特别是在OpenGL和DirectX等图形API中。</p><p>着色器在渲染管线的不同阶段执行各种任务，以确定最终像素的颜色和位置。</p><p>常见的着色器类型包括顶点着色器、片段着色器、几何着色器、像素着色器等。</p><p>以下是一些常见类型的着色器以及它们的主要功能：</p><ol><li><p><strong>顶点着色器（Vertex Shader）</strong>：</p><ul><li>主要任务是将对象的顶点坐标从模型空间变换到屏幕空间。这包括模型视图变换、投影变换等。</li><li>可以执行法线变换和颜色插值等操作。</li></ul></li><li><p><strong>片段着色器（Fragment Shader）</strong>：</p><ul><li>在每个像素上运行，用于确定像素的最终颜色。</li><li>可以执行光照计算、纹理采样、透明度处理等。</li></ul></li><li><p><strong>几何着色器（Geometry Shader）</strong>：</p><ul><li>可选组件，用于处理图元（点、线、三角形）级别的操作，如创建新的图元、剔除不可见的图元等。</li><li>通常用于执行粒子系统、几何变形等任务。</li></ul></li><li><p><strong>计算着色器（Compute Shader）</strong>：</p><ul><li>不与渲染管线直接相关，用于通用计算任务，如物理模拟、数据处理、图像处理等。</li><li>可以在GPU上并行执行计算任务。</li></ul></li></ol><p>顶点着色器和片段着色器是图形渲染中的核心组件，它们协同工作以实现渲染的绝大多数方面。</p><p>着色器通常使用GLSL（OpenGL Shading Language）或HLSL（High-Level Shading Language）等编程语言编写。</p><p>典型的渲染流程包括将几何数据传递到顶点着色器，然后经过变换和插值，传递到片段着色器，最终计算每个像素的颜色值。这个过程可以通过编写适当的着色器程序来实现，以实现各种渲染效果，包括光照、阴影、材质、纹理映射等。</p><p>创建着色器</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ShaderProgramSource</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>string VertexSource<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string FragmentSource<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* read the shader program */</span><span class="token keyword">static</span> ShaderProgramSource <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_type<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> source<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_id <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>shader_type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* error handling */</span>    <span class="token keyword">int</span> result<span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> GL_FALSE<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> length<span class="token punctuation">;</span>        <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token operator">*</span> message <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">alloca</span><span class="token punctuation">(</span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to compile"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>shader_type <span class="token operator">==</span> GL_VERTEX_SHADER <span class="token operator">?</span> <span class="token string">"vertex"</span> <span class="token operator">:</span> <span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">return</span> shader_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* create shader */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> vertexShader<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shaderProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shaderProgram<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* use shader */</span>  ShaderProgramSource source <span class="token operator">=</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token string">"../res/shaders/basic.shader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader <span class="token operator">=</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span>VertexSource<span class="token punctuation">,</span> source<span class="token punctuation">.</span>FragmentSource<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>定义了一个结构体 <code>ShaderProgramSource</code>，并实现了一个函数 <code>ParseShader</code> 用于从文件中解析着色器程序的源代码。</p></blockquote><blockquote><p>两个主要函数：<code>CompileShader</code> 和 <code>CreateShader</code>用于编译和创建OpenGL着色器程序，以及相应的错误处理部分。</p></blockquote><p><strong><code>CompileShader</code> 函数</strong>：</p><ol><li><p><code>unsigned int shader_id = glCreateShader(shader_type)</code>: 创建一个OpenGL着色器对象，<code>shader_type</code> 参数指定了着色器的类型，可以是 <code>GL_VERTEX_SHADER</code> 或 <code>GL_FRAGMENT_SHADER</code>。</p></li><li><p><code>const char* src = source.c_str()</code>: 将着色器源代码从C++的字符串格式转换为C风格的字符数组，以便传递给OpenGL。</p></li><li><p><code>glShaderSource(shader_id, 1, &amp;src, nullptr)</code>: 将着色器源代码关联到着色器对象 <code>shader_id</code> 上。</p></li><li><p><code>glCompileShader(shader_id)</code>: 编译着色器源代码。</p></li><li><p><strong>错误处理</strong>：接下来的代码段用于检查着色器编译是否成功。它通过调用 <code>glGetShaderiv</code> 来获取编译状态，并检查 <code>GL_COMPILE_STATUS</code> 是否为 <code>GL_FALSE</code>，表示编译失败。</p></li><li><p>如果编译失败，它获取编译错误消息的长度，并分配足够的内存来存储错误消息。</p></li><li><p>然后，它再次调用 <code>glGetShaderInfoLog</code> 来获取实际的错误消息并将其存储在 <code>message</code> 变量中。</p></li><li><p>最后，它打印出错误消息，指明是顶点着色器还是片段着色器编译失败，并释放不再需要的着色器对象。</p></li><li><p>如果编译成功，函数返回着色器对象的ID。</p></li></ol><p><strong><code>CreateShader</code> 函数</strong>：</p><ol><li><p><code>unsigned int shaderProgram = glCreateProgram()</code>: 创建一个OpenGL着色器程序对象，该对象用于将顶点着色器和片段着色器链接在一起。</p></li><li><p><code>unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader)</code>: 调用 <code>CompileShader</code> 函数编译顶点着色器，并将其结果存储在 <code>vs</code> 变量中。</p></li><li><p><code>unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader)</code>: 调用 <code>CompileShader</code> 函数编译片段着色器，并将其结果存储在 <code>fs</code> 变量中。</p></li><li><p><code>glAttachShader(shaderProgram, vs)</code>: 将顶点着色器附加到着色器程序上。</p></li><li><p><code>glAttachShader(shaderProgram, fs)</code>: 将片段着色器附加到着色器程序上。</p></li><li><p><code>glLinkProgram(shaderProgram)</code>: 链接着色器程序。</p></li><li><p><code>glDeleteShader(vs)</code> 和 <code>glDeleteShader(fs)</code>: 删除不再需要的顶点和片段着色器对象。</p></li><li><p>最后，函数返回着色器程序的ID，可以用于渲染图形。</p></li></ol><p>**结构体 <code>ShaderProgramSource</code>，函数 <code>ParseShader</code> **</p><ol><li><p><code>struct ShaderProgramSource { ... }</code>: 这是一个C++结构体定义，用于存储着色器程序的顶点着色器和片段着色器的源代码。它包含两个成员变量：<code>VertexSource</code> 和 <code>FragmentSource</code>，分别用于存储顶点着色器和片段着色器的源代码。</p></li><li><p><code>static ShaderProgramSource ParseShader(const std::string&amp; filepath)</code>: 这是一个静态函数，用于解析着色器程序文件并返回一个 <code>ShaderProgramSource</code> 结构体。它接受一个文件路径作为参数，以便读取文件内容。</p></li><li><p><code>std::ifstream stream(filepath)</code>: 在函数内部，它打开指定的文件，创建一个输入文件流（ifstream），文件路径由传递给函数的 <code>filepath</code> 参数指定。</p></li><li><p><code>enum class ShaderType { ... }</code>: 这是一个枚举类型定义，用于表示着色器类型。它包含三个成员：<code>NONE</code>、<code>VERTEX</code> 和 <code>FRAGMENT</code>。初始时，<code>type</code> 被设置为 <code>NONE</code>，表示当前没有处于任何特定类型的着色器代码段。</p></li><li><p><code>std::string line;</code>: 用于存储从文件中逐行读取的文本。</p></li><li><p><code>std::stringstream ss[2];</code>: 这是一个字符串流数组，其中有两个元素，用于分别存储顶点着色器和片段着色器的源代码。</p></li><li><p><code>ShaderType type = ShaderType::NONE;</code>: 初始化 <code>type</code> 变量，表示当前没有处于任何特定类型的着色器代码段。</p></li><li><p><code>while(getline(stream, line)) { ... }</code>: 这是一个循环，它会逐行读取文件内容。</p></li><li><p>在循环内部，代码检查每一行是否包含 <code>#shader</code>，以确定当前行是否是着色器的声明。如果是，它会进一步检查 <code>vertex</code> 或 <code>fragment</code> 关键字，以确定是顶点着色器还是片段着色器的声明。</p></li><li><p>如果是着色器代码的一部分，它将该行添加到适当类型（顶点或片段）的字符串流 <code>ss</code> 中。</p></li><li><p>循环继续，直到文件的末尾。</p></li><li><p>最后，函数返回一个 <code>ShaderProgramSource</code> 结构体，其中包含了解析的顶点着色器和片段着色器的源代码。</p></li></ol><h3 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h3><p>索引缓冲区（Index Buffer）是一种用于优化图形渲染的技术，特别是在处理大型三维模型时非常有用。索引缓冲区允许以一种更有效的方式定义和渲染顶点数据，减少冗余数据的存储和传输，以提高性能。</p><p>索引缓冲区的核心思想是将顶点数据和索引数据分开存储。通常有一个包含所有唯一顶点数据的顶点缓冲区，然后另一个缓冲区包含索引，这些索引指示如何组合顶点以构成几何图元（例如，三角形）。</p><p>以下是使用索引缓冲区的一般步骤：</p><ol><li><p><strong>创建顶点缓冲区</strong>：首先，创建一个顶点缓冲区（Vertex Buffer Object，VBO），并将所有唯一的顶点数据存储在其中。这包括位置、颜色、法线等顶点属性。</p></li><li><p><strong>创建索引缓冲区</strong>：然后，创建一个索引缓冲区（Index Buffer Object，IBO），其中包含表示图元的索引数据。这些索引通常是指向顶点缓冲区中的数据的引用。</p></li><li><p><strong>绘制对象</strong>：在渲染循环中，绑定顶点缓冲区和索引缓冲区，然后调用绘制命令以绘制几何图元。OpenGL将使用索引缓冲区中的索引来确定要绘制的顶点。</p></li></ol><p>优点和用途：</p><ul><li><p><strong>减少冗余数据</strong>：索引缓冲区允许多个图元共享相同的顶点数据，减少了内存和数据传输开销。</p></li><li><p><strong>提高性能</strong>：减少冗余数据传输和处理，提高渲染性能，特别是在大型三维模型的情况下。</p></li><li><p><strong>支持复杂的模型</strong>：索引缓冲区非常有用，当要渲染的模型包含大量重复顶点数据，例如一个立方体或球体。</p></li></ul><p>使用索引缓冲区时，需要小心确保顶点数据和索引数据的一致性，以及正确绑定和绘制命令的使用。此外，不同的渲染API可能有不同的方式来创建和使用索引缓冲区，但核心思想是相似的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> indices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* create Index buffer */</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> ibo<span class="token punctuation">;</span><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ibo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ibo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> indices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Draw rect with index buffer*/</span><span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a><code>glGetError</code></h4><p><code>glGetError</code> 是一个OpenGL函数，用于检查OpenGL中是否有错误发生。OpenGL使用错误标志来记录和报告各种渲染和配置问题。当进行OpenGL操作时，如果出现错误，可以使用 <code>glGetError</code> 来检测和识别这些错误。</p><p><code>glGetError</code> 的基本用法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">GLenum error <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 处理OpenGL错误</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一些可能的OpenGL错误码，以及它们的含义：</p><ul><li><code>GL_NO_ERROR</code>：没有错误。</li><li><code>GL_INVALID_ENUM</code>：无效的枚举参数。</li><li><code>GL_INVALID_VALUE</code>：无效的数值参数。</li><li><code>GL_INVALID_OPERATION</code>：无效的操作。</li><li><code>GL_STACK_OVERFLOW</code>：堆栈溢出。</li><li><code>GL_STACK_UNDERFLOW</code>：堆栈下溢。</li><li><code>GL_OUT_OF_MEMORY</code>：内存不足。</li><li><code>GL_INVALID_FRAMEBUFFER_OPERATION</code>：尝试使用无效帧缓冲对象。</li></ul><p>可以在OpenGL操作之后使用 <code>glGetError</code> 来检查是否发生了错误，然后采取适当的措施来处理这些错误，例如记录错误信息、中止渲染或采取其他适当的操作。通常，这在OpenGL调试和错误排除过程中非常有用。</p><blockquote><p>请注意，<code>glGetError</code> 只能检测到发生在最后一次OpenGL调用中的错误，它不会跟踪或记录多次操作中的错误。因此，通常需要在每个潜在的错误点后立即检查错误标志。</p></blockquote><h3 id="统一变量（uniform）"><a href="#统一变量（uniform）" class="headerlink" title="统一变量（uniform）"></a>统一变量（uniform）</h3><p>在OpenGL中，统一变量（Uniform）是一种特殊类型的变量，用于在着色器程序之间传递数据。统一变量的主要特点是它们在着色器程序中是全局的，而且它们的值在多个渲染过程之间保持不变。这使得统一变量非常适合在CPU和GPU之间传递数据，以便在着色器中使用。</p><p>在OpenGL中，uniform是一种特殊类型的着色器变量，它具有以下特点：</p><ol><li><p><strong>Uniform 变量的值在多个顶点或片段之间是相同的</strong>：Uniform 变量的值在一个绘制调用期间对于所有顶点着色器和片段着色器都是相同的。这使得它成为向着色器传递全局数据的一种方式。</p></li><li><p><strong>Uniform 变量在CPU端设置，但在GPU端访问</strong>：Uniform 变量的值通常是在CPU端设置的，然后在GPU端的着色器中访问。这使得它成为一种在应用程序和着色器之间传递数据的方法。</p></li><li><p><strong>Uniform 变量适用于各种着色器类型</strong>：Uniform 变量可以在顶点着色器、片段着色器以及其他着色器类型中使用。这使得它非常灵活，可以用于传递不同类型的数据，如变换矩阵、材质属性、光照参数等。</p></li></ol><p><strong>用法：</strong></p><ol><li><p><strong>声明和使用统一变量</strong>：统一变量通常在着色器程序中以以下方式声明和使用：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">uniform</span> data_type variable_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>data_type</code> 是变量的数据类型（如float、vec3、mat4等），<code>variable_name</code> 是变量的名称。统一变量的值可以在CPU代码中设置，并在着色器中使用。</p></li><li><p><strong>数据传递</strong>：可以使用OpenGL的API函数（如<code>glUniform*</code>系列函数）在CPU端将数据设置到统一变量中。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">GLint location <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"variable_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>glUniform<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用适当的 glUniform 函数将数据传递给统一变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将允许在渲染过程中将值传递给着色器。</p></li></ol><p><strong>示例：</strong></p><ol><li><p>shader文件中定义统一变量uniform:</p>  <pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">uniform</span> <span class="token keyword">vec4</span> u_Color<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>主文件中设置和使用uinform：</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> location <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> <span class="token string">"u_Color"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span>location <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glUniform4f</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p><code>uniform</code> 设置须在渲染之前</p></blockquote><p><strong>统一变量出错原因：</strong></p><ol><li><p><strong>Uniform变量名拼写错误</strong>：确保Uniform变量的名称与着色器代码中的名称完全匹配，包括大小写。在的着色器代码中，Uniform变量名称应该是 “u_Color”，请确保在代码中也是这样。</p></li><li><p><strong>Uniform变量没有被使用</strong>：如果在着色器中声明了一个Uniform变量但没有在代码中使用它，编译器可能会将其优化掉。请确保Uniform变量在着色器代码中实际使用，以便它在着色器程序中存在。</p></li><li><p><strong>着色器链接失败</strong>：如果着色器程序的链接失败，Uniform变量可能不会被成功绑定。确保着色器程序的链接没有问题。可以检查着色器程序的链接状态，以确保链接成功。</p></li><li><p><strong>Uniform变量在错误的着色器阶段</strong>：Uniform变量的存在和位置是着色器阶段相关的。请确保在正确的着色器阶段（顶点着色器或片段着色器）中声明了Uniform变量，并在正确的阶段中尝试设置它。</p></li></ol><h3 id="顶点数组（Vertex-Array）"><a href="#顶点数组（Vertex-Array）" class="headerlink" title="顶点数组（Vertex Array）"></a>顶点数组（Vertex Array）</h3><p>OpenGL中的顶点数组是一种用于存储和组织顶点数据的数据结构。顶点数组通常与顶点缓冲区对象（Vertex Buffer Object，VBO）一起使用，用于描述三维对象的几何信息，如位置、颜色、法线、纹理坐标等。</p><p><strong>顶点数组对象（Vertex Array Object，VAO）：</strong><br>    VAO是用于存储和管理顶点属性指针的OpenGL对象。它可以包括多个VBO和IBO（索引缓冲对象）。VAO的目的是封装顶点属性指针的状态，以便轻松地切换不同的顶点数据布局。</p><blockquote><p>如果使用核心配置文件，则必须创建顶点数组对象<br>使用兼容性配置文件时，有一个默认的顶点数组对象，可以不单独创建</p></blockquote><blockquote><p>顶点数组对象包含定点换种去之间的绑定，以及实际定点规范或布局</p></blockquote><p><strong>创建和绑定顶点数组:</strong><br>   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> vao<span class="token punctuation">;</span><span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>渲染时：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将代替：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="整体代码展示"><a href="#整体代码展示" class="headerlink" title="整体代码展示"></a>整体代码展示</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"GL/glew.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"GLFW/glfw3.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GLCall</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> GLClearError<span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression">x<span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">GLLogCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">void</span> <span class="token function">GLClearError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">GLLogCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>GLenum error <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"[OpenGL_Error] ("</span> <span class="token operator">&lt;&lt;</span> error <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">ShaderProgramSource</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>string VertexSource<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string FragmentSource<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* read the shader program */</span><span class="token keyword">static</span> ShaderProgramSource <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_type<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> source<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_id <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>shader_type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* error handling */</span>    <span class="token keyword">int</span> result<span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> GL_FALSE<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> length<span class="token punctuation">;</span>        <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token operator">*</span> message <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">alloca</span><span class="token punctuation">(</span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to compile"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>shader_type <span class="token operator">==</span> GL_VERTEX_SHADER <span class="token operator">?</span> <span class="token string">"vertex"</span> <span class="token operator">:</span> <span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">return</span> shader_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* create shader */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> vertexShader<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shaderProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shaderProgram<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">;</span>    <span class="token comment">/* Initialize the library */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* Create a windowed mode window and its OpenGL context */</span>    window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>window<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Make the window's context current */</span>    <span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glfwSwapInterval</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK <span class="token punctuation">)</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">glGetString</span><span class="token punctuation">(</span>GL_VERSION<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">float</span> positions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>   <span class="token comment">// 0</span>         <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>   <span class="token comment">// 1</span>         <span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span>   <span class="token comment">// 2</span>        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span>   <span class="token comment">// 3</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> indices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">/* Build VAO and bind*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vao<span class="token punctuation">;</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Build the buffer */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> buffer<span class="token punctuation">;</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> positions<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Configure vertex properties */</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* create Index buffer */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ibo<span class="token punctuation">;</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ibo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ibo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> indices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* create shader*/</span>    ShaderProgramSource source <span class="token operator">=</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token string">"../res/shaders/basic.shader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Vertex"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> source<span class="token punctuation">.</span>VertexSource <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Fragment"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> source<span class="token punctuation">.</span>FragmentSource <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader <span class="token operator">=</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span>VertexSource<span class="token punctuation">,</span> source<span class="token punctuation">.</span>FragmentSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* set the value of uniform */</span>    <span class="token keyword">int</span> location <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> <span class="token string">"u_Color"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>location <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glUniform4f</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Unbind object */</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> increment <span class="token operator">=</span> <span class="token number">0.05f</span><span class="token punctuation">;</span>    <span class="token comment">/* Loop until the user closes the window */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/* Render here */</span>        <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Traditional OpenGL draws triangles */</span>        <span class="token comment">// glBegin(GL_TRIANGLES);</span>        <span class="token comment">// glVertex2f(-0.5f, -0.5f);</span>        <span class="token comment">// glVertex2f( 0.0f,  0.5f);</span>        <span class="token comment">// glVertex2f( 0.5f, -0.5f);</span>        <span class="token comment">// glEnd();</span>        <span class="token comment">/* Draw triangles when there is no index buffer */</span>        <span class="token comment">// glDrawArrays(GL_TRIANGLES, 0, 6);</span>        <span class="token comment">/* Draw rect with index buffer*/</span>        <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glUniform4f</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// glBindBuffer(GL_ARRAY_BUFFER, buffer);</span>        <span class="token comment">// glEnableVertexAttribArray(0);</span>        <span class="token comment">// glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);</span>        <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ibo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&gt;</span> <span class="token number">1.0f</span><span class="token punctuation">)</span>            increment <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0.0f</span><span class="token punctuation">)</span>            increment <span class="token operator">=</span> <span class="token number">0.05f</span><span class="token punctuation">;</span>                r <span class="token operator">+=</span> increment<span class="token punctuation">;</span>        <span class="token comment">/* Swap front and back buffers */</span>        <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Poll for and process events */</span>        <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将代码抽象成类"><a href="#将代码抽象成类" class="headerlink" title="将代码抽象成类"></a>将代码抽象成类</h2><h3 id="抽象错误处理成类"><a href="#抽象错误处理成类" class="headerlink" title="抽象错误处理成类"></a>抽象错误处理成类</h3><p>头文件：</p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#ifndef __RENDERER_H_#define __RENDERER_H_#include &lt;GL\glew.h&gt;#include &lt;assert.h&gt;#define GLCall(x) GLClearError;\x;\assert(GLLogCall())void GLClearError();bool GLLogCall();#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp文件：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Renderer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">GLClearError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">GLLogCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>GLenum error <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"[OpenGL_Error] ("</span> <span class="token operator">&lt;&lt;</span> error <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象顶点缓冲区成类"><a href="#抽象顶点缓冲区成类" class="headerlink" title="抽象顶点缓冲区成类"></a>抽象顶点缓冲区成类</h3><p>头文件：</p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma onceclass VertexBuffer{private:    unsigned int m_RendererID;public:    VertexBuffer(const void* data, unsigned int size);    ~VertexBuffer();    void Bind() const;    void Unbind() const;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp文件：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"VertexBuffer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Renderer.h"</span></span><span class="token class-name">VertexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">VertexBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> size<span class="token punctuation">,</span> data<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">VertexBuffer</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">VertexBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glDeleteBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">VertexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">VertexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">Unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象索引缓冲区成类"><a href="#抽象索引缓冲区成类" class="headerlink" title="抽象索引缓冲区成类"></a>抽象索引缓冲区成类</h3><p>头文件：</p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma onceclass IndexBuffer{private:    unsigned int m_RendererID;    unsigned int m_count;public:    IndexBuffer(const unsigned int* data, unsigned int count);    ~IndexBuffer();    void Bind() const;    void Unbind() const;    inline unsigned int GetCount() const { return m_count; };};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cpp文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"IndexBuffer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Renderer.h"</span></span><span class="token class-name">IndexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">IndexBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">m_count</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> count <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">IndexBuffer</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">IndexBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glDeleteBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">IndexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">IndexBuffer</span><span class="token double-colon punctuation">::</span><span class="token function">Unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象顶点数组和布局成类"><a href="#抽象顶点数组和布局成类" class="headerlink" title="抽象顶点数组和布局成类"></a>抽象顶点数组和布局成类</h3><p><strong>布局头文件：</strong></p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma once#include &lt;vector&gt;#include "GL/glew.h"#include &lt;assert.h&gt;struct VertexBufferElement{    unsigned int count;    unsigned int type;    unsigned char normalized;    static unsigned int GetSizeofType(unsigned int type)    {        switch (type)        {            case GL_FLOAT:                      return 4;            case GL_UNSIGNED_INT:       return 4;            case GL_UNSIGNED_BYTE:     return 1;        }        // assert(false);   // ？ vscode+mingw此处断言任然生效        return 0;    }};class VertexBufferLayout{private:    std::vector&lt;VertexBufferElement&gt; m_Elements;    unsigned int m_Stride;public:    VertexBufferLayout()        : m_Stride(0) {}    // TODO: 解决在GCC中报错    /* vs中有效，但vscode+mingw时会报错 */    /*    template&lt;typename T&gt;    void Push(unsigned int count)    {        static_assert(false, "Unsupported type in VertexBufferLayout::Push");    }    template&lt;&gt;    void Push&lt;float&gt;(unsigned int count)    {        m_Elements.push_back({ count, GL_FLOAT, GL_FALSE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_FLOAT);    }    template&lt;&gt;    void Push&lt;unsigned int&gt;(unsigned int count)    {        m_Elements.push_back({ count, GL_UNSIGNED_INT, GL_FALSE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_UNSIGNED_INT);    }    template&lt;&gt;    void Push&lt;unsigned char&gt;(unsigned int count)    {        m_Elements.push_back({ count, GL_UNSIGNED_BYTE, GL_TRUE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_UNSIGNED_BYTE);    }    */    void PushFloat(unsigned int count)    {        m_Elements.push_back({ count, GL_FLOAT, GL_FALSE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_FLOAT);    }    void PushUInt(unsigned int count)    {        m_Elements.push_back({ count, GL_UNSIGNED_INT, GL_FALSE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_UNSIGNED_INT);    }    void PushUChar(unsigned int count)    {        m_Elements.push_back({ count, GL_UNSIGNED_BYTE, GL_TRUE });        m_Stride += count * VertexBufferElement::GetSizeofType(GL_UNSIGNED_BYTE);    }    inline const std::vector&lt;VertexBufferElement&gt; GetElements() const { return m_Elements; }    inline unsigned int GetStride() const { return m_Stride; }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>顶点数组头文件：</strong></p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma once#include "VertexBuffer.h"#include "VertexBufferLayout.h"class VertexArray{private:    unsigned int m_RendererID;public:    VertexArray();    ~VertexArray();    void AddBuffer(const VertexBuffer&amp; vb, const VertexBufferLayout&amp; layout);    void Bind() const;    void Unbind() const;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>顶点数组cpp文件：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"VertexArray.h"</span></span><span class="token class-name">VertexArray</span><span class="token double-colon punctuation">::</span><span class="token function">VertexArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">VertexArray</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">VertexArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glDeleteVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">VertexArray</span><span class="token double-colon punctuation">::</span><span class="token function">AddBuffer</span><span class="token punctuation">(</span><span class="token keyword">const</span> VertexBuffer <span class="token operator">&amp;</span>vb<span class="token punctuation">,</span> <span class="token keyword">const</span> VertexBufferLayout <span class="token operator">&amp;</span>layout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vb<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> elements <span class="token operator">=</span> layout<span class="token punctuation">.</span><span class="token function">GetElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> element <span class="token operator">=</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> element<span class="token punctuation">.</span>count<span class="token punctuation">,</span> element<span class="token punctuation">.</span>type<span class="token punctuation">,</span> element<span class="token punctuation">.</span>normalized<span class="token punctuation">,</span> layout<span class="token punctuation">.</span><span class="token function">GetStride</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>intptr_t<span class="token punctuation">)</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        offset <span class="token operator">+=</span> element<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token class-name">VertexBufferElement</span><span class="token double-colon punctuation">::</span><span class="token function">GetSizeofType</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">VertexArray</span><span class="token double-colon punctuation">::</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">VertexArray</span><span class="token double-colon punctuation">::</span><span class="token function">Unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将着色器抽象成类"><a href="#将着色器抽象成类" class="headerlink" title="将着色器抽象成类"></a>将着色器抽象成类</h3><p><strong>头文件：</strong></p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma once#include &lt;string&gt;#include &lt;unordered_map&gt;struct ShaderProgramSource{    std::string VertexSource;    std::string FragmentSource;};class Shader{private:    std::string m_Filepath;    unsigned int m_RendererID;    // catching for uniforms    std::unordered_map&lt;std::string, unsigned int&gt; m_UniformLocationCache;public:    Shader(const std::string&amp; filepath);    ~Shader();    void Bind() const;    void Unbind() const;    // Set uniforms    void SetUniform4f(const std::string&amp; name, float v1, float v2, float v3, float v4);private:    ShaderProgramSource ParseShader(const std::string&amp; filepath);    unsigned int CompileShader(unsigned int shader_type, const std::string&amp; source);    unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader);    unsigned int GetUniformLocation(const std::string&amp; name);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>cpp文件：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Shader.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Renderer.h"</span></span><span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">Shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_Filepath</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_RendererID</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ShaderProgramSource source <span class="token operator">=</span> <span class="token function">ParseShader</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_RendererID <span class="token operator">=</span> <span class="token function">CreateShader</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span>VertexSource<span class="token punctuation">,</span> source<span class="token punctuation">.</span>FragmentSource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Shader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glDeleteProgram</span><span class="token punctuation">(</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ShaderProgramSource <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">ParseShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> filepath<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">stream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShaderType</span>    <span class="token punctuation">{</span>        NONE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> VERTEX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> FRAGMENT <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ShaderType type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>NONE<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"#shader"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"vertex"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>VERTEX<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>                type <span class="token operator">=</span> ShaderType<span class="token double-colon punctuation">::</span>FRAGMENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            ss<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>ss<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">CompileShader</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_type<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> source<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shader_id <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>shader_type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* error handling */</span>    <span class="token keyword">int</span> result<span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> GL_FALSE<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> length<span class="token punctuation">;</span>        <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token operator">*</span> message <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">alloca</span><span class="token punctuation">(</span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to compile"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>shader_type <span class="token operator">==</span> GL_VERTEX_SHADER <span class="token operator">?</span> <span class="token string">"vertex"</span> <span class="token operator">:</span> <span class="token string">"fragment"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>shader_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> shader_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">CreateShader</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> vertexShader<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> shaderProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fs <span class="token operator">=</span> <span class="token function">CompileShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> shaderProgram<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">Unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">SetUniform4f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">float</span> v1<span class="token punctuation">,</span> <span class="token keyword">float</span> v2<span class="token punctuation">,</span> <span class="token keyword">float</span> v3<span class="token punctuation">,</span> <span class="token keyword">float</span> v4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glUniform4f</span><span class="token punctuation">(</span><span class="token function">GetUniformLocation</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">,</span> v4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">Shader</span><span class="token double-colon punctuation">::</span><span class="token function">GetUniformLocation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m_UniformLocationCache<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">!=</span> m_UniformLocationCache<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> m_UniformLocationCache<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> location <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>m_RendererID<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>location <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Warning: uniform '"</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">" ' dosen't exist!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m_UniformLocationCache<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> location<span class="token punctuation">;</span>    <span class="token keyword">return</span> location<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>在OpenGL中添加纹理通常涉及以下步骤：</p><ol><li><p><strong>加载纹理图像</strong>：首先，需要加载纹理图像文件。通常使用库如stb_image或SOIL（Simple OpenGL Image Library）来加载图像文件。这将为提供图像的像素数据。</p></li><li><p><strong>创建纹理对象</strong>：在OpenGL中，需要创建一个纹理对象来存储纹理数据。使用 <code>glGenTextures</code> 来生成一个纹理对象的ID。</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">GLuint textureID<span class="token punctuation">;</span><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>textureID<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li><strong>绑定纹理对象</strong>：使用 <code>glBindTexture</code> 来绑定纹理对象，以便后续的操作将影响该纹理对象。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> textureID<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><strong>设置纹理参数</strong>：使用 <code>glTexParameteri</code> 来设置纹理参数，如缩小滤波、放大滤波、纹理坐标包裹模式等。这些参数会影响纹理在渲染中的采样行为。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><strong>将图像数据上传到纹理对象</strong>：使用 <code>glTexImage2D</code> 来将图像数据上传到纹理对象。需要指定纹理目标（通常是 <code>GL_TEXTURE_2D</code>）、级别、内部像素格式、宽度、高度、边界、源格式和数据类型。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> level<span class="token punctuation">,</span> internalformat<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> format<span class="token punctuation">,</span> type<span class="token punctuation">,</span> image_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是 <code>glTexImage2D</code> 函数的关键参数和用法：</p><ul><li><p><code>target</code>：指定纹理的类型，通常是 <code>GL_TEXTURE_2D</code> 表示二维纹理。也可以是其他类型，如立方体贴图等。</p></li><li><p><code>level</code>：指定纹理的细节级别，通常为0表示基本级别。用于创建多级细节纹理（MIP贴图）时，可以设置不同的级别。</p></li><li><p><code>internalformat</code>：指定纹理数据的内部格式，如 <code>GL_RGBA</code> 表示纹理包含红、绿、蓝和透明度通道。这与实际的纹理图像格式可以不同，OpenGL会根据此内部格式进行适当的转换。</p></li><li><p><code>width</code> 和 <code>height</code>：指定纹理的宽度和高度，以像素为单位。</p></li><li><p><code>border</code>：指定边界宽度，通常为0。</p></li><li><p><code>format</code>：指定纹理数据的格式，如 <code>GL_RGBA</code>。</p></li><li><p><code>type</code>：指定纹理数据的数据类型，如 <code>GL_UNSIGNED_BYTE</code> 表示数据是无符号字节。</p></li><li><p><code>data</code>：指定包含图像数据的指针。这是您加载的图像数据的指针。</p></li></ul><p><code>glTexImage2D</code> 的主要作用是将图像数据从CPU内存上传到GPU，以便GPU能够在着色器中对其进行采样和处理。一旦数据被上传到纹理对象，就可以在着色器中使用纹理坐标对纹理进行采样，从而将其应用到渲染的几何体上。</p><ol start="6"><li><strong>解除纹理对象绑定</strong>：最后，使用 <code>glBindTexture</code> 解除对纹理对象的绑定，以确保后续操作不会影响该纹理。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上是添加纹理的基本步骤。在实际应用中，可能需要考虑更多的细节，例如使用多个纹理、纹理过滤、MIP映射、多重渲染目标等。同时，还需要在着色器中使用纹理坐标来采样纹理，以便在渲染中应用纹理。</p><p>实际使用时需要先激活纹理插槽并绑定纹理对象：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0 <span class="token operator">+</span> slot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置纹理统一变量：</p><pre class="line-numbers language-unity" data-language="unity"><div class="caption"><span>shader</span></div><code class="language-unity">uniform sampler2D u_Texture;void main(){    vec4 texColor = texture(u_Texture, v_Texcoord);    color = texColor;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例</strong>：<br>Texture.h:</p><pre class="line-numbers language-h" data-language="h"><code class="language-h">#pragma once#include "Renderer.h"class Texture{private:    unsigned int m_RendererID;    std::string m_FilePath;    unsigned char* m_localBuffer;    int m_Width, m_Height, m_BPP;public:    Texture(const std::string&amp; path);    ~Texture();    void Bind(unsigned int slot = 0) const;    void Unbind() const;    inline int GetWidth() const { return m_Width; }    inline int GetHeight() const { return m_Height; }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Texture.cpp:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Texture.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STB_IMAGE_IMPLEMENTATION</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"vender\stb_image\stb_image.h"</span></span><span class="token class-name">Texture</span><span class="token double-colon punctuation">::</span><span class="token function">Texture</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>path<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_RendererID</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_FilePath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_localBuffer</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_Width</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_Height</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_BPP</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// Set Image flip flag bits</span>    <span class="token function">stbi_set_flip_vertically_on_load</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m_localBuffer <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_Width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_Height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_BPP<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA8<span class="token punctuation">,</span> m_Width<span class="token punctuation">,</span> m_Height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> m_localBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m_localBuffer<span class="token punctuation">)</span>        <span class="token function">stbi_image_free</span><span class="token punctuation">(</span>m_localBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Texture</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Texture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glDeleteTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Texture</span><span class="token double-colon punctuation">::</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0 <span class="token operator">+</span> slot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> m_RendererID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token class-name">Texture</span><span class="token double-colon punctuation">::</span><span class="token function">Unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="混合（Blending）"><a href="#混合（Blending）" class="headerlink" title="混合（Blending）"></a>混合（Blending）</h2><p>混合（Blending）是OpenGL中的一种渲染技术，用于将多个片元（像素）的颜色值合成到帧缓冲中。混合通常用于实现半透明、阴影、颜色叠加和其他特效。在混合中，每个片元的颜色和透明度（alpha）与已经存在于帧缓冲中的颜色进行组合，最终呈现在屏幕上。</p><p>使用混合的一般步骤：</p><ol><li><p><strong>启用混合</strong>：在使用混合之前，您需要在OpenGL上下文中启用混合功能。您可以使用 <code>glEnable(GL_BLEND)</code> 来启用混合。通常，这会在初始化OpenGL时进行设置。</p></li><li><p><strong>设置混合函数</strong>：混合函数（Blend Function）用于定义如何将新像素与背景像素混合。通常，您会使用 <code>glBlendFunc</code> 函数来设置混合函数。例如，<code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code> 用于标准的alpha混合，其中 <code>GL_SRC_ALPHA</code> 表示新像素的颜色的alpha通道，<code>GL_ONE_MINUS_SRC_ALPHA</code> 表示背景像素的颜色的alpha通道的补数。</p></li><li><p><strong>启用深度测试（可选）</strong>：如果您同时使用深度测试（Depth Testing），确保深度测试在混合之前执行，以确保像素按正确的顺序渲染。</p></li><li><p><strong>在片段着色器中处理混合</strong>：在片段着色器中，您可以使用特殊变量 <code>gl_FragColor</code>（或 <code>out</code> 变量）来表示片段的颜色。通过修改这个颜色，您可以实现混合效果。例如，根据透明度，您可以将新像素的颜色与背景像素的颜色混合，以产生透明效果。</p></li></ol><p>示例代码片段：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 启用混合</span><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_BLEND<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置混合函数</span><span class="token function">glBlendFunc</span><span class="token punctuation">(</span>GL_SRC_ALPHA<span class="token punctuation">,</span> GL_ONE_MINUS_SRC_ALPHA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 片段着色器中的混合示例</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 计算混合后的颜色</span>    vec4 newColor <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span>textureColor<span class="token punctuation">,</span> backgroundColor<span class="token punctuation">,</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>    gl_FragColor <span class="token operator">=</span> newColor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，<code>glEnable(GL_BLEND)</code> 启用混合，<code>glBlendFunc</code> 设置混合函数，然后在片段着色器中使用 <code>mix</code> 函数来计算混合后的颜色，并将结果赋给 <code>gl_FragColor</code>。</p><p>混合是一个强大的工具，可用于实现各种视觉效果，但也需要小心使用，因为不正确的混合设置可能会导致不期望的结果。根据您的具体需求，您可以尝试不同的混合函数和混合参数来获得所需的效果。</p><h2 id="模型视图投影矩阵（Model-View-Projection-Matrix，MVP）"><a href="#模型视图投影矩阵（Model-View-Projection-Matrix，MVP）" class="headerlink" title="模型视图投影矩阵（Model-View-Projection Matrix，MVP）"></a>模型视图投影矩阵（Model-View-Projection Matrix，MVP）</h2><p>在计算机图形学中，模型视图投影矩阵（Model-View-Projection Matrix，通常简写为MVP矩阵）是一种用于将三维物体的坐标变换到二维屏幕坐标的矩阵。MVP矩阵由三个部分组成：模型矩阵（Model Matrix）、视图矩阵（View Matrix）和投影矩阵（Projection Matrix）。这些矩阵协同工作，使您能够将三维物体从它们的本地坐标空间（模型坐标空间）转换到观察者的视图空间，最终将其投影到二维屏幕坐标。</p><p>下面是每个部分的简要解释：</p><ol><li><p><strong>模型矩阵（Model Matrix）</strong>：模型矩阵用于将物体的本地坐标转换为世界坐标。它描述了物体的位置、旋转和缩放。通常，模型矩阵会将物体从其局部坐标系变换到全局坐标系。</p></li><li><p><strong>视图矩阵（View Matrix）</strong>：视图矩阵定义了观察者的相机位置和方向。它将世界坐标转换为观察者的视图坐标，同时定义了观察方向和相机的位置。视图矩阵使您能够以不同的角度和位置查看场景中的物体。</p></li><li><p><strong>投影矩阵（Projection Matrix）</strong>：投影矩阵定义了观察体积，即可见场景的空间。它可以是正交投影矩阵（Orthographic Projection）或透视投影矩阵（Perspective Projection）。投影矩阵将视图坐标变换为标准化设备坐标（Normalized Device Coordinates，NDC），以便进行最终的屏幕投影。</p></li></ol><p>MVP矩阵的计算顺序通常如下：</p><ol><li><p>首先，将模型矩阵应用于物体的本地坐标，将其转换为世界坐标。</p></li><li><p>然后，将视图矩阵应用于世界坐标，将其变换为观察者的视图坐标。</p></li><li><p>最后，将投影矩阵应用于视图坐标，将其变换为标准化设备坐标，从而进行屏幕投影。</p></li></ol><p>这个MVP矩阵可以将物体从其本地坐标变换到最终的二维屏幕坐标，以进行渲染。</p><pre class="line-numbers language-none"><code class="language-none">uniform mat4 u_MVP;void main(){    gl_Position = u_MVP * positions;    v_Texcoord = texcoord;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 设置物体的本地坐标</span><span class="token keyword">float</span> positions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token number">128.0f</span><span class="token punctuation">,</span> <span class="token number">128.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 0</span>            <span class="token number">256.0f</span><span class="token punctuation">,</span> <span class="token number">128.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 1</span>            <span class="token number">256.0f</span><span class="token punctuation">,</span>  <span class="token number">256.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 2</span>            <span class="token number">128.0f</span><span class="token punctuation">,</span>  <span class="token number">256.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span>   <span class="token comment">// 3</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* Model-View-Projection Matrix */</span><span class="token comment">// 将投影矩阵应用于视图坐标，将其变换为标准化设备坐标，从而进行屏幕投影。</span>glm<span class="token double-colon punctuation">::</span>mat4 proj <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">ortho</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">640.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">480.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 将视图矩阵应用于世界坐标，将其变换为观察者的视图坐标。</span>glm<span class="token double-colon punctuation">::</span>mat4 view <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 将模型矩阵应用于物体的本地坐标，将其转换为世界坐标。</span>glm<span class="token double-colon punctuation">::</span>mat4 model <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      glm<span class="token double-colon punctuation">::</span>mat4 mvp <span class="token operator">=</span> proj <span class="token operator">*</span> view <span class="token operator">*</span> model<span class="token punctuation">;</span>shader<span class="token punctuation">.</span><span class="token function">SetUniformMatrix4f</span><span class="token punctuation">(</span><span class="token string">"u_MVP"</span><span class="token punctuation">,</span> mvp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G</title>
      <link href="/2023/09/28/5g/"/>
      <url>/2023/09/28/5g/</url>
      
        <content type="html"><![CDATA[<h1 id="5G关键技术"><a href="#5G关键技术" class="headerlink" title="5G关键技术"></a>5G关键技术</h1><h2 id="物理层技术"><a href="#物理层技术" class="headerlink" title="物理层技术"></a>物理层技术</h2><p><img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/202311071109358.png"></p><ul><li><p>传输信道</p><ul><li><p>下行传输信道</p><ol><li>广播信道（BCH，Broadcast Channel）</li><li>下行共享信道（DL-SCH，Downlink Share Channel）</li><li>寻呼信道（PCH，Paging Channel）</li></ol></li><li><p>上行传输信道</p><ol><li>上行共享信道（UL-SCH，Uplink Shared Channel）</li><li>随机接入信道（RACH，Random Access Channel）</li></ol></li></ul></li><li><p>物理信道</p><ol><li><p>物理下行共享信道(Physical Downlink Shared CHannel,,PDSCH)：用于下行数据传输。</p></li><li><p>物理下行控制信道(Physical Downlink Control CHannel,PDCCH)：用于下行控制信息传输，下行控制信息包括：接收下行数据(PDSCH)所需的调度决策以及允许UE传输上行数据(PUSCH)的调度授权。</p></li><li><p>物理广播信道(Physical Broadcast CHannel,PBCH)：用于UE接入网络所需的系统信息广播。</p></li><li><p>物理上行共享信道(Physical Uplink Shared CHannel,PUSCH)：用于承载终端设备上行数据，这些数据包括用户生成的语音、视频、文本消息、应用程序数据等。</p></li><li><p>物理上行控制信道(Physical Uplink Control CHannel,PUCCH)：用于传输上行控制信息，上行控制信息包括：HARQ反馈确认（指示下行传输是否成功）、调度请求（向网络请求用于上行传输的时频资源），以及用于链路自适应的下行信道状态信息。</p></li><li><p>物理随机接入信道(Physical Random Access CHannel,PRACH)：被UE用来请求建立连接，称为随机接入。</p></li></ol></li><li><p>物理信号</p><ul><li><p>下行物理信号</p><ol><li>解调参考信号(DM-RS)</li><li>相位跟踪参考信号(PT-RS)</li><li>信道状态信息参考信号(CSI-RS)</li><li>主同步信号(PSS)</li><li>辅同步信号(SSS)</li></ol></li><li><p>上行物理信号</p><ol><li>解调参考信号(DM-RS)</li><li>相位跟踪参考信号(PT-RS)</li><li>探测参考信号(SRS)</li></ol></li></ul></li></ul><h3 id="PUSCH"><a href="#PUSCH" class="headerlink" title="PUSCH"></a>PUSCH</h3><p>PUSCH（Physical Uplink Shared Channel）是一种物理上行共享信道，通常在LTE（Long-Term Evolution）和5G NR（New Radio）等移动通信系统中使用。PUSCH主要用于将终端设备（如手机或其他通信设备）的上行数据传输到基站或基础设施，以实现双向通信。</p><p>以下是有关PUSCH的关键信息：</p><ol><li><p><strong>用途</strong>：</p><ul><li>PUSCH用于承载终端设备上行数据，这些数据包括用户生成的语音、视频、文本消息、应用程序数据等。</li></ul></li><li><p><strong>信道类型</strong>：</p><ul><li>PUSCH是一个物理上行信道，它传输终端设备的上行数据。</li></ul></li><li><p><strong>多路访问方式</strong>：</p><ul><li>在LTE和5G NR等通信系统中，PUSCH通常采用多址访问方式（Multiple Access）来支持多个设备共享同一上行频带资源。在LTE中，采用SC-FDMA（Single-Carrier Frequency Division Multiple Access）作为上行多址访问技术，而在5G NR中，使用更高效的FDMA（Frequency Division Multiple Access）。</li></ul></li><li><p><strong>带宽分配</strong>：</p><ul><li>PUSCH的带宽可以根据网络需求和配置进行动态分配。带宽可以是连续的或离散的资源块，具体取决于通信系统的设计。</li></ul></li><li><p><strong>调制和编码</strong>：</p><ul><li>PUSCH中的数据通常经过调制和编码，以便在无线信道上传输。调制和编码的方式通常根据信道条件和配置而变化。</li></ul></li><li><p><strong>功率控制</strong>：</p><ul><li>PUSCH的传输功率通常受到功率控制机制的控制，以确保传输在可接受范围内，从而减少干扰和提高系统性能。</li></ul></li><li><p><strong>ACK/NACK反馈</strong>：</p><ul><li>在5G NR中，PUSCH上行链路可能用于传输设备的数据，同时还可以用于传输ACK/NACK（确认/否定）反馈，以指示接收端是否成功接收到下行数据。</li></ul></li><li><p><strong>调度和资源管理</strong>：</p><ul><li>网络基站根据调度算法和资源管理策略来分配PUSCH资源，以满足不同设备的上行传输需求。</li></ul></li></ol><blockquote><p>PUSCH是LTE和5G NR等移动通信系统中用于传输终端设备上行数据的重要信道。它通过多址访问方式支持多个设备共享上行频带资源，经过调制、编码和功率控制等处理，以确保高效的上行数据传输。网络基站根据资源管理策略来动态分配PUSCH资源，以满足不同设备的通信需求。</p></blockquote><h4 id="5G-PUSCH信道收发流程"><a href="#5G-PUSCH信道收发流程" class="headerlink" title="5G PUSCH信道收发流程"></a>5G PUSCH信道收发流程</h4><p>5G PUSCH 信道可以支持两种类型的波形，即 <a href="#cp-ofdm">CP-OFDM</a>波形和基于 DFT 扩展的 OFDM(DFT-Spread-OFDM, <a href="#dft-s-ofdm">DFT-S-OFDM</a>) 波形</p><p>CP-OFDM 属于多载波波形，可以更好地与 MIMO 技术相互结合，以增强系统的抗干扰能力，并且在接收端所需均衡算法的复杂度较低，使用一般的线性均衡便可实现较好的效果。CP-OFDM 波形可以支持多流传输，给高数据传输速率提供了可能。通常适用于近、中点应用场景。</p><p>DFT-S-OFD为单载波波形，能够提升覆盖性能，应用场景通常为远点，通过较低的峰均比 (Peak to Average Power Ratio, PAPR) 获得功率回退增益</p><p><strong>发送流程：</strong><br>  <img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/20231009112431.png" alt="PUSCH信道收发流程图"></p><ol><li><p><strong>上行数据生成</strong>：终端设备（用户设备）生成上行数据，这可以是从用户生成的语音、视频、文本消息、应用程序数据等。</p></li><li><p><strong>加扰（Scrambling）</strong>：加扰是通过与特定序列（一个由长度为31 的 Gold 序列生成的随机序列）异或操作来实现的。可以使干扰的特性近似于白噪声，且这种随机化非常有助于提升信道编码增益的利用率，增加数据的随机性和安全性。</p></li><li><p><strong>调制（Modulation）</strong>：经过加扰后的数据被调制成数字符号，通常采用QAM（Quadrature Amplitude Modulation）等调制方式，以在不同的调制阶数中传输数据。</p></li><li><p><strong>层映射（Layer Mapping）</strong>：如果系统采用多天线技术（例如MIMO，Multiple Input Multiple Output），则调制后的数据可以被分配到不同的传输层。层映射将数据分配到不同的发送天线，以提高通信质量和可靠性。</p></li><li><p><strong>转换预编码（Precoding）</strong>：对于MIMO系统，预编码技术可以在发射前对数据进行空间处理，以减少干扰并优化接收端的信号质量。</p></li><li><p><strong>预编码（Precoding）</strong>：数据被进一步处理，以满足系统要求，如波束赋形（beamforming）和天线选择。</p></li><li><p><strong>资源映射（Resource Mapping）</strong>：确定PUSCH信号在时域和频域上的资源分配。这是根据系统配置和资源分配信息完成的。</p></li><li><p><strong>符号生成（Symbol Generation）</strong>：基于资源映射信息，生成PUSCH符号。这些符号表示要发送的上行数据，包括承载数据和控制信息。</p></li><li><p><strong>天线发射</strong>：生成的PUSCH符号通过无线电前端传输到天线，最终通过无线信道发送给基站。这包括RF信号处理和无线电前端的调制、放大和发射。</p></li></ol><p><strong>接受流程：</strong><br>  <img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/202310101026353.png" alt="PUSCH信道接收流程图"></p><h4 id="5G解调参考信号DMRS"><a href="#5G解调参考信号DMRS" class="headerlink" title="5G解调参考信号DMRS"></a>5G解调参考信号DMRS</h4><p>在5G NR（New Radio）通信系统中，DMRS（Demodulation Reference Signal）是一种解调参考信号，用于协助接收端进行数据解调和信道估计。NR 上下行的业务信道和控制信道都需要解调参考信号（Demodulation ReferenceSignal，DM­RS）作为导频来进行信道估计和相干解调。DMRS的主要作用是提供了一种已知的信号，接收端可以利用它来估计信道条件和相位，以更准确地解码接收到的数据。</p><ol><li><p><strong>位置和分布</strong>：DMRS信号在物理资源块（Physical Resource Block）中的特定位置和分布是根据系统配置和波束赋形策略而确定的。在时域和频域上，DMRS通常分布在特定的位置，以便接收端能够准确识别和估计它们。</p></li><li><p><strong>频域上的DMRS</strong>：在频域上，DMRS通常出现在物理资源块的特定子载波上。这些子载波通常称为“DMRS端口”。频域上的DMRS用于进行信道估计和提供多天线传输（例如，MIMO）的参考。</p></li><li><p><strong>时域上的DMRS</strong>：在时域上，DMRS出现在特定的符号位置，通常在物理资源块的开头或结尾。它们用于同步和时域信道估计。</p></li><li><p><strong>DMRS符号结构</strong>：DMRS符号的结构通常是已知的，接收端知道如何解码它们。DMRS的结构包括特定的序列和调制方式。</p></li><li><p><strong>波束赋形</strong>：DMRS信号可以用于波束赋形（beamforming），其中接收端根据接收到的DMRS信号来调整天线的相位和权重，以获得更好的信号质量。</p></li><li><p><strong>信道估计</strong>：接收端可以使用DMRS信号来估计信道条件，包括信道增益、相位和多径传播信息。这些估计用于解码接收到的数据。</p></li><li><p><strong>干扰抑制</strong>：DMRS信号还可以用于干扰抑制。接收端可以识别DMRS信号，并将其从接收到的信号中去除，以减少干扰。</p></li></ol><blockquote><p>DMRS信号对于提高数据传输的可靠性和效率非常重要。</p></blockquote><blockquote><p>PUSCH是上行共享信道，即可传数据，又可传输PMI,CQI，RI等控制信息；PUCCH是上行控制信道，只能传输上性能控制信息，但不可以传输用户数据<br>PUCCH主要是周期性上报的，PUSCH主要是请求调度时使用。如果同时存在，那么PUSCH会覆盖掉PUCCH，在非载波聚合网络中，不能同时上报控制信息。</p></blockquote><h3 id="PUCCH"><a href="#PUCCH" class="headerlink" title="PUCCH"></a>PUCCH</h3><p>PUCCH（Physical Uplink Control Channel）物理上行控制信道，是在LTE（Long-Term Evolution）和5G移动通信系统中使用的一种无线物理信道，用于在上行链路上传输控制信息。PUCCH的主要任务是支持上行链路的调度、ACK/NACK（确认/否认）反馈、资源分配等控制信息的传输。</p><ol><li><p><strong>功能</strong>：PUCCH主要用于传输与调度和控制相关的信息。这包括：</p><ul><li><strong>调度信息</strong>：调度信息用于指导用户设备何时发送上行数据，以避免冲突和碰撞。</li><li><strong>ACK/NACK反馈</strong>：PUCCH用于传输接收到的下行数据包的确认（ACK）或否认（NACK）信息，以告知基站是否成功接收数据包。</li><li><strong>资源分配请求</strong>：PUCCH也可以用于请求上行资源分配，以便用户设备可以发送数据。</li></ul></li><li><p><strong>频段和资源</strong>：PUCCH的频段和资源在LTE和5G中都是灵活配置的，通常由基站进行调度。不同的子帧和符号用于传输不同类型的控制信息。</p></li><li><p><strong>调制和编码</strong>：PUCCH的调制和编码方案会根据具体的通信系统和配置而有所不同，但通常采用QPSK（Quadrature Phase Shift Keying）或BPSK（Binary Phase Shift Keying）等调制方式。</p></li><li><p><strong>传输时机</strong>：PUCCH的传输时机通常由基站进行调度和控制。传输时机可能会因不同的控制信息类型而异。</p></li><li><p><strong>功率控制</strong>：为了保证PUCCH的可靠传输，通常需要进行功率控制，以确保适当的信噪比。</p></li></ol><h4 id="上行控制信息"><a href="#上行控制信息" class="headerlink" title="上行控制信息"></a>上行控制信息</h4><p>PUCCH（Physical Uplink Control Channel）中包含各种上行控制信息，其中一些主要包括HARQ-ACK、SR、CSI。</p><ol><li><strong>HARQ-ACK（Hybrid Automatic Repeat Request - Acknowledgment）</strong>：<br>  HARQ（Hybrid Automatic Repeat Request）是一种混合自动重传请求技术，它结合了前向纠错编码（FEC）和自动重传请求（ARQ），以确保可靠的数据传输。</li></ol><p>  HARQ-ACK用于传输接收到的下行数据包的确认（ACK）或否认（NACK）信息。这是重要的反馈机制，告知基站是否成功接收到下行数据包。如果接收到ACK，则表示数据包已成功接收，如果接收到NACK，则表示需要重传数据包。</p><p>  它通常包括检错、纠错和应答等功能，以确保可靠的数据传输。</p><p>  HARQ的工作原理如下：</p><pre><code>1. **前向纠错编码（FEC）**：  在发送端，数据通常会经过前向纠错编码，以添加冗余信息，使接收端能够检测和纠正数据中的错误。这有助于减少在传输过程中发生的错误，提高数据的可靠性。2. **数据传输**：  经过FEC编码的数据被发送到接收端。在传输过程中，数据可能会受到干扰、噪声或其他问题的影响，导致错误。3. **接收端检测**：  接收端会检测接收到的数据，使用FEC编码的冗余信息来检测和纠正错误。如果数据经过检测后没有错误，接收端可以立即使用这些数据。4. **自动重传请求（ARQ）**：  如果接收端检测到数据包含错误，它可以向发送端发送自动重传请求（NACK），请求重新发送有问题的数据包。5. **重传**：  在收到NACK后，发送端会重新发送丢失或损坏的数据包。接收端会将这些新数据与之前的数据进行合并，以恢复丢失的部分。6. **循环**：  这个过程可以循环多次，直到接收端成功接收到正确的数据或达到最大重传次数。</code></pre><blockquote><p>HARQ的优势在于，它结合了FEC的纠错能力和ARQ的自动重传请求机制，以最大程度地提高数据的可靠性。这对于移动通信、数据传输和各种无线通信应用非常有用，因为它可以应对无线信道上的干扰和误差，确保数据能够在不可靠的环境中可靠传输。这种技术在LTE、5G等现代移动通信标准中得到广泛应用。</p></blockquote><p>  HARQ­ACK 反馈方案：</p><ul><li><p>半静态码本（Semi­state Codebook）</p></li><li><p>动态码本（Dynamic Codebook）</p></li></ul><ol start="2"><li><strong>SR（Scheduling Request）</strong>：<br>  SR用于请求上行资源，以便用户设备可以发送数据。当用户设备需要发送数据时，它可以向基站发送SR，以请求分配上行资源。基站可以根据SR来决定何时分配资源。</li></ol><p>  <strong>基站响应SR信号：</strong></p><ol><li><p><strong>用户设备发送SR</strong>：</p><ul><li>当用户设备需要上传数据时，它会发送SR，请求分配上行资源。SR通常会在PUCCH（Physical Uplink Control Channel）上发送。</li></ul></li><li><p><strong>PDCCH分配上行资源</strong>：</p><ul><li>基站接收到用户设备的SR后，会使用PDCCH来分配适当的上行资源。PDCCH用于向用户设备发送控制信息，包括上行资源分配信息。</li></ul></li><li><p><strong>PDCCH传输和解码</strong>：</p><ul><li>基站在特定的下行子帧中发送PDCCH，其中包含了上行资源分配信息，以满足用户设备的请求。</li><li>用户设备在其监听窗口内（通常是一个特定的子帧）监听PDCCH，并尝试解码其中的信息。</li></ul></li><li><p><strong>响应和数据传输</strong>：</p><ul><li>如果用户设备成功解码PDCCH中的上行资源分配信息，它将按照分配的资源和调度要求，使用PUSCH（Physical Uplink Shared Channel）来上传数据。</li><li>基站会监听用户设备的上传数据，并进行相关处理，如解码和数据交付。</li></ul></li><li><p><strong>回馈和调度</strong>：</p><ul><li>基站可以使用PDCCH来通知用户设备是否成功分配了上行资源，以及分配的资源的详细信息。用户设备收到这些信息后，会执行相应的数据传输。</li></ul></li><li><p><strong>CSI（Channel State Information）</strong>：<br>  CSI用于向基站提供信道状态信息，以帮助基站进行更好的资源分配和干扰协调。</p><ol><li><p><strong>CQI（Channel Quality Indicator）</strong>：CQI 是用于指示接收端（UE）所感知到的下行信道质量的指标。它通常以一种数值的形式表示，该数值反映了信道质量的好坏。CQI的值越高，表示信道质量越好，可以支持更高的数据传输速率。基站可以使用CQI信息来决定在某个时间和频率资源上分配多少比特数据，以满足不同UE的需求。</p></li><li><p><strong>PMI（Precoding Matrix Indicator）</strong>：PMI是指示预编码矩阵的指示器。预编码是在MIMO（Multiple-Input, Multiple-Output）系统中用于提高数据传输的技术。PMI告诉基站哪种预编码矩阵在当前信道条件下最适合使用，以最大程度地提高信号的可靠性和质量。</p></li><li><p><strong>RI（Rank Indicator）</strong>：RI是MIMO系统中的秩指示器，它指示了信道的秩，也就是信道中具有多少有效传输通道。RI告诉基站信道的多路径特性，基站可以根据RI来选择适当的编码方式和天线配置。</p></li></ol></li></ol><h4 id="Zadoff-­Chu序列"><a href="#Zadoff-­Chu序列" class="headerlink" title="Zadoff-­Chu序列"></a><a href="https://blog.csdn.net/HiWangWenBing/article/details/113752716">Zadoff-­Chu序列</a></h4><p>Zadoff-Chu序列是一个欧拉复数序列，通常用于无线通信系统中的信道估计、同步、多址识别和频域分配等应用。</p><p><strong>定义</strong>：<br>Zadoff-Chu序列可以表示为以下形式：</p><p>$$ZC(n, u, N_{\text{ZC}}) = e^{j \cdot \frac{\pi \cdot u \cdot n \cdot (n + 1)}{N_{\text{ZC}}}},$$</p><p>其中：</p><ul><li>$ZC(n, u, N_{\text{ZC}})$ 表示序列的第 $n$ 个元素。</li><li>$n$ 是序列的序列号，$0 &lt;= m &lt;= N_\text{ZC} - 1$。</li><li>$u$ 是一个整数，称为Zadoff-Chu序列的根指数。</li><li>$N_{\text{ZC}}$ 是Zadoff-Chu序列的长度。</li></ul><p><strong>性质</strong>：</p><ol><li><p><strong>恒包络</strong>：任意长度的ZC序列的信号的幅值是恒定的，这也意味着功率恒定。</p></li><li><p><strong>理想周期自相关</strong>：Zadoff-Chu序列是周期性的，具有周期 $N_{\text{ZC}}$。ZC序列循环移位N，如果N不等于ZC序列的长度（$N_{\text{ZC}}$），则移位后的序列和原序列零相关。</p></li><li><p><strong>良好的互相关性</strong>：Zadoff-Chu序列循环移位N后，原序列只与移位后的序列得良好的相关峰值，其它位置的序列相关峰值为0。除此之外，两个根如果是互质的，生成的序列相关峰值几乎为零</p></li><li><p><strong>傅立叶变换后仍是ZC序列</strong></p></li><li><p><strong>频域性质</strong>：Zadoff-Chu序列在频域中产生边瓣很小的谱，这有助于在频域上进行精确的信道估计。</p></li><li><p><strong>时间域性质</strong>：Zadoff-Chu序列在时间域中具有良好的自相干性，有助于同步和时间标定。</p></li><li><p><strong>多种根指数和长度</strong>：不同的根指数和长度可以生成不同种类的Zadoff-Chu序列，这提供了灵活性，适用于不同应用和场景。</p></li></ol><h4 id="PUCCH格式"><a href="#PUCCH格式" class="headerlink" title="PUCCH格式"></a>PUCCH格式</h4><p>PUCCH信道格式，是指PUCCH信道,在时域上占用多少个符号、在频域上占用多少子载波、通过什么编码方式承载要传输的UCI比特数据的一种约定。<br><img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/202310251111268.png"></p><h5 id="5G-NR的PUCCH格式"><a href="#5G-NR的PUCCH格式" class="headerlink" title="5G-NR的PUCCH格式"></a>5G-NR的PUCCH格式</h5><p><img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/202311061355379.png"></p><h3 id="PDSCH"><a href="#PDSCH" class="headerlink" title="PDSCH"></a>PDSCH</h3><h3 id="PDCCH"><a href="#PDCCH" class="headerlink" title="PDCCH"></a>PDCCH</h3><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><h3 id="OFDM"><a href="#OFDM" class="headerlink" title="OFDM"></a>OFDM</h3><blockquote><p>OFDM（Orthogonal Frequency Division Multiplexing）技术是一种在数字通信中广泛使用的调制和多路复用技术。它将高速数据流分为多个较低速的子信道，并在这些子信道上同时传输数据，从而提高了通信系统的性能和鲁棒性。以下是OFDM技术的关键特点和工作原理：</p></blockquote><ol><li><p><strong>子载波和频域分割</strong>：<br>  OFDM将整个带宽分成多个子载波，每个子载波通常是正交的。这些子载波之间的正交性使它们在频域上不会相互干扰，允许它们同时传输数据。</p></li><li><p><strong>符号调制</strong>：<br>  在每个子载波上，数据被调制成符号。通常采用QAM（Quadrature Amplitude Modulation）或PSK（Phase Shift Keying）等调制方式。</p></li><li><p><strong>正交性</strong>：<br>  OFDM中的子载波是正交的，这意味着它们之间没有互相干扰的交叉谱。这种正交性使得OFDM系统更能抵抗多径传播引起的符号间干扰。</p></li><li><p><strong>循环前缀</strong>：<br>  为了对抗多径传播，每个OFDM符号的前面会添加一个循环前缀（Cyclic Prefix）。这个前缀是从符号的尾部复制而来，用于确保接收端可以正确识别符号。</p></li><li><p><strong>时域和频域分离</strong>：<br>  OFDM通过使用快速傅立叶变换（FFT）在频域上进行调制和解调。每个子载波对应于FFT中的一个频率点，这使得OFDM能够在时域和频域上实现分离，从而简化了信号处理。</p></li><li><p><strong>抗多径传播</strong>：<br>  多径传播是信号在传播路径上反射和衍射引起的多个版本的信号到达接收器。OFDM的正交性和循环前缀有助于减少多径引起的符号间干扰，提高了系统的鲁棒性。</p></li><li><p><a href="#%E9%A2%91%E7%8E%87%E9%80%89%E6%8B%A9%E6%80%A7%E8%A1%B0%E8%90%BD"><strong>频率选择性衰落</strong></a>：<br>  OFDM可以有效处理频率选择性信道衰落，因为它将信道衰落分别应用于每个子载波，而不是整个带宽。</p></li><li><p><strong>资源分配和灵活性</strong>：<br>  OFDM系统可以通过灵活地分配子载波来适应不同的通信需求和信道条件。资源分配可以根据数据速率、优先级和质量等因素进行调整。</p></li></ol><p><strong>OFDM发射接收框图</strong><br>  <img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/202310101101323.png"></p><h4 id="导频（Pilot）"><a href="#导频（Pilot）" class="headerlink" title="导频（Pilot）"></a>导频（Pilot）</h4><blockquote><p>导频的作用在于帮助接收端更好地理解信道的特性，包括信道的频率响应、相位偏移和信道衰落等。这使得接收端能够更准确地解调和恢复原始数据，提高了通信系统的性能和可靠性。</p></blockquote><ol><li><p><strong>信道估计</strong>：导频是已知的信号，它们的值在发射端和接收端都是已知的。接收端可以利用导频信号来估计信道的衰落、相位偏移和其他特性。这有助于接收端更准确地恢复原始数据。通过比较接收到的导频值和已知的发送端导频值，接收端可以估计信道的影响，并进行信号解调和恢复。</p></li><li><p><strong>信道补偿</strong>：接收端可以使用导频估计的信道信息来对接收到的数据进行信道补偿。这意味着接收端可以校正信号的相位和幅度，以抵消信道引起的失真。这有助于提高数据的准确性和可靠性。</p></li><li><p><strong>自动增益控制（AGC）</strong>：导频信号还可以用于自动增益控制。接收端可以使用导频信号的强度信息来调整接收机的增益，以确保信号在适当的范围内，避免过载或信号弱化。</p></li><li><p><strong>频率偏移估计</strong>：导频信号还可以用于估计接收端和发射端之间的频率偏移。这对于抵消载波频率偏移非常重要，以便准确地解调数据。</p></li><li><p><strong>多天线系统</strong>：在多天线系统中，导频信号可以用于进行波束赋形和天线选择。接收端可以根据导频信号的反馈来确定哪些天线或波束组合提供了最好的通信质量。</p></li></ol><h4 id="虚载波"><a href="#虚载波" class="headerlink" title="虚载波"></a>虚载波</h4><blockquote><p>在OFDM（Orthogonal Frequency Division Multiplexing）技术中，虚载波（Null Subcarriers）是一些子载波，其上不传输有效数据。</p></blockquote><p>虚载波在OFDM系统中有以下几种重要作用：</p><ol><li><p><strong>频谱保护和避免干扰</strong>：虚载波用于保护OFDM系统的频谱免受邻近信号或其他干扰源的影响。通过保留一些子载波为空载波，OFDM系统可以减少与邻近频带信号之间的干扰，从而提高通信系统的鲁棒性。</p></li><li><p><strong>PAPR 控制</strong>：PAPR（Peak-to-Average Power Ratio）是指OFDM信号的峰值功率与平均功率之间的比值。在OFDM系统中，部分子载波的幅度可能很大，导致高PAPR，这会增加功率放大器的要求。通过使用虚载波，可以减小PAPR，减少功率放大器的压力，提高系统的能效。</p></li><li><p><strong>同步和定时</strong>：虚载波可以用于同步和定时。接收端可以通过检测虚载波的位置来实现时钟同步，以确保符号正确地对齐。这对于准确解调其他子载波上的数据非常重要。</p></li><li><p><strong>保护特定子载波</strong>：虚载波可以用于保护特定子载波，使其免受干扰或频谱混叠的影响。这对于特殊应用中的子载波保护非常有用，如导航信号或控制信号。</p></li><li><p><strong>系统灵活性</strong>：虚载波的存在提供了OFDM系统的灵活性。通过动态配置虚载波的位置和数量，OFDM系统可以适应不同的通信需求和信道条件。</p></li></ol><blockquote><p>虚载波在OFDM系统中发挥着重要的作用，包括频谱保护、PAPR控制、同步、保护特定子载波和系统灵活性。它们有助于提高系统性能、鲁棒性和可靠性，同时允许OFDM系统更好地适应不同的通信场景。</p></blockquote><h4 id="循环前缀（Cyclic-Prefix）"><a href="#循环前缀（Cyclic-Prefix）" class="headerlink" title="循环前缀（Cyclic Prefix）"></a>循环前缀（Cyclic Prefix）</h4><p>OFDM（Orthogonal Frequency Division Multiplexing）技术中添加CP（Cyclic Prefix，循环前缀）的主要作用是对抗多径传播引起的符号间干扰。多径传播是信号在传播路径上经历多次反射和衍射，导致接收端同时接收到多个版本的信号，这些版本具有不同的时延和相位。</p><blockquote><p>循环前缀是从前一个OFDM符号的尾部复制而来，长度通常是符号的一部分，一般为OFDM符号长度的一小部分。</p></blockquote><blockquote><p>前缀的目的是为了在多径传播引起的符号重叠之间创建一段”间隔”，以便接收端可以更容易地区分不同符号之间的干扰。</p></blockquote><p><strong>优点：</strong></p><ol><li><p><strong>抵抗多径传播</strong>：多径传播导致了符号间的时延扩散，即不同版本的信号以不同的时延到达接收端。这会导致符号间干扰，因为接收端无法准确分辨符号的边界。通过在每个OFDM符号的前面添加CP，接收端可以使用CP来消除时延扩散引起的符号间干扰。</p></li><li><p><strong>简化接收端处理</strong>：CP的存在简化了接收端的信号处理，因为接收端可以通过在时域上对接收到的信号进行循环相关操作来去除CP，然后使用快速傅立叶变换（FFT）将信号变换到频域。这使得信号处理更加有效和简单。</p></li><li><p><strong>提高系统性能</strong>：CP允许OFDM系统更好地应对多径传播和频率选择性衰落等信道特性。它提高了系统的鲁棒性和抗干扰性能，使OFDM在各种通信环境中都能有效地工作。</p></li><li><p><strong>减少PAPR</strong>：添加CP还有助于减少OFDM信号的峰均比（Peak-to-Average Power Ratio，PAPR）。PAPR是指信号的峰值功率与平均功率之间的比值。通过将信号扩展到CP中，可以减小信号的峰值功率，降低了对功率放大器的要求，从而提高了系统的能效。</p></li></ol><p>缺点：循环前缀会占用一定的频谱资源，导致频谱效率的降低</p><h3 id="多天线（MIMO）"><a href="#多天线（MIMO）" class="headerlink" title="多天线（MIMO）"></a>多天线（MIMO）</h3><h3 id="信道估计-均衡"><a href="#信道估计-均衡" class="headerlink" title="信道估计&amp;均衡"></a>信道估计&amp;均衡</h3><h3 id="时频资源"><a href="#时频资源" class="headerlink" title="时频资源"></a>时频资源</h3><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><blockquote><p>5G NR定义了灵活的子构架，时隙和字符长度可根据子载波间隔SCS灵活定义。</p></blockquote><p><img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/20438763-e1bb288f9c746261.png"></p><ul><li>无线帧 = 10（ms）</li><li>子帧 = 1 （ms）</li><li>时隙 = 12/14个符号周期（ms）</li><li>符号周期 = 1/SCS + CP长度（ms）</li></ul><h5 id="子帧类型"><a href="#子帧类型" class="headerlink" title="子帧类型"></a>子帧类型</h5><p><img src="https://raw.githubusercontent.com/sparrowyou/picture_bed/main/blog_image/20438763-9b670c4509727259.png"></p><table><thead><tr><th align="center">$\mu$</th><th align="center">$N_{symb}^{slot}$</th><th align="center">$N_{slot}^{frame, \mu}$</th><th align="center">$N_{slot}^{subframe, \mu}$</th><th align="center">slot</th></tr></thead><tbody><tr><td align="center">0(15kHz)</td><td align="center">14</td><td align="center">10</td><td align="center">1</td><td align="center">1ms</td></tr><tr><td align="center">1(30kHz)</td><td align="center">14</td><td align="center">20</td><td align="center">2</td><td align="center">0.5ms</td></tr><tr><td align="center">2(60kHz)</td><td align="center">12/14</td><td align="center">40</td><td align="center">4</td><td align="center">0.25ms</td></tr><tr><td align="center">3(120kHz)</td><td align="center">14</td><td align="center">80</td><td align="center">8</td><td align="center">0.125ms</td></tr><tr><td align="center">4(240kHz)</td><td align="center">14</td><td align="center">160</td><td align="center">16</td><td align="center">0.0625ms</td></tr></tbody></table><blockquote><p>随着子载波间距的增大，时隙会变短，数据调度粒度就更小，更适合于时延要求高的传输</p></blockquote><h5 id="时隙配置"><a href="#时隙配置" class="headerlink" title="时隙配置"></a>时隙配置</h5><ul><li>时隙类型<ul><li>上行时隙（Uplink Slot）：<br>上行时隙用于用户设备向基站传输数据。允许终端设备发送数据，以便与网络进行双向通信。</li><li>下行时隙（Downlink Slot）：<br>下行时隙用于基站向用户设备传输数据。时隙用于网络向用户提供服务和内容。</li><li>灵活时隙（Flexible Slot）：<br>可以根据实际通信需求和资源利用情况来分配和管理时隙的能力。</li></ul></li></ul><h3 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h3><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="CP-OFDM"><a href="#CP-OFDM" class="headerlink" title="CP-OFDM"></a>CP-OFDM</h3><p>CP-OFDM（Cyclic Prefix Orthogonal Frequency Division Multiplexing）是一种调制和多路复用技术，常用于无线通信系统，特别是在Wi-Fi、LTE（Long-Term Evolution）和5G NR（New Radio）等标准中。<br>CP-OFDM的主要特点是在每个OFDM符号的前面添加了一个循环前缀（Cyclic Prefix），用于对抗多径传播引起的符号间干扰。</p><p>以下是CP-OFDM的一些关键特点和工作原理：</p><ol><li><p><strong>多载波调制</strong>：CP-OFDM将数据分成多个子载波，每个子载波都携带一部分数据。这种多载波调制技术允许在不同的子载波上同时传输数据，提高了频谱效率。</p></li><li><p><strong>循环前缀</strong>：CP-OFDM在每个OFDM符号的前面添加了一个循环前缀，也称为CP。这个前缀是从OFDM符号的尾部复制而来的，用于对抗多径传播引起的符号间干扰。循环前缀的长度通常是符号的一部分，一般为OFDM符号长度的一小部分。</p></li><li><p><strong>时域和频域分离</strong>：CP-OFDM通过使用快速傅立叶变换（FFT）在频域上进行调制和解调。每个子载波都由FFT中的一个频率点表示，这使得CP-OFDM能够实现时域和频域分离，从而简化了信号处理。</p></li><li><p><strong>对抗多径传播</strong>：多径传播是信号在传播路径上反射和衍射引起的多个版本的信号到达接收器。CP-OFDM的循环前缀可以抵消多径引起的符号间干扰，从而提高了系统的鲁棒性和抗干扰能力。</p></li><li><p><strong>频率选择性衰落</strong>：CP-OFDM可以有效地处理频率选择性信道衰落，因为它将信道衰落作用在每个子载波上，而不是整个带宽上。</p></li></ol><blockquote><p>CP-OFDM是许多现代通信系统的核心调制技术之一，它在面对多径传播和频率选择性衰落等信道特性时表现出色。它已广泛用于无线局域网（Wi-Fi）、蜂窝移动通信（LTE和5G NR）以及其他通信标准中。<br>通过使用CP-OFDM，这些系统能够在复杂的无线环境中实现高效的数据传输。</p></blockquote><h3 id="DFT-S-OFDM"><a href="#DFT-S-OFDM" class="headerlink" title="DFT-S-OFDM"></a>DFT-S-OFDM</h3><p>DFT-Spread-OFDM（DFT-Spread Orthogonal Frequency Division Multiplexing）是一种改进的OFDM波形设计，旨在提高OFDM系统的抗多径传播和频率选择性衰落等信道效应的性能。<br>DFT-S-OFDM的核心思想是在标准OFDM符号之前引入一个DFT扩展序列，这个序列经过离散傅立叶变换（DFT）后会生成一组频域上的增强信号，从而增强了信号的鲁棒性。</p><p>以下是关于DFT-Spread-OFDM的一些关键特点和工作原理：</p><ol><li><p><strong>DFT扩展序列</strong>：DFT-S-OFDM引入了一个DFT扩展序列，通常是长度为N的复数序列，其中N通常等于OFDM子载波的数量。这个序列经过离散傅立叶变换后生成一组频域上的复数权重，用于增强OFDM符号的频域表示。</p></li><li><p><strong>频域增强</strong>：DFT扩展序列的频域权重用于加权OFDM子载波，使得部分子载波的能量增强，而其他子载波的能量减小。这样，信号在频域上具有更均匀的功率分布，减少了峰值功率，提高了抗峰均比（PAPR）性能。</p></li><li><p><strong>抗多径传播</strong>：DFT-S-OFDM的频域增强特性有助于减少多径传播引起的符号间干扰，提高了系统的抗多径传播性能。</p></li><li><p><strong>频率选择性衰落</strong>：由于频域增强，DFT-S-OFDM在频率选择性衰落信道中表现更出色。它能够更好地适应信道的频率响应变化。</p></li><li><p><strong>DFT-S-OFDM符号生成</strong>：生成DFT-S-OFDM符号的过程包括将数据符号与DFT扩展序列进行元素相乘，然后进行逆离散傅立叶变换（IDFT）以生成时域上的OFDM符号。</p></li><li><p><strong>系统复杂性</strong>：尽管DFT-S-OFDM提供了一些性能优势，但它也增加了系统的复杂性，需要在发送端和接收端进行DFT和IDFT等额外的计算操作。</p></li></ol><blockquote><p>DFT-S-OFDM是一种用于提高OFDM系统性能的技术，特别适用于具有频率选择性衰落和多径传播的无线通信环境。它在LTE和5G NR等通信标准中得到了广泛应用，以提高系统的鲁棒性和性能。</p></blockquote><h3 id="频率选择性衰落"><a href="#频率选择性衰落" class="headerlink" title="频率选择性衰落"></a>频率选择性衰落</h3><blockquote><p>频率选择性衰落（Frequency Selective Fading）是一种无线通信信道的特性，其中信号在频率上以不同的方式衰减或发生多径传播。这意味着不同频率成分的信号在传播路径上会经历不同的衰落和相位变化。频率选择性衰落是由多径传播和传播介质的不均匀性引起的，它通常在高速移动通信和室内通信环境中出现。</p></blockquote><p>频率选择性衰落的主要原因包括以下几点：</p><ol><li><p><strong>多径传播</strong>：当无线信号传播时，它可以通过多条不同的路径到达接收器，其中包括直射路径和反射、折射路径。这些路径具有不同的长度，导致了多径传播，其中不同频率成分的信号以不同的相位到达接收器。这导致了频率选择性衰落。</p></li><li><p><strong>传播介质的不均匀性</strong>：不同的频率成分受到传播介质（如大气、建筑物或地形）的影响可能会有所不同，导致频率选择性的传播损耗。这意味着一些频率可能会受到较大的衰减，而其他频率可能相对较少衰减。</p></li><li><p><strong>多普勒效应</strong>：高速移动通信设备引入了多普勒效应，其中发射机和接收机之间的相对速度会导致频率偏移。这会导致信号的不同频率成分经历不同的多普勒频移，进一步增加了频率选择性衰落的效应。</p></li></ol><p>频率选择性衰落对无线通信系统具有挑战性，因为它会引起信号失真、多路径干扰和高比特错误率。为了应对频率选择性衰落，通信系统采用了各种技术，如均衡、信道编码、频谱保护和引入导频等，以提高通信质量和鲁棒性。这些技术可以减轻频率选择性衰落引起的信号质量下降，并提高通信系统的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信 </tag>
            
            <tag> 5G </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习</title>
      <link href="/2023/09/28/c-study-note/"/>
      <url>/2023/09/28/c-study-note/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言复习笔记"><a href="#C语言复习笔记" class="headerlink" title="C语言复习笔记"></a><a href="https://www.runoob.com/cprogramming/c-tutorial.html" title="菜鸟教程">C语言复习笔记</a></h1><!-- * vscode终端输出中文乱码解决：  vscode的终端下输入chcp 65001表示，将当前终端的编码方式改为utf-8这样就与vscode的编码一致了。 --><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="C程序结构"><a href="#C程序结构" class="headerlink" title="C程序结构"></a>C程序结构</h3><ul><li>预处理器指令</li><li>函数</li><li>变量</li><li>语句&amp;表达式</li><li>注释</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span>  <span class="token expression">\\ 预处理器指令</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>      \\ main：函数；<span class="token keyword">void</span>：变量<span class="token punctuation">{</span>    \<span class="token operator">*</span> 输出<span class="token string">"hello world!"</span> <span class="token operator">*</span>\    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   \\ 语句<span class="token operator">&amp;</span>表达式    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C数据类型"><a href="#C数据类型" class="headerlink" title="C数据类型"></a>C数据类型</h3><table><thead><tr><th align="center">类型</th><th align="center">存储大小/字节</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">-128<del>127 or 0</del>255</td></tr><tr><td align="center">signed char</td><td align="center">1</td><td align="center">-128~127</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">0~255</td></tr><tr><td align="center">int</td><td align="center">2 or 4</td><td align="center">-32768<del>32767 or -2147483648</del>2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">2 or 4</td><td align="center">0<del>65535 or 0</del>4294967295</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">-32768~32767</td></tr><tr><td align="center">unsigned short</td><td align="center">2</td><td align="center">0~65535</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">-2147483648~2147483647</td></tr><tr><td align="center">unsigned long</td><td align="center">4</td><td align="center">0~4294967295</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">1.2e-38~3.4e+38</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">2.3e-308~1.7e+308</td></tr><tr><td align="center">long double</td><td align="center">16</td><td align="center">3.4e-4932~1.1e+4932</td></tr></tbody></table><ul><li><strong>void变量</strong> <ul><li>函数返回空<blockquote><p>不返回值的函数的返回类型为空</p></blockquote></li><li>函数参数为空<blockquote><p>不带参数的函数可以接受一个<code>void</code></p></blockquote></li><li>指针指向void<blockquote><p>不返回值的函数的返回类型为空</p></blockquote></li></ul></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。<br>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。<br>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。<br>常量可以直接在代码中使用，也可以通过定义常量来使用。</p></blockquote><ul><li><strong>整数常量</strong><blockquote><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表&gt; 示十六进制，0 表示八进制，不带前缀则默认表示十进制。<br>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数 （unsigned），L 表示长整数（long）。<br>后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">212</span>       <span class="token comment">/*合法的*/</span><span class="token number">215u</span>      <span class="token comment">/*合法的*/</span><span class="token number">0xFeeL</span>    <span class="token comment">/*合法的*/</span><span class="token number">078</span>       <span class="token comment">/*非法的：8不是八进制的数字*/</span><span class="token number">032UU</span>     <span class="token comment">/*非法的：不能重复后缀*/</span><span class="token number">85</span>        <span class="token comment">/*十进制*/</span><span class="token number">0213</span>      <span class="token comment">/*八进制*/</span><span class="token number">0x4b</span>      <span class="token comment">/*十六进制*/</span><span class="token number">30</span>        <span class="token comment">/*整数*/</span><span class="token number">30u</span>       <span class="token comment">/*无符号整数*/</span><span class="token number">301</span>       <span class="token comment">/*长整数*/</span><span class="token number">30u</span><span class="token number">1</span>      <span class="token comment">/*无符号长整数*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>浮点常量</strong><blockquote><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。<br>可以使用小数形式或者指数形式来表示浮点常量。<br>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。<br>当使用指数形式表示时，必须包含小数点、指数，或同时包含两者。<br>带符号的指数是用e或E引入的。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">3.14159</span>     <span class="token comment">/*合法的*/</span><span class="token number">314159E-5L</span>  <span class="token comment">/*合法的*/</span><span class="token number">510</span>E        <span class="token comment">/*非法的：不完整的指数*/</span><span class="token number">210f</span>        <span class="token comment">/*非法的：没有小数或指数*/</span><span class="token punctuation">.</span>e55        <span class="token comment">/*非法的：缺少整数或分数*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>定义常量</strong><ol><li>#define预处理器定义</li><li>const关键字：<code>const type variable = value;</code></li></ol></li></ul><hr><h3 id="C存储类"><a href="#C存储类" class="headerlink" title="C存储类"></a>C存储类</h3><ul><li><p><strong>auto</strong></p><blockquote><p>auto存储类是所有局部变量默认的存储类。<br>定义在函数中的变量默认为uto存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token keyword">int</span> mount    <span class="token keyword">auto</span> <span class="token keyword">int</span> mount<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>register</strong></p><blockquote><p>register存储类定义存储在寄存器的局部变量，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在RAM中的。<br>在需要频繁访问的变量上使用register存储类可以提高程序的运行速度。<br><code>register int variance</code><br>还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p></blockquote></li><li><p><strong>static</strong></p><blockquote><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。<br>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p></blockquote><blockquote><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p></blockquote><blockquote><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p></blockquote><blockquote><p>静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token comment">/* 函数声明 */</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">/* 全局变量 - static 是默认的 */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次* 每次调用函数 'func1' 'thingy' 值不会被重置。*/</span>                <span class="token keyword">static</span> <span class="token keyword">int</span> thingy<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>thingy<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" thingy 为 %d ， count 为 %d\n"</span><span class="token punctuation">,</span> thingy<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>extern</strong></p><blockquote><p>extern 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，<br>而只是指示编译器该变量在其他文件中定义。</p></blockquote><blockquote><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。<br>当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p></blockquote><blockquote><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。<br>可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</p></blockquote></li></ul><hr><h3 id="C运算符"><a href="#C运算符" class="headerlink" title="C运算符"></a>C运算符</h3><ul><li><strong>算术运算符</strong><ul><li>基本运算：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>。</li><li><code>++</code>，<code>--</code>。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* a++与++a的区别 */</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 先赋值后计算</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"运算后b的值为%d,运算后a的值为%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token operator">++</span>a<span class="token punctuation">;</span>    <span class="token comment">// 先计算后赋值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"运算后b的值为%d,运算后a的值为%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><strong>位运算符</strong><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与操作，按二进制位进行”与”运算。</td><td>(A <code>&amp;</code> B) 将得到 12，即为 0000 1100</td></tr><tr><td>`</td><td>`</td><td>按位或运算符，按二进制位进行”或”运算。</td></tr><tr><td><code>\^</code></td><td>异或运算符，按二进制位进行”异或”运算。</td><td>(A <code>^</code> B) 将得到 49，即为 0011 0001</td></tr><tr><td><code>~</code></td><td>取反运算符，按二进制位进行”取反”运算。</td><td>(<code>~</code>A ) 将得到 -61，即为 1100 0011</td></tr><tr><td><code>&lt;&lt;</code></td><td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td><td>A <code>&lt;&lt;</code> 2 将得到 240，即为 1111 0000</td></tr><tr><td><code>&gt;&gt;</code></td><td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td>A <code>&gt;&gt;</code> 2 将得到 15，即为 0000 1111</td></tr></tbody></table></li><li><strong>其他运算符</strong><table><thead><tr><th align="center">运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">sizeof(x)</td><td align="center">返回x占存储空间的大小</td></tr><tr><td align="center">&amp;</td><td align="center">返回变量的地址</td></tr><tr><td align="center">*</td><td align="center">指向一个变量</td></tr><tr><td align="center">?:</td><td align="center">条件取值</td></tr></tbody></table><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a所占存储空间的大小为：%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*ptr的取值为：%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">20</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b的值为：%d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">20</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b的值为：%d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。<br>数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p></blockquote><ul><li><p><strong>数组声明</strong><br><code>type arrayName [ arraySize ];</code></p><blockquote><p>arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。<br>eg. <code>double books[6];</code></p></blockquote></li><li><p><strong>数组初始化</strong></p><ul><li><code>books[6] = [110, 120, 119, 666, 777, 888]</code></li></ul></li><li><p><strong>访问数组元素</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">char</span> books<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> books<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li><strong>二维数组存放字符串，读取时可当一维数组使用。</strong><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">char</span> names<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"马超"</span><span class="token punctuation">,</span><span class="token string">"关平"</span><span class="token punctuation">,</span><span class="token string">"赵云"</span><span class="token punctuation">,</span><span class="token string">"张飞"</span><span class="token punctuation">,</span><span class="token string">"关羽"</span><span class="token punctuation">,</span><span class="token string">"刘备"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"悍将名称：%s\n"</span><span class="token punctuation">,</span>names<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>二维数组在内存上的存放方法</strong><br>二维数组在逻辑上是方阵，由行和列组成。<br>但是二维数组在物理上是线性的，按行来依次进行存放，内存是连续的。<br>二维数组名的步长是一行的长度。<pre class="line-numbers language-c" data-language="c"><code class="language-c">age <span class="token operator">+</span> <span class="token number">1</span> address is <span class="token number">00</span>EFFC04age <span class="token operator">+</span> <span class="token number">2</span> address is <span class="token number">00</span>EFFC14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>因为每一行有四个元素，每个int类型的元素占四个字节，一行有16个字节，<br>所以数组名age加1后地址增加了16个字节说明数组名的步长位一行的长度。</p></blockquote>具体到每一个元素加1的时候，地址增加的是一个元素所占字节的大小，因此元素的步长即为元素本身的大小。<pre class="line-numbers language-c" data-language="c"><code class="language-c">age<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0</span> address is <span class="token number">00</span>EFFC14age<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> address is <span class="token number">00</span>EFFC18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>例子：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>age<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"age + %d address is %p\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span> age <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>age<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>age<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"age[%d][0] + %d address is %p\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token operator">&amp;</span>age<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="二维数组传递给函数"><a href="#二维数组传递给函数" class="headerlink" title="二维数组传递给函数"></a>二维数组传递给函数</h4><ol><li>第一维的长度可以不指定，但必须指定第二维的长度：<br>  <code>void print_a(int a[][5], int n, int m)</code><blockquote><p>编译器是这样处理数组的：<br>设有数组 <code>int a[m][n]</code>，如果要访问 <code>a[i][j ]</code>的值，编译器的寻址方式为:<br> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">+</span>j<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意 n 为第二维的维数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p></blockquote></li><li>指向一个有5个元素一维数组的指针：<br>  <code>void print_b(int (*a)[5], int n, int m)</code><blockquote><p>a是一个指向整数数组的指针，它有5列。因为使用了指针算法，所以可以使用一个单独的指针来访问二维数组中的元素。</p></blockquote><blockquote><p>具体来说，<code>(*a)[5]</code>表示一个指向整数数组的指针，该数组有5列。我们可以将其拆分为以下步骤：</p></blockquote><ol><li><code>(*a)</code>：这将解引用指针，从而获得整数数组的地址。</li><li><code>(*a)[5]</code>：这将解引用整数数组的地址，并表示该数组有5列。</li></ol></li><li>利用数组是顺序存储的特性,通过降维来访问原数组:<br><code>void print_c(int *a, int n, int m)</code><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> i <span class="token operator">*</span> col <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>*(arr + i * col + j)</code>是指针算法，用于访问二维数组中的元素。在这个例子中，<code>arr</code>是一个指向整数的指针，<code>i</code>和<code>j</code>是循环变量，<code>col</code>是列数。因为我们使用了指针算法，所以我们可以使用一个单独的指针来访问二维数组中的元素，而不需要使用两个嵌套的循环。</p></blockquote><blockquote><p>具体来说，<code>*(arr + i * col + j)</code>等价于<code>arr[i][j]</code>。我们可以将其拆分为以下步骤：</p></blockquote><ol><li><code>arr + i * col</code>：这将指针移动到第i行的开头。</li><li><code>*(arr + i * col)</code>：这将解引用指针，从而获得第i行的地址。</li><li><code>*(arr + i * col + j)</code>：这将解引用第i行的地址，并将指针移动到第j列。</li></ol></li></ol><hr><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a><a href="https://www.runoob.com/cprogramming/c-pointers.html">指针</a></h3><blockquote><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。<br>指针也就是内存地址，指针变量是用来存放内存地址的变量。</p></blockquote><p><strong>形式</strong>：<code>type *var_name;</code></p><pre class="line-numbers language-none"><code class="language-none">int    *ip;    /* 一个整型的指针 */double *dp;    /* 一个 double 型的指针 */float  *fp;    /* 一个浮点型的指针 */char   *ch;    /* 一个字符型的指针 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2014/09/c-pointer.png" alt="指针图解"></p><ul><li><strong>null指针</strong><br>在变量声明的时候，如果没有确切的地址可以赋值，赋为 NULL 值的指针被称为空指针。</li></ul><h4 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h4><p>C 指针是一个用数值表示的地址。因此可以对指针进行四种算术运算：<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>。</p><ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。<br>列子：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span>  var<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span>  i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token comment">/* 指针中的数组地址 */</span>  ptr <span class="token operator">=</span> var<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储地址：var[%d] = %p\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储值：var[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 指向下一个位置 */</span>      ptr<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，<br>比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</li></ul><h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p>  数组<code>a[ ]</code>的数组名<code>a</code>是一个指向<code>&amp;a[0]</code>的指针，所以可以用指向数组的指针来表示数组：<br>  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span>\<span class="token operator">*</span> 下面几种表示等价 <span class="token operator">*</span>\a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>a <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  例子：<br>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">/* 带有 5 个元素的整型数组 */</span>  <span class="token keyword">double</span> balance<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1000.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">17.0</span><span class="token punctuation">,</span> <span class="token number">50.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  p <span class="token operator">=</span> balance<span class="token punctuation">;</span>  <span class="token comment">/* 输出数组中每个元素的值 */</span>  <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"使用指针的数组值\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(p + %d) : %f\n"</span><span class="token punctuation">,</span>  i<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"使用 balance 作为地址的数组值\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(balance + %d) : %f\n"</span><span class="token punctuation">,</span>  i<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>balance <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组：存储指向 int 或 char 或其他数据类型的指针的数组。<br>指针数组声明：<code>type *p[];</code><br>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>names<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>                   <span class="token string">"Zara Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Hina Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Nuha Ali"</span><span class="token punctuation">,</span>                   <span class="token string">"Sara Ali"</span><span class="token punctuation">,</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of names[%d] = %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果指针数组中的元素是字符串，那么每个元素都是一个指向字符数组的指针。</p></blockquote><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。<br>当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。<br>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符。<br><img src="https://www.runoob.com/wp-content/uploads/2014/09/c-pointerxxxxx.png" alt="指向指针的指针"><br>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span>  V<span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token operator">*</span>Pt1<span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token operator">*</span><span class="token operator">*</span>Pt2<span class="token punctuation">;</span>      V <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>      <span class="token comment">/* 获取 V 的地址 */</span>    Pt1 <span class="token operator">=</span> <span class="token operator">&amp;</span>V<span class="token punctuation">;</span>      <span class="token comment">/* 使用运算符 &amp; 获取 Pt1 的地址 */</span>    Pt2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Pt1<span class="token punctuation">;</span>      <span class="token comment">/* 使用 pptr 获取值 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"var = %d\n"</span><span class="token punctuation">,</span> V <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Pt1 = %p\n"</span><span class="token punctuation">,</span> Pt1 <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*Pt1 = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>Pt1 <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Pt2 = %p\n"</span><span class="token punctuation">,</span> Pt2 <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"**Pt2 = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>Pt2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指针函数与回调函数"><a href="#指针函数与回调函数" class="headerlink" title="指针函数与回调函数"></a>指针函数与回调函数</h4><ul><li><strong>指针函数</strong><br>函数指针是指向函数的指针变量。<br>函数指针可以像一般函数一样，用于调用函数、传递参数。<br>函数指针变量的声明：<br><code>typedef int (*fun_ptr)(int,int);</code><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>operation<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    operation <span class="token operator">=</span> add<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    operation <span class="token operator">=</span> subtract<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d - %d = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    operation <span class="token operator">=</span> multiply<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d * %d = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    operation <span class="token operator">=</span> divide<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d / %d = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>回调函数</strong><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int Callback_1(int x) // Callback Function 1{    printf("Hello, this is Callback_1: x = %d ", x);    return 0;}int Callback_2(int x) // Callback Function 2{    printf("Hello, this is Callback_2: x = %d ", x);    return 0;}int Callback_3(int x) // Callback Function 3{    printf("Hello, this is Callback_3: x = %d ", x);    return 0;}int Handle(int y, int (*Callback)(int)){    printf("Entering Handle Function. ");    Callback(y);    printf("Leaving Handle Function. ");}int main(){    int a = 2;    int b = 4;    int c = 6;    printf("Entering Main Function. ");    Handle(a, Callback_1);    Handle(b, Callback_2);    Handle(c, Callback_3);    printf("Leaving Main Function. ");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。<br>定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。<br>每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。</p><ul><li><p>枚举语法定义格式为：<br><code>enum　枚举名　{枚举元素1,枚举元素2,……};</code></p></li><li><p>枚举变量的定义:</p><ol><li>先定义枚举类型，再定义枚举变量 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">DAY</span><span class="token punctuation">{</span>      MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> FRI<span class="token punctuation">,</span> SAT<span class="token punctuation">,</span> SUN<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">DAY</span> day<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>定义枚举类型的同时定义枚举变量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">DAY</span><span class="token punctuation">{</span>      MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> FRI<span class="token punctuation">,</span> SAT<span class="token punctuation">,</span> SUN<span class="token punctuation">}</span> day<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>省略枚举名称，直接定义枚举变量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span><span class="token punctuation">{</span>      MON<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> FRI<span class="token punctuation">,</span> SAT<span class="token punctuation">,</span> SUN<span class="token punctuation">}</span> day<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><hr><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。<br>由于在数组的末尾存储了空字符 \0，所以字符数组的大小比字符串的字符数多一个。<br><strong>字符串声明：</strong><br><code>char str[] = {'h','e','l','l','o',' 'w','o','r','l','d','!'}</code></p><blockquote><p>s声明时不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾。</p></blockquote><p><code>char str[] = "hello world!"</code></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a><a href="https://www.runoob.com/cprogramming/c-structures.html">结构体</a></h3><p>结构是 C 编程中一种用户自定义的可用的数据类型，它允许存储不同类型的数据项。<br>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><ul><li><p><strong>结构体定义</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tag</span> <span class="token punctuation">{</span>      \\ tag为结构体的标签名    member<span class="token operator">-</span>list   \\ 变量定义    member<span class="token operator">-</span>list     member<span class="token operator">-</span>list      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> variable<span class="token operator">-</span>list <span class="token punctuation">;</span> \\ 结构变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个</p></blockquote></li><li><p><strong>结构体变量初始化</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Books</span><span class="token punctuation">{</span>  <span class="token keyword">char</span>  title<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span>  author<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">char</span>  subject<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span>   book_id<span class="token punctuation">;</span><span class="token punctuation">}</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"C 语言"</span><span class="token punctuation">,</span> <span class="token string">"RUNOOB"</span><span class="token punctuation">,</span> <span class="token string">"编程语言"</span><span class="token punctuation">,</span> <span class="token number">123456</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>结构体的访问</strong><br>使用成员访问运算符（.）访问结构的成员。成员访问运算符是结构变量名称和要访问的结构成员之间的一个句号。<br><code>variable-list.member-list;</code></p><blockquote><p>. 是成员（分量）运算符，它在所有的运算符中优先级最高，因此可以把 <code>variable-list.member-list </code>作为一个整体来看待。</p></blockquote></li><li><p><strong>指向结构的指针</strong><br>定义：<code>struct tag *variable_pointer</code><br>使用指向该结构的指针访问结构的成员：</p><ol><li>结构体变量.成员名</li><li>(*p).成员名</li><li>p-&gt; 成员名(-&gt; 称为指向运算符)</li></ol></li><li><p><strong>结构体数组</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>stu<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a><a href="https://www.runoob.com/w3cnote/c-structures-intro.html">链表</a></h3><p>链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。<br>链表有一个 头指针变量(如果不提供 头指针 head 则整个链表无法访问。)，它存放一个地址，该地址指向一个元素，链表中每一个元素称为 结点，<br>每个结点都应包括两个部分，一为用户需要用的实际数据，二为下一个结点的地址。<br>可以看出，头指针 head 指向第一个元素，第一个元素又指向第二个元素，。。。。<br>直到最后一个元素，该元素不再指向其他元素，它称为 表尾，它的地址部分放一个 NULL（表示 空地址）链表到此结束。</p><ul><li>简单链表示例<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> num<span class="token punctuation">;</span>    <span class="token keyword">float</span> score<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">99101</span><span class="token punctuation">;</span> a<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">89.5</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">99103</span><span class="token punctuation">;</span> b<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">99107</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">85</span><span class="token punctuation">;</span><span class="token comment">//对结点的 num 和 score 成员赋值</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//将结点 a 的起始地址赋给头指针 head</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//将结点 b 的起始地址赋给 a 结点的 next 成员</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">// c 结点的 next 成员不存放其他结点地址</span>    p <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//使 p 指针指向 a 结点</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld %5.1f\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 p 指向的结点的数据</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//使 p 指向下一结点</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出完 c 结点后 p 的值为 NULL</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>处理动态链表所需函数<ul><li><strong><code>malloc</code>函数</strong><br><code>void *malloc(unsigned int size);</code><blockquote><p>作用是在内存的动态存储区中分配一个长度为<code>size</code>的连接空间。<br>些函数的值（即返回值）是一个指向分配空间起始地址的指针（基类型为<code>void</code>）。<br>如果些函数未能成功地执行（例如内存空间不足）则返回空指针 <code>NULL</code>。</p></blockquote></li><li><strong><code>calloc</code>函数</strong><br><code>void *calloc(unsigned n, unsigned size);</code><blockquote><p>其作用是在内存的动态区存储中分配<code>n</code>个长度为<code>size</code>的连续空间。<br>函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。<br>用<code>calloc</code>函数可以为一维数组开辟动态存储空间，<code>n</code>为数组元素个数，每个元素长度为<code>size</code>。</p></blockquote></li><li><strong><code>free</code>函数</strong><br><code>void free(void *p);</code><blockquote><p>其作用是释放由<code>p</code>指向的内存区，使这部分内存区能被其它变量使用，<br><code>p</code>是最后一次调用<code>calloc</code>或 <code>malloc</code>函数时返回的值。<code>free</code>函数无返回值。</p></blockquote></li></ul></li><li>动态链表示例<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> <span class="token comment">// 引入标准输入输出头文件，用于输入输出函数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span> <span class="token comment">// 引入标准库头文件，用于内存分配和系统调用函数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">// 定义一个宏，表示空指针</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span> </span><span class="token comment">// 定义一个宏，表示学生结构体的大小</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token comment">// 定义一个结构体类型，名为student</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> num<span class="token punctuation">;</span> <span class="token comment">// 定义一个长整型变量，表示学号</span>    <span class="token keyword">float</span> score<span class="token punctuation">;</span> <span class="token comment">// 定义一个浮点型变量，表示成绩</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 定义一个指向student类型的指针，表示下一个学生</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 定义一个函数，返回值是指向student类型的指针，函数名为create</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> <span class="token comment">// 声明三个指向student类型的指针，分别为p1,p2和head</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span> <span class="token comment">// 声明一个整型变量，表示学号</span>    <span class="token keyword">float</span> score<span class="token punctuation">;</span> <span class="token comment">// 声明一个浮点型变量，表示成绩</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 声明并初始化一个整型变量，表示学生的个数</span>    head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 将head指针初始化为空</span>    p1 <span class="token operator">=</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>LEN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为p1和p2指针分配一块大小为LEN的内存空间，并强制转换为student类型的指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input num and score.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，让用户输入学号和成绩</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从标准输入读取两个值，并赋给p1所指向的结构体的num和score成员</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 当输入的学号不为0时，进入循环</span>    <span class="token punctuation">{</span>        n <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 学生个数加一</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 如果是第一个学生</span>            head <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 将head指针指向p1所指向的结构体</span>        <span class="token keyword">else</span> <span class="token comment">// 如果不是第一个学生</span>            p2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 将p2所指向的结构体的next成员指向p1所指向的结构体</span>        p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 将p2指针指向p1所指向的结构体</span>        p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为p1指针重新分配一块大小为LEN的内存空间，并强制转换为student类型的指针</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input num and score.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，让用户继续输入学号和成绩</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从标准输入读取两个值，并赋给p1所指向的结构体的num和score成员</span>    <span class="token punctuation">}</span>    p2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当输入的学号为0时，退出循环，并将p2所指向的结构体的next成员设为空</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment">// 返回head指针，即链表的头节点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printlist</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token comment">// 定义一个函数，无返回值，参数是指向student类型的指针，函数名为printlist</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 声明一个指向student类型的指针，名为p</span>    p <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将p指针指向head所指向的结构体，即链表的头节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 如果链表不为空</span>    <span class="token punctuation">{</span>        <span class="token keyword">do</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num=%d score=%f\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印p所指向的结构体的num和score成员的值</span>            p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">// 将p指针指向p所指向的结构体的next成员所指向的结构体，即链表的下一个节点</span>        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当p不为空时，重复上述步骤</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 定义主函数，无返回值，函数名为main</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> <span class="token comment">// 声明一个指向student类型的指针，名为head</span>    head <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用create函数，将返回值赋给head指针，即创建一个链表</span>    <span class="token function">printlist</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用printlist函数，传入head指针作为参数，即打印链表中的每个学生的信息</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用system函数，传入"pause"作为参数，即暂停程序的执行，等待用户输入</span><span class="token punctuation">}</span>           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>动态链表中删除节点</strong><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义一个函数，返回值是指向student类型的指针，函数名为delNode，参数是指向student类型的指针head和一个整型变量num */</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">delNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"delNode.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示进入了delNode函数</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token comment">// 声明两个指向student类型的指针，分别为p1和p2</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 如果链表为空，即head指针为空</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The List is NULL.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示链表为空</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment">// 如果链表不为空</span>    <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将p1指针指向head所指向的结构体，即链表的头节点</span>        <span class="token comment">/* 当p1所指向的结构体的next成员不为空，并且p1所指向的        结构体的num成员不等于要删除的学号时，进入循环 */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p1<span class="token operator">-&gt;</span>num <span class="token operator">!=</span> num<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 将p2指针指向p1所指向的结构体</span>            p1 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">// 将p1指针指向p1所指向的结构体的next成员所指向的结构体，即链表的下一个节点</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 当退出循环后，如果p1所指向的结构体的num成员等于要删除的        学号，说明找到了要删除的节点 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>num <span class="token operator">==</span> num<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token comment">// 如果要删除的节点是头节点</span>                <span class="token comment">/* 将head指针指向p1所指向的结构体的next成员                所指向的结构体，即链表的第二个节点 */</span>                head <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>             <span class="token keyword">else</span> <span class="token comment">// 如果要删除的节点不是头节点</span>                <span class="token comment">/* 将p2所指向的结构体的next成员指向p1所指向的结构体的next成员所指向的结构体，                即跳过要删除的节点，将前后两个节点连接起来 */</span>                p2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment">/* 如果退出循环后，如果p1所指向的结构体的num成员不等于要        删除的学号，说明没有找到要删除的节点 */</span>        <span class="token keyword">else</span>             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can not find list num.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示无法找到要删除的学号</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment">// 返回head指针，即删除后的链表的头节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>动态链表更新节点</strong><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">float</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"update.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The List is NULL.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>num <span class="token operator">!=</span> index<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>num <span class="token operator">==</span> index<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            p<span class="token operator">-&gt;</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>            p<span class="token operator">-&gt;</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can not find list index.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>动态链表增加节点</strong><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义一个函数，返回值是指向student类型的指针，函数名为add，参数是指向student类型的指针head和三个整型变量index，num和score */</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">float</span> score<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示进入了add函数</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">,</span> <span class="token operator">*</span>p3<span class="token punctuation">;</span> <span class="token comment">// 声明三个指向student类型的指针，分别为p1，p2和p3</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 如果链表为空，即head指针为空</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The List is NULL.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示链表为空</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment">// 如果链表不为空</span>    <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将p1和p2指针都指向head所指向的结构体，即链表的头节点</span>        <span class="token comment">/* 当p1所指向的结构体的next成员不为空，并且p1所指向的结构        体的num成员不等于要插入的位置的学号时，进入循环 */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p1<span class="token operator">-&gt;</span>num <span class="token operator">!=</span> index<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            p1 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">// 将p1指针指向p1所指向的结构体的next成员所指向的结构体，即链表的下一个节点</span>            p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 将p2指针指向p1所指向的结构体</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 当退出循环后，如果p1所指向的结构体的num成员等于要插入的        位置的学号，说明找到了要插入的位置 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>num <span class="token operator">==</span> index<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>LEN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用malloc函数，分配一块大小为LEN的空间，并将返回值强制转换为指向student类型的指针赋给p3，即创建一个新的学生结构体</span>            p3<span class="token operator">-&gt;</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// 将要插入的学生的学号赋给p3所指向的结构体的num成员</span>            p3<span class="token operator">-&gt;</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span> <span class="token comment">// 将要插入的学生的成绩赋给p3所指向的结构体的score成员</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 如果要插入的位置是链表的尾节点</span>            <span class="token punctuation">{</span>                p2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// 将p2所指向的结构体的next成员指向p3所指向的结构体，即将新节点连接到链表尾部</span>                p3<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 将p3所指向的结构体的next成员置为空，即将新节点作为链表尾部</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token comment">// 如果要插入的位置不是链表尾节点</span>            <span class="token punctuation">{</span>                <span class="token comment">/* 将p3所指向的结构体的next成员指向p2所指向的结构                体的next成员所指向的结构体，即将新节点连接到原来位                置后面一个节点 */</span>                p3<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                <span class="token comment">/* 将p2所指向的结构体的next成员指向p3所指向的结构                体，即将新节点连接到原来位置前面一个节点 */</span>                p2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p3<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 如果退出循环后，如果p1所指向的结构体的num成员不等于要        插入位置学号，说明没有找到要插入位置 */</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can not find list index.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示信息，表示无法找到要插入位置学号</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment">// 返回head指针，即插入后链表头节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体是C语言中一种特殊的数据类型，它可以让几个不同类型的变量共享同一段内存空间。<br>共用体的定义格式和结构体类似，但是共用体的成员只能同时使用一个，而结构体的成员可以同时使用多个。<br>共用体的作用是节省内存空间，或者实现不同类型数据之间的转换。<br>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> <span class="token punctuation">[</span><span class="token keyword">union</span> tag<span class="token punctuation">]</span><span class="token punctuation">{</span>   member definition<span class="token punctuation">;</span>   member definition<span class="token punctuation">;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   member definition<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>one or more <span class="token keyword">union</span> variables<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>共用体变量所占的内存长度等于最长的成员变量的长度。</p></blockquote><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>位域是一种数据结构，可以把一个字节中的二进制位划分为不同的区域，<br>并说明每个区域的位数。位域可以节省存储空间，方便对二进制位进行操作。<br>定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> 位域结构名 <span class="token punctuation">{</span> type <span class="token punctuation">[</span>member_name<span class="token punctuation">]</span> <span class="token operator">:</span> width <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><ul><li>位域变量名.位域名</li><li>位域变量名-&gt;位域名<blockquote><p>位域的宽度不能超过它所依附的数据类型的长度，例如int型的位域最多只能占32位。<br>位域可以是无名的，这样可以用来填充或调整位置。<br>位域可以是有符号或无符号的，这会影响它们的取值范围。<br>位域的存储方式依赖于编译器，不同的编译器可能有不同的字节对齐规则。<br>位域不能跨两个字节，如果剩余的空间不够，就会从下一个字节开始存储。<br>位域不能用数组或指针来访问，只能用位域名来操作。</p></blockquote></li></ul><h3 id="typedef-define"><a href="#typedef-define" class="headerlink" title="typedef &amp; #define"></a>typedef &amp; #define</h3><blockquote><p>typedef是一个关键字，用来为已有的数据类型定义一个新的名字。<br>typedef可以用来简化复杂的类型名称，增加代码的可读性，方便程序的移植和修改。</p></blockquote><blockquote><p>#define是一个预处理指令，用来定义一个宏123。宏是一个标识符，它与一个常量或一个表达式相关联。<br>当宏出现在源代码中时，预处理器会用它的值或表达式来替换它。这样可以简化代码，提高效率，避免重复。</p></blockquote><p>区别：</p><ul><li>typedef是一个关键字，而#define是一个预处理指令。</li><li>typedef只能为类型定义别名，而#define可以为任何文本定义别名。</li><li>typedef在编译时进行类型检查，而#define在预处理时进行简单的文本替换，不作正确性检查。</li><li>typedef定义的别名不能再使用其他类型说明符进行扩展，而#define定义的别名可以。</li><li>typedef对作用域敏感，而#define对作用域不敏感。</li></ul><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="center">fopen</td><td align="center">打开文件</td><td align="left">FILE *fp = fopen(“test.txt”, “r”); //以只读模式打开test.txt文件</td></tr><tr><td align="center">fclose</td><td align="center">关闭文件</td><td align="left">fclose(fp); //关闭文件指针fp指向的文件</td></tr><tr><td align="center">fgetc</td><td align="center">读取一个字符</td><td align="left">int ch = fgetc(fp); //从文件中读取一个字符并赋值给ch</td></tr><tr><td align="center">fputc</td><td align="center">写入一个字符</td><td align="left">fputc(‘A’, fp); //向文件中写入一个字符’A’</td></tr><tr><td align="center">fgets</td><td align="center">读取一个字符串</td><td align="left">char str[100]; fgets(str, 100, fp); //从文件中读取最多99个字符的字符串并存入str数组</td></tr><tr><td align="center">fputs</td><td align="center">写入一个字符串</td><td align="left">char *str = “Hello”; fputs(str, fp); //向文件中写入一个字符串”Hello”</td></tr><tr><td align="center">fscanf</td><td align="center">格式化读取数据</td><td align="left">int a, b; fscanf(fp, “%d %d”, &amp;a, &amp;b); //从文件中按照格式读取两个整数并赋值给a和b</td></tr><tr><td align="center">fprintf</td><td align="center">格式化写入数据</td><td align="left">int a = 10, b = 20; fprintf(fp, “%d + %d = %d”, a, b, a + b); //向文件中按照格式写入一条算式</td></tr><tr><td align="center">fread</td><td align="center">读取一块数据</td><td align="left">int arr[10]; fread(arr, sizeof(int), 10, fp); //从文件中读取10个整数的数据并存入arr数组</td></tr><tr><td align="center">fwrite</td><td align="center">写入一块数据</td><td align="left">int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; fwrite(arr, sizeof(int), 10, fp); //向文件中写入10个整数的数据</td></tr><tr><td align="center">feof</td><td align="center">判断文件是否结束</td><td align="left">while (!feof(fp)) { … } //循环读取文件直到结束</td></tr><tr><td align="center">ferror</td><td align="center">判断文件是否出错</td><td align="left">if (ferror(fp)) { … } //如果文件出错，执行相应操作</td></tr><tr><td align="center">clearerr</td><td align="center">清除文件错误标</td><td align="left">clearerr(fp); //清除fp指向的文件的错误标志</td></tr><tr><td align="center">rewind</td><td align="center">将文件指针移到开始处</td><td align="left">rewind(fp); //将fp指向的文件的指针移到开始处</td></tr><tr><td align="center">fseek</td><td align="center">重定位文件指针</td><td align="left">fseek(fp, 100L, SEEK_SET); //将fp指向的文件的指针移到距离开始处100字节的位置</td></tr></tbody></table><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_LEN</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">//定义最大字符串长度</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    FILE <span class="token operator">*</span>fp1<span class="token punctuation">,</span> <span class="token operator">*</span>fp2<span class="token punctuation">;</span> <span class="token comment">//定义两个文件指针</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span>MAX_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//定义一个字符数组，用于存储读取的字符串</span>    <span class="token comment">//以文本方式打开源文件</span>    fp1 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"source.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fp1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//判断文件是否打开成功</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Cannot open source file.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//退出程序</span>    <span class="token punctuation">}</span>    <span class="token comment">//以文本方式打开目标文件</span>    fp2 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"target.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//判断文件是否打开成功</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Cannot open target file.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//退出程序</span>    <span class="token punctuation">}</span>    <span class="token comment">//循环读取源文件中的字符串，直到文件结束或出错</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//从源文件中读取一行字符串，最多读取MAX_LEN-1个字符</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> MAX_LEN<span class="token punctuation">,</span> fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">feof</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果已经到达文件末尾，跳出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果发生错误，跳出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">//将读取的字符串写入目标文件中</span>        <span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果发生错误，跳出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//关闭两个文件</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//重新以文本方式打开目标文件，用于打印复制的数据</span>    fp2 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"target.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//判断文件是否打开成功</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Cannot open target file.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//退出程序</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The copied data are:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//循环读取目标文件中的字符串，直到文件结束或出错</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//从目标文件中读取一行字符串，最多读取MAX_LEN-1个字符</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> MAX_LEN<span class="token punctuation">,</span> fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">feof</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果已经到达文件末尾，跳出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ferror</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果发生错误，跳出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">//打印读取的字符串</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关闭目标文件</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是一种数据结构，它是由n个数据特性相同的元素构成的有限序列。<br>线性表的特点是每个元素有且只有一个前驱和一个后继，除了第一个元素和最后一个元素外。<br>线性表可以用顺序存储结构或链式存储结构来实现。<br>顺序存储结构是用一组地址连续的存储单元依次存储线性表的元素，例如用数组来表示线性表。<br>链式存储结构是用一组任意的存储单元存储线性表的元素，每个元素除了数据域外，还有一个指针域指向下一个元素，例如用链表来表示线性表。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个最大长度为100的常量</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token comment">//定义一个整型数组作为顺序存储结构</span><span class="token keyword">int</span> array<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义一个变量作为线性表的长度</span><span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//创建一个示例线性表，如下图所示</span><span class="token comment">//array: [10, 20, 30, 40, 50]</span><span class="token comment">//length: 5</span><span class="token keyword">void</span> <span class="token function">createExampleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//给数组赋值</span>  array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>  <span class="token comment">//更新长度</span>  length <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在顺序存储结构的线性表中，插入或删除元素需要移动其他元素的位置，以保持线性表的连续性和顺序性。具体的步骤如下：</p><ul><li>插入元素<br>假设要在第i个位置插入一个元素x，需要先判断i是否合法，即1&lt;=i&lt;=length+1。<br>如果不合法，返回错误信息。如果合法，需要先判断线性表是否已满，即length是否等于MAX_SIZE。<br>如果已满，返回错误信息。<br>如果不满，需要从第length个元素开始，依次将每个元素后移一位，直到第i个元素为止。然后将第i个元素赋值为x，最后将length加一。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个插入函数，参数为位置i和元素x</span><span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//判断i是否合法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//返回错误信息</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Invalid position!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//判断线性表是否已满</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> MAX_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//返回错误信息</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"List is full!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//从第length个元素开始，依次后移一位</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> length<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//将第i个元素赋值为x</span>  array<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">//将length加一</span>  length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//返回成功信息</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>删除元素<br>假设要删除第i个位置的元素，并返回其值，需要先判断i是否合法，即1&lt;=i&lt;=length。<br> 如果不合法，返回错误信息。<br>如果合法，需要先将第i个元素的值保存在一个变量中，然后从第i+1个元素开始，依次将每个元素前移一位，直到第length个元素为止。最后将length减一，并返回保存的变量。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个删除函数，参数为位置i，返回被删除的元素</span><span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//判断i是否合法</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//返回错误信息</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Invalid position!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//保存被删除的元素</span>  <span class="token keyword">int</span> x <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//从第i+1个元素开始，依次前移一位</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//将length减一</span>  length<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">//返回被删除的元素</span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种只能在一端进行插入和删除的线性表，这一端叫做栈顶，另一端叫做栈底。<br>栈的插入操作叫做入栈或者压栈，删除操作叫做出栈或者弹栈。<br>栈遵循先进后出的原则，也就是说最后入栈的元素最先出栈。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个最大容量为10的数组</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">int</span> stack<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//初始化栈顶为-1</span><span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//入栈操作，将元素x压入栈中</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//判断栈是否已满</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is full.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//将元素x放入数组中，并将栈顶加一</span>  stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//出栈操作，将栈顶元素弹出并返回</span><span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//判断栈是否为空</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is empty.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//返回数组中的元素，并将栈顶减一</span>  <span class="token keyword">return</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种只能在一端进行插入操作，在另一端进行删除操作的线性表，插入的一端叫做队尾，删除的一端叫做队头。<br>队列遵循先进先出的原则，也就是说最先入队的元素最先出队。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指针域</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token comment">//定义一个队列</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">queue</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>front<span class="token punctuation">;</span> <span class="token comment">//队头指针</span>    Node <span class="token operator">*</span>rear<span class="token punctuation">;</span> <span class="token comment">//队尾指针</span><span class="token punctuation">}</span>Queue<span class="token punctuation">;</span><span class="token comment">//初始化一个队列</span><span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//队头指针置空</span>    q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//队尾指针置空</span><span class="token punctuation">}</span><span class="token comment">//判断队列是否为空</span><span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//如果队头指针为空，说明队列为空，返回1，否则返回0</span><span class="token punctuation">}</span><span class="token comment">//入队操作，从队尾插入元素</span><span class="token keyword">void</span> <span class="token function">enQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个新结点</span>    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment">//给新结点的数据域赋值</span>    newNode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//给新结点的指针域赋空值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果队列为空，那么新结点既是队头也是队尾</span>    <span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment">//如果队列不为空，那么新结点成为新的队尾，原来的队尾指向新结点</span>    <span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//出队操作，从队头删除元素，并返回元素值</span><span class="token keyword">int</span> <span class="token function">deQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果队列为空，返回-1表示错误</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment">//如果队列不为空，删除队头元素，并返回其值</span>    <span class="token punctuation">{</span>        Node <span class="token operator">*</span>temp <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> <span class="token comment">//用一个临时指针保存要删除的结点</span>        <span class="token keyword">int</span> data <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span> <span class="token comment">//保存要返回的数据</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//更新队头指针</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//如果删除后队列为空，那么更新队尾指针为NULL</span>        <span class="token punctuation">{</span>            q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放要删除的结点的内存空间</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span> <span class="token comment">//返回出队元素的值</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种分层的数据结构，有一个根节点和若干子节点。每个节点可以有零个或多个子节点，每个子节点只有一个父节点。<br>树可以用来表示层次关系或者分类关系。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义一个最大子节点数为10的常量</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_CHILDREN</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token comment">//定义一个树节点结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>  <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>children<span class="token punctuation">[</span>MAX_CHILDREN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//指针域，存储子节点</span><span class="token punctuation">}</span> TreeNode<span class="token punctuation">;</span><span class="token comment">//创建一个新的树节点，并赋值数据域为x，指针域为NULL</span>TreeNode <span class="token operator">*</span><span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//分配内存空间</span>  TreeNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>TreeNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//赋值数据域</span>  node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">//初始化指针域</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_CHILDREN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//返回新节点</span>  <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//创建一个示例树，如下图所示</span><span class="token comment">//      1</span><span class="token comment">//    / | \//   2  3  4</span><span class="token comment">//  / \    |</span><span class="token comment">// 5   6   7</span>TreeNode <span class="token operator">*</span><span class="token function">createExampleTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//创建根节点，并赋值为1</span>  TreeNode <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//创建第二层的三个子节点，并赋值为2，3，4</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//创建第三层的三个子节点，并赋值为5，6，7</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//返回根节点</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预处理器命令"><a href="#预处理器命令" class="headerlink" title="预处理器命令"></a><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">预处理器命令</a></h3><p>预处理器指令是以井号（#）开头的一些指令，它们可以用来简化源程序在不同的执行环境中的更改和编译。<br>C语言的预处理器(CPP)是一个文本替换工具，它会在编译器处理程序之前对源代码进行一些操作，比如包含头文件，扩展宏，进行条件编译等。<br>它不是编译器的组成部分，而是编译过程中的一个单独的步骤。我们可以用预处理器指令来扩充程序设计的环境。</p><table><thead><tr><th align="center">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">#define</td><td align="left">定义宏</td></tr><tr><td align="center">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="center">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="center">#ifdef</td><td align="left">如果宏已经定义，则返回真</td></tr><tr><td align="center">#ifndef</td><td align="left">如果宏没有定义，则返回真</td></tr><tr><td align="center">#if</td><td align="left">如果给定条件为真，则编译下面代码</td></tr><tr><td align="center">#else</td><td align="left">#if的替代方案</td></tr><tr><td align="center">#elif</td><td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td align="center">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="center">#error</td><td align="left">当遇到标准错误时，输出错误消息</td></tr><tr><td align="center">#pragma</td><td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><blockquote><p>告诉 CPP 把所有的 MAX_ARRAY_LENGTH 定义为 20。使用 #define 定义常量来增强可读性。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ARRAY_LENGTH</span> <span class="token expression"><span class="token number">20</span></span></span>````<span class="token operator">&gt;</span> 告诉 CPP 从系统库中获取 stdio<span class="token punctuation">.</span>h，并添加文本到当前的源文件中。<span class="token operator">&gt;</span> 告诉 CPP 从本地目录中获取 myheader<span class="token punctuation">.</span>h，并添加内容到当前的源文件中。```c<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"myheader.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>  <span class="token expression">FILE_SIZE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FILE_SIZE</span> <span class="token expression"><span class="token number">42</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MESSAGE</span></span>   <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MESSAGE</span> <span class="token string">"You wish!"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>告诉 CPP 如果定义了 DEBUG，则执行处理语句</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>   <span class="token comment">/* Your debugging statements here */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h4><ul><li>宏延续运算符<br>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。</li><li>字符串常量化运算符<br>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name function">message_for</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span>#a </span><span class="token string">" and "</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">b</span> </span></span><span class="token string">": We love you!\n"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">message_for</span><span class="token punctuation">(</span>Carole<span class="token punctuation">,</span> Debra<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>标记粘贴运算符<br>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">tokenpaster</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token function">printf</span> <span class="token punctuation">(</span></span><span class="token string">"token"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">n</span> </span></span><span class="token string">" = %d"</span><span class="token expression"><span class="token punctuation">,</span> token</span><span class="token punctuation">##</span><span class="token expression">n<span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> token34 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>    <span class="token function">tokenpaster</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h4><p>使用参数化的宏来模拟函数。<br>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Max between 20 and 10 is %d\n"</span><span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><a href="https://zhuanlan.zhihu.com/p/345399752">头文件</a></h3><ul><li>引用头文件<ul><li>引用系统头文件<br><code>#include &lt;header_file.h&gt;</code></li><li>引用用户头文件<br><code>#include "header_file.h"</code></li></ul></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数函数是指可以接受可变数量和类型的参数的函数，例如 printf（）和 scanf（）。<br>要定义一个可变参数函数，您需要使用<code>stdarg.h</code>头文件中的一些宏，例如 <code>va_list</code>,<code>va_start</code>,<code>va_arg</code>和<code>va_end</code>。</p><ul><li><p>va_start(ap, last_arg)<br>初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。</p></li><li><p>va_arg(ap, type)<br>获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。</p></li><li><p>va_end(ap)<br>结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 NULL。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h&gt;</span></span><span class="token comment">// 定义一个可变参数函数，第一个参数是整数个数，后面是任意个整数</span><span class="token keyword">double</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list valist<span class="token punctuation">;</span> <span class="token comment">// 定义一个 va_list 类型的变量</span>    <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">// 用 va_start 宏初始化 valist 变量，第二个参数是可变参数列表中的第一个参数</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>valist<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用 va_arg 宏访问每个可变参数，并累加到 sum 中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>valist<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 用 va_end 宏清理 valist 变量</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>valist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum <span class="token operator">/</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Average of 2, 3, 4, 5 = %f\n"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Average of 5, 10, 15 = %f\n"</span><span class="token punctuation">,</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边缘计算</title>
      <link href="/2023/09/28/edge-computing/"/>
      <url>/2023/09/28/edge-computing/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h1><h2 id="边缘计算基础"><a href="#边缘计算基础" class="headerlink" title="边缘计算基础"></a>边缘计算基础</h2><h3 id="边缘及本概念"><a href="#边缘及本概念" class="headerlink" title="边缘及本概念"></a>边缘及本概念</h3><blockquote><p>边缘计算是指在网络边缘执行的一种新型计算模型：介于终端设备和云端之间。<br>网络边缘设备科将终端设备产生的数据进行预处理，之后再传给云端，以减少传送的带宽和能耗。<br>边缘设备还可以执行部分计算任务：存储、计算、隐私保护等。</p></blockquote><p><strong>关键内容：</strong></p><ul><li>应用程序/服务功能可分割<br>  可以将应用或服务的一个任务分割成若干个子任务，并且可将任务迁移到边缘设备执行。</li><li>数据可分布</li><li>资源可分布</li></ul><h3 id="边缘计算的关键技术"><a href="#边缘计算的关键技术" class="headerlink" title="边缘计算的关键技术"></a>边缘计算的关键技术</h3><ul><li>计算迁移<br>对海量终端设备产生的数据进行部分或全部计算的预处理，过滤无用信息，降低传输带宽。</li><li>5G通信技术<br>降低数据传输时延</li><li>新型存储系统<br>边缘计算的数据具有高时效性、高多样性、高关联性等特点。<br>边缘计算存储系统需要低延迟、大容量、高可靠性等特点。</li><li>轻量级内核和函数库<br>边缘设备的硬件资源有限，应该以计算时消耗更少的资源和时间、达到最好的性能为目标。</li><li>边缘计算编程模型<br>边缘节点多为异构平台，每个结点的运行环境可能不同，所以在边缘计算模型下部署应用程序时传统的编程模型可能不适用。<ul><li>计算流</li></ul></li></ul><h2 id="边缘智能"><a href="#边缘智能" class="headerlink" title="边缘智能"></a>边缘智能</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>边缘智能为边缘计算和人工智能的结合：边缘计算可以AI更多的数据和应用场景、边缘数据可利用AI增强计算。<br><strong>要素</strong></p><ul><li>准确率（accuracy）</li><li>延迟（latency）</li><li>功耗（energy）</li><li>内存占用（memory footprint）</li></ul><h3 id="边缘智能技术栈"><a href="#边缘智能技术栈" class="headerlink" title="边缘智能技术栈"></a>边缘智能技术栈</h3><h4 id="边缘智能算法（-由于边缘设备计算资源受限，所以需要减少算法所需的计算量）"><a href="#边缘智能算法（-由于边缘设备计算资源受限，所以需要减少算法所需的计算量）" class="headerlink" title="边缘智能算法（ 由于边缘设备计算资源受限，所以需要减少算法所需的计算量）"></a>边缘智能算法（ 由于边缘设备计算资源受限，所以需要减少算法所需的计算量）</h4><ul><li><p>深度模型压缩</p><table><thead><tr><th align="center">压缩技术</th><th align="center">描述</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">参数量化、共享、剪裁</td><td align="center">删除冗余连接和神经元</td><td align="center">支持训练中压缩</td><td align="center">泛化性降低</td></tr><tr><td align="center">低秩逼近</td><td align="center">将高秩矩阵重构为低秩矩阵</td><td align="center">最小化性能变化</td><td align="center">重构计算量较大</td></tr><tr><td align="center">知识迁移</td><td align="center">利用预训练的网络构建紧凑型网络</td><td align="center">最大化先验知识</td><td align="center">需重新训练</td></tr></tbody></table></li><li><p>原生边缘只能算法：直接基于首先的边缘计算设备设计算法</p><ul><li>SqueezeNet</li><li>MobileNets</li><li>flattened networks</li><li>Xception</li></ul></li></ul><h4 id="边缘智能编程库"><a href="#边缘智能编程库" class="headerlink" title="边缘智能编程库"></a>边缘智能编程库</h4><blockquote><p>边缘深度学习编程库向上提供编程接口方便用户开发，向下调用深度学习库，兼容多种设备</p></blockquote><p>计算框架：<br>可执行训练和预测任务：TensorFlow、Caffe2、Pytorch、MXNet、Paddlepaddle…<br>只执行预测任务：TensorFlow Lite、CoreML、TensorRT…</p><h4 id="边缘智能数据处理平台"><a href="#边缘智能数据处理平台" class="headerlink" title="边缘智能数据处理平台"></a>边缘智能数据处理平台</h4><ul><li>EdgeXFoundry</li><li>intelligent edge fabric</li><li>OoenVDAP</li></ul><h4 id="边缘智能操作系统"><a href="#边缘智能操作系统" class="headerlink" title="边缘智能操作系统"></a>边缘智能操作系统</h4><blockquote><p>边缘计算操作系统倾向于对数据、计算任务、计算资源进行管理</p></blockquote><ul><li>robot operating system, ROS</li></ul><h4 id="边缘智能芯片"><a href="#边缘智能芯片" class="headerlink" title="边缘智能芯片"></a>边缘智能芯片</h4><p>…</p><h4 id="边缘智能设备"><a href="#边缘智能设备" class="headerlink" title="边缘智能设备"></a>边缘智能设备</h4><p>…</p><h3 id="边缘智能的协同计算"><a href="#边缘智能的协同计算" class="headerlink" title="边缘智能的协同计算"></a>边缘智能的协同计算</h3><h4 id="云边协同"><a href="#云边协同" class="headerlink" title="云边协同"></a>云边协同</h4><blockquote><p>边缘端负责数据的采集、本地数据计算和存储；云端负责大数据的分析和算法更新</p></blockquote><ol><li><p>训练—预测云边协同<br>云端负责设计和训练模型，并更新升级模型；边缘负责采集实时数据并预测，同时根据云端模型实时更新。<br>该模式应用于无人驾驶、智慧城市、社区安防等领域</p></li><li><p>云端导向云边协同<br>该模式下模型规模比较大，边缘难以完成全部预测任务，所以云端不仅承担模型的训练还要完成一部分预测任务。</p></li><li><p>边缘导向云边协同<br>该模式下，云端训练初始只能模型，然后下载到边缘。边缘完成预测的同时，基于自己采集的数据进一步训练模型，以达到个性化的需求。</p><blockquote><p>迁移学习是边缘导向云边协同的代表性工作</p></blockquote></li></ol><h4 id="边边协同"><a href="#边边协同" class="headerlink" title="边边协同"></a>边边协同</h4><blockquote><p>提升系统整体能力，解决单个边缘的计算能力有限的问题；解决数据孤岛问题。</p></blockquote><ul><li>边边预测协同<br>边缘承担全部的预测任务，整体任务标准与边缘设备的算力相匹配，减少每个边缘的计算压力，充分利用边缘计算资源。</li><li>边边分布式训练协同<br>每个边缘都承担智能模型的训练任务，边缘上拥有整个计算模型或部分模型。</li><li>边边联邦训练协同</li></ul><h4 id="边物协同"><a href="#边物协同" class="headerlink" title="边物协同"></a>边物协同</h4><p>…</p><h4 id="云边物协同"><a href="#云边物协同" class="headerlink" title="云边物协同"></a>云边物协同</h4><blockquote><p>云边物协同利用整个链路上的计算资源，以发挥不同设备的计算、存储优势并最小化通信开销。</p></blockquote><ul><li>功能性协同<br>根据不同设备所处的地理空间、角色等不同而承担不同的功能</li><li>性能性协同<br>由于算力的限制，不同层级的设备承担不同算力需求的任务，包括任务的纵向切割和分配。</li></ul><h3 id="支撑边缘智能的计算框架"><a href="#支撑边缘智能的计算框架" class="headerlink" title="支撑边缘智能的计算框架"></a>支撑边缘智能的计算框架</h3><ul><li>边缘智能的应用开发所遇到的挑战<ul><li>算力限制</li><li>数据共享和协作能力限制</li><li>算法、软件、硬件的组合爆炸问题</li></ul></li></ul><ol><li>OpenEI：面向边缘设备的开放数据处理框架</li></ol><ul><li>包管理器<br>包管理器为算法执行的环境，安装在边缘平台的操作系统上，提供智能算法运行的环境。<br>设计模型专用的数据摆放格式，减少CPU与GPU之间的通信开销，协同优化模型和计算框架，减少加速模型的执行速度。</li><li>模型选择器<br>模型选择器包括多个优化后的模型和一个选择算法。<br>模型同时针对包管理器做针对性优化，两者联合优化后实现算法运行时的实时加速，解决算力受限问题。<br>悬着算法将首先评估边缘屏体的资源承载能力，然后选择满足准确率和资源占用率的合适模型，已解决算法与计算平台不匹配的问题。</li><li>开放库<br>边缘化设备中的所有资源都可被URL代表，libei提供一整套标准化的ResultAPI,使OpenEI及其所在的硬件设备可以被其他边缘设备访问，并向其童工数据共享和功能协作服务，实现深度学习引擎在异构边缘设备上的共享。</li></ul><ol start="2"><li>NestDNN：动态分配多任务资源的移动端深度学习框架<br>…</li><li>AdaDeep：应用驱动的模型选择框架<br>…</li><li>DeepCham：自适应移动目标识别框架<br>…</li><li>DDNN：分布式神经网络框架<br>…</li></ol><h2 id="边缘计算资源调度"><a href="#边缘计算资源调度" class="headerlink" title="边缘计算资源调度"></a>边缘计算资源调度</h2><h3 id="资源调度概述"><a href="#资源调度概述" class="headerlink" title="资源调度概述"></a>资源调度概述</h3><p><strong>边缘计算的资源调度</strong></p><ul><li>以任务为中心的调度<br>用户的任务需要过呢据本身的需求进行一个最优决策：本地处理挥着调度到边缘服务器上处理。调度到边缘服务器需要付出额外的能量、通信和时延等代价</li><li>以资源为中心的调度<br>由于边缘资源的限制，需要合理的分配和配置边缘资源：边缘资源的部署、云边的协同计算、边缘之间的迁移计算以及边缘系统中服务的智能放置。以适应用户需求的变化提升资源利用率和用户的服务质量需求。<br><strong>性能指标</strong></li><li>时延<ol><li>任务从用户到边缘的传输时间</li><li>任务在边缘的处理时间</li><li>计算结果从边缘回传给用户的时间</li></ol></li><li>能耗<ol><li>任务在本地计算产生的能耗</li><li>任务传输到边缘产生的能耗</li><li>任务在边缘计算完成产生的能耗</li></ol></li><li>开销<br>  综合性能指标。任务卸载时的开销：能耗开销、通信开销、边缘处理任务的开销。</li><li>资源利用率、系统效用和收益<br><strong>研究方向</strong></li><li>卸载决策<br>由于用户层资源受限。需要将全部或部分计算密集型任务卸载到资源充足的地方来处理，可卸载到有空闲资源的其他用户设备、边缘服务器、云服务器。计算卸载解决了用户层设备资源存储、计算性能、及能效等方面的不足。<ul><li>0/1卸载<br>  计算任务要么全在本地处理要么全部卸载到其他地方处理。</li><li>部分卸载<br>  计算任务可拆分，可以一部分在本地处理。另一部分卸载到其他地方处理。</li></ul></li><li>资源分配<br>资源分配是在计算卸载过程中合理分配边缘系统中的资源完成卸载、任务处理。<ul><li>通信资源<br>  任务卸载过程中的数据传输所需的无线资源：功率、信道、带宽等</li><li>计算资源<br>  CPU的周期数、计算资源块</li><li>存储资源<br>  …</li></ul></li><li>资源配置<br>用户的请求负载随时间变化，边缘系统工作量随之波动，可能会导致资源配置过度或配置不足等问题。<ul><li>任务分配<br>  从用户的角度出发进行被动的资源配置</li><li>资源放置<br>  从资源提供者的角度进行主动的资源配置</li></ul></li></ul><h3 id="资源调度的主要技术"><a href="#资源调度的主要技术" class="headerlink" title="资源调度的主要技术"></a>资源调度的主要技术</h3><p>根据控制中心是否搜集全局信息分为集中式方法和分布式方法<br>集中式方法：基于用户和边缘的相关信息进行集中决策，能获得很好的调度效果。</p><h4 id="集中式方法"><a href="#集中式方法" class="headerlink" title="集中式方法"></a>集中式方法</h4><ol><li>基于凸优化算法<br>计算卸载、资源分配、资源配置建立的问题优化模型通常是非凸的NP难问题。解决思路为将非凸问题转化为近凸优化或凸优化问题，进而采用可行的凸优化方法。<br>凸优化算法主要技术：Lyapunov、分解技术、交替方向乘子法以及分支约束等。</li><li>近似算法<br>近似算法的研究集中在计算卸载和资源配置。基本思想是利用现有的近似算法解决建立的NP难问题。<br>近似算法相较于凸优化算法复杂度有所降低，但无法保证一定能在多项式时间内找到局部最优解。</li><li>启发式算法<br>简单启发式：贪婪算法<br>元起发式：遗传算法、蚁群算法、粒子群算法、模拟退火、禁忌收索等<br>简单启发式算法收索高效，但容易陷入局部最优解；元起发式算法参数过多，计算结果难以复用，无法快速有效的进行参数调整。</li><li>基于机器学习算法<br>与动态环境交互的同时设计资源调度策略可建模为MDP，利用强化学习和深度学习解决MDP问题。<br>机器学习算法大多数使用在计算卸载，并偏向使用强化学习和深度学习结合DQN方法来解决问题。</li></ol><h4 id="分布式方法"><a href="#分布式方法" class="headerlink" title="分布式方法"></a>分布式方法</h4><ol><li>博弈论<br>利用博弈论进行资源管理的一般方法是基于其一些解决方案（纳什均衡理论）及其精炼或扩展，来获得网络实体的行为策略，并以此分析竞争边缘资源的尸体用户之间的决策行为。</li><li>匹配理论</li><li>拍卖方法</li><li>联邦学习</li><li>区块链</li></ol><h2 id="边缘计算系统"><a href="#边缘计算系统" class="headerlink" title="边缘计算系统"></a>边缘计算系统</h2><p>边缘计算系统对边缘计算数据传输路径上的计算、存储与网络资源进行统一的控制与管理，构建边缘计算基础设施，方便开发者快速开发和部署应用。</p><h3 id="Cloudlet"><a href="#Cloudlet" class="headerlink" title="Cloudlet"></a>Cloudlet</h3><p>Cloudlet 是一个部署在边缘的可信资源丰富的主机或机群，与互联网连接，可被周围设备访问，为其提供服务。<br>三层架构：移动设备-Cloudlet-云<br>特性：</p><ol><li>软状态：cloudlet可看作位于网络边缘的小型云计算中心，作为应用的服务端要维护和客户端交互的状态信息。但不需要长期维护交互信息，可以进行自我管理。</li><li>资源丰富</li><li>靠近用户</li></ol><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol><li>计算迁移</li><li>资源发现与选择</li><li>动态NM合成</li></ol><h3 id="PCloud"><a href="#PCloud" class="headerlink" title="PCloud"></a>PCloud</h3><p>PCloud可以将附近的计算、存储、输入/输出设备与云计算资源整合，是这些资源无缝的为西东设备提供支持。<br>ParaDrop以Wifi接入点/无线网关作为硬件平台构建边缘计算系统，为第三方应用在网络的边缘提供计算和存储支援。<br>ParaDrop更接近用户和数据源，可感知网络连接状态，降低反馈延迟，增强数据安全和用户隐私。<br>…</p><h3 id="Firework"><a href="#Firework" class="headerlink" title="Firework"></a>Firework</h3><ol><li>分布式数据共享</li><li>Firework.View</li><li>Firework.Node</li><li>Firework.Manager</li></ol><h1 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h1><h2 id="SDN概述"><a href="#SDN概述" class="headerlink" title="SDN概述"></a>SDN概述</h2><ul><li><a href="http://www.xzclass.com/?p=121">什么是SDN</a></li><li><a href="http://www.xzclass.com/?p=298">SDN和NFV之间的关系</a></li><li><a href="http://www.xzclass.com/?p=309">SDN、OpenFlow和OpenDaylight</a></li></ul><h1 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a><a href="https://zhuanlan.zhihu.com/p/581217782">OpenFlow</a></h1><p>OpenFlow是一种网络通信协议，应用于SDN架构中控制器和转发器之间的通信。<br>整个OpenFlow协议架构由控制器(Controller)、OpenFlow交换机(OpenFlow Switch)、以及安全通道(Secure Channel)组成。<br>控制器对网络进行集中控制，实现控制层的功能；OpenFlow交换机负责数据层的转发，与控制器之间通过安全通道进行消息交互，实现表项下发、状态上报等功能。</p><h2 id="OpenFlow控制器"><a href="#OpenFlow控制器" class="headerlink" title="OpenFlow控制器"></a>OpenFlow控制器</h2><p>控制器负责控制逻辑的实现和流表的生成、维护、配置和派发。</p><ol><li>NOX/POX<br>NOX是第一款真正的SDN OpenFlowi控制器，由Nicira公司在O8年开发，并且捐赠给了开源组织。<br>NOX支持OpenFlow V1.0,并提供相关C++的APl,采用异步的、基于时间的编程模型。<br>而POX可以视作是更新的、基于Python的NOX版本，支持Windows,Mac OSi和Linux系统上的Pythoni开发，主要用于研究和教育领域。</li><li>ONOS<br>ONOS(Open Network Operating System)控制器是由The Open Networking Lab使用Java及Apache实现发布的首款开源SDN网络操作系统，主要面向服务提供商和企业骨干网。<br>ONOS的设计宗旨是实现可靠性强、性能好、灵活度高的SDN控制器。</li><li>OpenDaylight<br>Open Daylight是一个Linux基金合作项目，该项目以开源社区为主导，使用ava语言实现开源框架，旨在推动创新实施以及软件定义网络透明化。<br>面对SDN型网络，OpenDaylight作为项目核心，拥有一套模块化、可插拔且极为灵活的控制器，还包含一套模块合集，能够执行需要快速完成的网络任务。<br>OpenDaylight控制器的命名以化学元素为名，最初的产品是Hydrogen（氢），当前已经发布了第八个版本Oxygen（氧），并且实现了OpenDaylight-与NFV开放平台OPNFV(pen Platform for NFV)、开源云平台OpenStacki和开放网络自动化平台ONAP(Open Network Automation Platform)同步。</li></ol><h2 id="OpenFlow交换机"><a href="#OpenFlow交换机" class="headerlink" title="OpenFlow交换机"></a>OpenFlow交换机</h2><p>OpenFlow交换机是整个OpenFlow网络的核心部件，主要负责数据层的转发。OpenFlow交换机可以是物理的交换机/路由器，也可以是虚拟化的交换机/路由器。<br>按照对DpenFlow的支持程度，OpenFlow交换机可以分为两类：</p><ul><li>OpenFlow专用交换机<br>一个标准的DpenFlow设备，仅支持DpenFlow转发。他不支持现有的商用交换机上的正常处理流程，所有经过该交换机的数据都按照OpenFlow的模式进行转发。</li><li>OpenFlow兼容型交换机<br>既支持OpenFlow转发，也支持正常二三层转发。这是在商业交换机的基础上添加流表、安全通道和OpenFlow协议来获得了OpenFlow特性的交换机。<br>OpenFlow交换机在实际转发过程中，依赖于流表(FlowTable)。流表是OpenFlow交换机进行数据转发的策略表项集合，指示交换机如何处理流量，所有进入交换机的报文都按照流表进行转发。流表本身的生成、维护、下发完全由控制器来实现。</li></ul><h2 id="OpenFlow安全通道"><a href="#OpenFlow安全通道" class="headerlink" title="OpenFlow安全通道"></a>OpenFlow安全通道</h2><p>安全通道就是连接DpenFlow交换机与控制器的信道，负责在OpenFlow交换机和控制器之间建立安全链接。控制器通过这个通道来控制和管理交换机，同时接收来自交换机的反馈。<br>通过OpenFlow安全通道的信息交互必须按照DpenFlowi协议规定的格式来执行，通常采用TLS(Transport Layer Security)加密，在一些OpenFlow版本中(1.1及以上)，有时也会通过TCP明文来实现。<br>通道中传输的DpenFlowi消息类型包括以下三种：</p><ul><li>Controller-to-Switch消息：由控制器发出、OpenFlow交换机接收并处理的消息，主要用来管理或获取OpenFlow交换机状态。</li><li>Asynchronousi消息：由OpenFlow?交换机发给控制器，用来将网络事件或者交换机状态变化更新到控制器。</li><li>Symmetric消息：可由OpenFlow交换机发出也可由控制器发出，也不必通过请求建立，主要用来建立连接、检测对方是否在线等。</li></ul><h2 id="流表的组成"><a href="#流表的组成" class="headerlink" title="流表的组成"></a>流表的组成</h2><ul><li>Match fields</li><li>Action</li><li>计数器</li></ul><h1 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OpenStack.html">OpenStack</a></h1><p>OpenStack是一个云平台管理的项目，它不是一个软件，它是由几个主要的组件组合起来，为公有云、私有云和混合云的建设与管理提供软件的开源项目。<br>Openstack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性。<br>OpenStack系统或其演变版本目前被广泛应用在各行各业，包括自建私有云、公共云、租赁私有云及混合云，用户包括思科、英特尔、IBM、华为、希捷等。<br>OpenStack 支持 KVM、Xen、Lvc、Docker等虚拟机软件或容器。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>OpenStack的主要目标是管理数据中心的资源，简化资源分配。它管理三部分资源，分别是：</p><ul><li>计算资源<br>OpenStack可以规划并管理大量虚拟机，从而允许企业或服务提供商按需提供计算资源；<br>开发者可以通过API访问计算资源从而创建云应用，管理员与用户则可以通过web访问这些资源。</li><li>存储资源<br>OpenStack可以为云服务或云应用提供所需的对象及块存储资源，OpenStack可以根据用户需要提供可配置的对象存储或块存储功能。</li><li>网络资源<br>如今的数据中心存在大量的配置工作，如服务器、网络设备、存储设备、安全设备均需要配置，而它们还将被划分成更多的虚拟设备或虚拟网络。<br>这会导致 IP 地址的数量、路由配置、安全规则将爆炸式增长；传统的网络管理技术无法真正的可高扩展、高自动化地管理下一代网络。<br>因而OpenStack 提供了插件式、可扩展、API 驱动型的网络及IP管理功能。</li></ul><h2 id="OpenStack的典型架构和功能映射"><a href="#OpenStack的典型架构和功能映射" class="headerlink" title="OpenStack的典型架构和功能映射"></a>OpenStack的典型架构和功能映射</h2><ul><li>表示层<br>负责与用户交互，主要包含一些图形化界面的web门户网站（用于提供给非开发人员进行界面操作），同时该部分还提供了供开发人员进行二次开发的API接口。<br>该部分还包括一些更高级的特性，例如：负载均衡、控制台代理安全和命名服务。</li><li>逻辑层<br>提供云服务的智能控制功能，如：orchestration（负责任务的工作流管理）、scheduling（任务到资源的调度管理）、policy（配额等服务）、image registry（镜像实例的元数据管理）和logging（事件计费管理）。</li><li>资源层<br>包含计算、网络和存储等物理资源。</li></ul><h2 id="OpenStack的核心项目"><a href="#OpenStack的核心项目" class="headerlink" title="OpenStack的核心项目"></a>OpenStack的核心项目</h2><ul><li>Keystone<br>Keystone是OpenStack的认证服务，Keystone为所有的OpenStack组件提供认证和访问策略服务，它依赖自身REST系统进行工作，主要对Swift、Glance、Nova等进行认证与授权，它对动作消息中的来源者进行合法性鉴定。<br>Keystone采用两种授权方式，一种基于用户名/密码，另一种基于令牌（Token）。<br>除此之外，Keystone提供以下三种服务：<ul><li>令牌服务：令牌中含有授权用户或群组的授权信息，授权给合法用户或群组。</li><li>目录服务：目录中含有合法用户或群组的可用服务列表。</li><li>策略服务：利用Keystone具体指定用户或群组的某些访问权限。</li></ul></li><li>Nova<br>Nova是一套控制器，用于为单个用户或使用群组管理虚拟机实例的整个生命周期，根据用户需求来提供虚拟服务，Nova负责管理整个云的计算资源、网络资源、授权及测度。<br>虽然Nova本身并不提供任何虚拟能力，但是它将使用libvirt API与虚拟机的宿主机进行交互。<br>Nova通过Web服务API来对外提供处理接口。</li><li>Glance<br>Glance负责OpenStack的镜像服务，Glance是一套虚拟机镜像发现、注册、检索系统，它提供虚拟机镜像的存储，查询和检索功能，为nova进行服务，依赖于存储服务和数据库服务。</li><li>Swift<br>Swift为OpenStack提供了一种分布式、持续虚拟对象存储。Swift具有跨节点的存储能力。<br>Swift组件有冗余和失效备援管理功能，也能够处理归档和媒体流，特别是对大数据和大容量的测度非常高效。</li><li>Cinder<br>Cinder是OpenStack的块存储服务组件，它管理所有块存储设备，为VM服务。</li><li>Neutorn<br>Neutorn为OpenStack提供虚拟的网络功能，为每个不同的租户建立独立的网络环境。</li><li>Horizon<br>Horizon是一个用以管理、控制OpenStack服务的Web控制面板。用户可以通过这个界面对OpenStack状态进行查看和管理。</li></ul><h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a><a href="https://www.cnblogs.com/Richard-2006/p/13920150.html">图论基础</a></h1><h1 id="异构网络融合"><a href="#异构网络融合" class="headerlink" title="异构网络融合"></a>异构网络融合</h1><p>异构网络是一种混合型网络，网络有不同厂商的设备和系统组成，支持不同的协议和技术，能够面向不同的的应用场景和用户。<br>异构网络融合，可以根据用户的偏好、业务QoS和网络状态等方面进行中和决策，保证用户连接到最好的网络，提高用户体验。</p><ul><li>切换技术<ul><li>水平切换（HHO）：同一网络类型内进行切换</li><li>垂直切换（VHO）：不同网络内进行切换</li></ul></li><li>切换策略因素<ul><li>用户偏好</li><li>QoS</li><li>网络状况</li><li>…</li></ul></li></ul><h2 id="异构网络架构"><a href="#异构网络架构" class="headerlink" title="异构网络架构"></a>异构网络架构</h2><h3 id="IEEE-802-21-MIH媒质独立切换协议"><a href="#IEEE-802-21-MIH媒质独立切换协议" class="headerlink" title="IEEE 802.21 MIH媒质独立切换协议"></a>IEEE 802.21 MIH媒质独立切换协议</h3><blockquote><p>目的是实现用户终端在同类型网络间及不同类型网络之间的无缝接入和切换，实现独立于异构网络的接入和切换。</p></blockquote><ul><li><p>协议框架</p><ul><li><strong>MIH用户</strong>（MIH User，MIHU）：是一个应用层的实体，它可以使用MIH服务来优化高层服务，如切换、网络选择、漫游等。</li><li><strong>MIH功能</strong>（MIH Function，MIHF）：是一个协议层的实体，它提供了一组MIH服务和事件，以及一个MIH协议，用于在不同的MIHF之间交换信息。</li><li><strong>MIH链接</strong>（MIH Link，MIHL）：是一个物理层或数据链路层的实体，它可以与MIHF交互，提供链接相关的信息和操作。<blockquote><p>MIH用户和MIH功能之间的交互是通过MIH协议来实现的，MIH协议是一种基于IP的传输协议，它定义了一组消息格式和规则，用于在不同的MIH功能之间传递信息和指令。<br>MIH协议支持三种传输方式：TCP、UDP和SCTP²。MIH用户可以通过MIH协议向MIH功能发出请求，查询或控制MIH链接的状态和参数，例如信号强度、速率、质量等。<br>MIH功能可以通过MIH协议向MIH用户发送事件通知，报告MIH链接的变化，例如链接断开、链接可用、链接手over等。MIH用户和MIH功能之间的交互可以在同一设备内部进行，也可以跨越不同的设备或网络进行。</p></blockquote></li></ul></li><li><p>服务</p><ul><li><strong>信息服务</strong>（Information Service，IS）：这种服务可以让MIH用户查询和发现不同类型网络的信息，例如网络标识、链路特性、网络条件等。这些信息可以帮助MIH用户选择最合适的网络，以及预测网络的变化。信息服务可以分为两种类型：<strong>本地信息服务</strong>（Local Information Service，LIS）和<strong>远程信息服务</strong>（Remote Information Service，RIS）。本地信息服务是指MIH功能可以从本地的MIH链接获取信息，而远程信息服务是指MIH功能可以从远程的MIH功能或其他实体获取信息。例如，一个MIH用户可以通过本地信息服务查询当前连接的无线局域网（WLAN）的信号强度，或者通过远程信息服务查询附近可用的蜂窝网络（Cellular Network）的覆盖范围。</li><li><strong>事件服务</strong>（Event Service，ES）：这种服务可以让MIH用户订阅和通知不同类型网络的事件，例如链路断开、链路可用、链路质量变化等。这些事件可以帮助MIH用户及时感知网络的状态，以及采取相应的行动。事件服务也可以分为两种类型：<strong>本地事件服务</strong>（Local Event Service，LES）和<strong>远程事件服务</strong>（Remote Event Service，RES）。本地事件服务是指MIH功能可以从本地的MIH链接接收事件通知，而远程事件服务是指MIH功能可以从远程的MIH功能或其他实体接收事件通知。例如，一个MIH用户可以通过本地事件服务订阅当前连接的WLAN的链路断开事件，或者通过远程事件服务订阅附近可用的蓝牙网络（Bluetooth Network）的链路可用事件。</li><li><strong>命令服务</strong>（Command Service，CS）：这种服务可以让MIH用户控制和执行不同类型网络的操作，例如链路激活、链路去激活、链路参数设置等。这些操作可以帮助MIH用户主动调整网络的配置，以及实现网络之间的切换。命令服务也可以分为两种类型：<strong>本地命令服务</strong>（Local Command Service，LCS）和<strong>远程命令服务</strong>（Remote Command Service，RCS）。本地命令服务是指MIH功能可以向本地的MIH链接发送命令请求，并接收命令响应，而远程命令服务是指MIH功能可以向远程的MIH功能或其他实体发送命令请求，并接收命令响应。例如，一个MIH用户可以通过本地命令服务请求当前连接的WLAN去激活链路，或者通过远程命令服务请求附近可用的蓝牙网络激活链路。</li></ul></li></ul><h3 id="3GPP：非-3GPP-网络接入架构"><a href="#3GPP：非-3GPP-网络接入架构" class="headerlink" title="3GPP：非 3GPP 网络接入架构"></a>3GPP：非 3GPP 网络接入架构</h3><p>非 3GPP 网络接入的方案主要有以下几种：</p><ul><li><p>独立非 3GPP 接入：这种方案是指 5G 终端只通过非 3GPP 标准的无线接入网络（例如 WLAN、WiMAX、LTE-U 等）连接到 5G 核心网，不涉及任何 3GPP 接入网络（例如 NR、LTE 等）。这种方案的优点是简单、灵活，可以利用现有的无线接入网络资源，提高网络覆盖范围和容量。这种方案的缺点是需要在非 3GPP 接入网络和 5G 核心网之间部署一个网关设备，即非 3GPP 互通功能（N3IWF），负责在两者之间建立安全的信令和数据通道。此外，这种方案也不能实现 3GPP 和非 3GPP 接入网络之间的无缝切换，可能影响用户体验。</p></li><li><p>混合非 3GPP 接入：这种方案是指 5G 终端同时通过非 3GPP 标准的无线接入网络和 3GPP 标准的无线接入网络连接到 5G 核心网，实现两者之间的协同和互补。这种方案的优点是可以提供更多样化的服务选择，同时也可以实现 3GPP 和非 3GPP 接入网络之间的无缝切换，提高用户体验。这种方案的缺点是需要在终端和核心网之间维护多个连接，增加了信令开销和资源消耗。此外，这种方案也需要解决不同接入网络之间的互操作性、安全性、质量保障等问题。</p></li><li><p>集成非 3GPP 接入：这种方案是指将非 3GPP 标准的无线接入网络作为 5G 新空口（NR）的一部分，与 NR 共享相同的物理层、媒体访问控制层和无线资源控制层，实现对 NR 的扩展和增强。这种方案的优点是可以充分利用 NR 的特性，如灵活的频谱使用、大规模天线阵列、低时延等，提高非 3GPP 接入网络的性能和效率。这种方案的缺点是需要对非 3GPP 接入网络进行较大的改造和升级，以适应 NR 的要求，增加了技术复杂度和成本。</p></li></ul><h4 id="核心网侧分流架构（基于-S2a、S2b-和-S2c-接口的融合方案）"><a href="#核心网侧分流架构（基于-S2a、S2b-和-S2c-接口的融合方案）" class="headerlink" title="核心网侧分流架构（基于 S2a、S2b 和 S2c 接口的融合方案）"></a>核心网侧分流架构（基于 S2a、S2b 和 S2c 接口的融合方案）</h4><p>在 3GPP 系统中，实现不同类型的非 3GPP 接入网络（例如 WLAN，WiMAX 等）与 3GPP 核心网络（例如 EPC，IMS 等）之间的互通和协同。<br>根据非 3GPP 接入网络的信任程度和漫游情况，可以有不同的接口和功能方案。<br>一般来说，非 3GPP 接入网络需要通过一个非 3GPP 互通功能（N3IWF）或者一个演进型分组数据网关（ePDG）连接到 3GPP 核心网络，N3IWF 或 ePDG 分别通过 S2a、S2b 和 S2c 接口连接到控制面和用户面的功能实体。S2a、S2b 和 S2c 接口的主要作用和区别如下¹：</p><ul><li>S2a 接口：提供可信任的非 3GPP 接入网络（例如 TWAN）与 3GPP 核心网络之间的用户面和控制面的连接。S2a 接口需要在 TWAN 和 PDN GW 之间部署一个 N3IWF，N3IWF 负责中继用户面和控制面的信令和数据包，并支持移动性管理和切换。</li><li>S2b 接口：提供非可信任的非 3GPP 接入网络（例如公共 WLAN）与 3GPP 核心网络之间的用户面和控制面的连接。S2b 接口需要在 WLAN 和 PDN GW 之间部署一个 ePDG，ePDG 负责与 UE 建立 IPSec 隧道，以保证数据的安全传输，并中继用户面和控制面的信令和数据包，并支持移动性管理和切换。</li><li>S2c 接口：提供 UE 和 3GPP 核心网络之间的用户面和控制面的连接。S2c 接口可以在可信任或非可信任的非 3GPP 接入网络或者 3GPP 接入网络上实现。S2c 接口需要 UE 支持 DSMIPv6 协议，以实现 UE 和 PDN GW 或 PDG 之间的 DSMIP 隧道连接，并支持移动性管理和切换。</li></ul><h4 id="无线侧分流方案"><a href="#无线侧分流方案" class="headerlink" title="无线侧分流方案"></a>无线侧分流方案</h4><ul><li><p>LTE-WLAN无线接入聚合（LWA）：</p><p>  这种方案是指 5G 终端可以同时通过 LTE 和 WLAN 接入网络连接到 5G 核心网，实现两者之间的数据平面聚合。</p><p>  LWA 通过在 LTE 基站和 WLAN 接入点之间建立 Xw 接口，将 LTE 数据有效载荷分离，一部分流量通过 WLAN 传输，另一部分通过 LTE 传输，从而提高 LTE 服务的性能。</p><p>  LWA 需要在终端和核心网之间维护一个 PDU 会话，并在切换时保持会话的一致性。</p><p>  LWA 的优点是可以利用现有的 WLAN 接入点资源，提高网络覆盖范围和容量，同时也可以实现 LTE 和 WLAN 接入网络之间的无缝切换，提高用户体验。</p><p>  LWA 的缺点是需要在 LTE 基站和 WLAN 接入点之间部署额外的硬件和软件，增加了网络复杂度和成本。</p></li><li><p>LTE-WLAN无线控制平面聚合（LWIP）：</p><p>  这种方案是指 5G 终端可以同时通过 LTE 和 WLAN 接入网络连接到 5G 核心网，实现两者之间的控制平面聚合。</p><p>  LWIP 通过在 LTE 基站和 WLAN 接入点之间建立 Xw 接口，将 LTE 控制信令分离，一部分信令通过 WLAN 传输，另一部分通过 LTE 传输，从而提高 LTE 服务的可靠性。</p><p>  LWIP 需要在终端和核心网之间维护一个 PDU 会话，并在切换时保持会话的一致性。</p><p>  LWIP 的优点是可以利用现有的 WLAN 接入点资源，提高网络覆盖范围和容量，同时也可以实现 LTE 和 WLAN 接入网络之间的无缝切换，提高用户体验。</p><p>  LWIP 的缺点是需要在 LTE 基站和 WLAN 接入点之间部署额外的硬件和软件，增加了网络复杂度和成本。</p></li></ul><blockquote><p>LWA 是一种数据平面聚合方案，即 5G 终端可以同时通过 LTE 和 WLAN 接入网络传输数据，实现两者之间的数据流量分配和负载均衡。LWIP 是一种控制平面聚合方案，即 5G 终端可以同时通过 LTE 和 WLAN 接入网络传输控制信令，实现两者之间的信令可靠性和鲁棒性。</p></blockquote><blockquote><p>LWA 和 LWIP 都需要在 LTE 基站和 WLAN 接入点之间建立 Xw 接口，但是 Xw 接口的功能不同。LWA 的 Xw 接口主要用于将 LTE 数据有效载荷分离，一部分流量通过 WLAN 传输，另一部分通过 LTE 传输。LWIP 的 Xw 接口主要用于将 LTE 控制信令分离，一部分信令通过 WLAN 传输，另一部分通过 LTE 传输。</p></blockquote><blockquote><p>LWA 和 LWIP 都需要在终端和核心网之间维护一个 PDU 会话，并在切换时保持会话的一致性。但是 LWA 和 LWIP 的 PDU 会话的类型不同。LWA 的 PDU 会话是一种单路径类型，即只有一个数据承载网络层（DN）地址，而 LWIP 的 PDU 会话是一种多路径类型，即有两个或多个 DN 地址。</p></blockquote><ul><li><p>LTE-WLAN无线双连接（LWDC）：</p><p>  这种方案是指 5G 终端可以同时通过 LTE 和 WLAN 接入网络连接到 5G 核心网，实现两者之间的双连接。</p><p>  LWDC 不需要在 LTE 基站和 WLAN 接入点之间建立任何接口，而是在终端上实现两个独立的 PDU 会话，一个通过 LTE 连接到核心网，一个通过 WLAN 连接到互联网。</p><p>  LWDC 的优点是可以利用现有的 WLAN 接入点资源，提高网络覆盖范围和容量，同时也可以实现 LTE 和 WLAN 接入网络之间的灵活切换，提高用户体验。</p><p>  LWDC 的缺点是需要在终端上实现复杂的会话管理逻辑，增加了终端的功耗和成本。</p></li><li><p>工作方式</p><ul><li><p>LWA：<br>  当 5G 终端通过 LTE 接入网络建立 PDU 会话后，可以通过 Xw 接口向 LTE 基站请求开启 LWA 功能。<br>  如果 LTE 基站和 WLAN 接入点之间的 Xw 接口可用，LTE 基站会向 5G 终端发送 LWA 激活指示，告知其 WLAN 接入点的信息。<br>  5G 终端根据这些信息，通过 WLAN 接入网络建立 LWA 数据通道，并向 LTE 基站发送 LWA 激活确认。<br>  此时，LWA 功能开启成功，LTE 基站可以将 LTE 数据有效载荷分离，一部分流量通过 WLAN 传输，另一部分通过 LTE 传输。<br>  当 LWA 功能不再需要时，LTE 基站或 5G 终端可以通过 Xw 接口发送 LWA 去激活指示，关闭 LWA 功能。</p></li><li><p>LWIP：当 5G 终端通过 LTE 接入网络建立 PDU 会话后，可以通过 Xw 接口向 LTE 基站请求开启 LWIP 功能。<br>  如果 LTE 基站和 WLAN 接入点之间的 Xw 接口可用，LTE 基站会向 5G 终端发送 LWIP 激活指示，告知其 WLAN 接入点的信息。<br>  5G 终端根据这些信息，通过 WLAN 接入网络建立 LWIP 控制通道，并向 LTE 基站发送 LWIP 激活确认。<br>  此时，LWIP 功能开启成功，LTE 基站可以将 LTE 控制信令分离，一部分信令通过 WLAN 传输，另一部分通过 LTE 传输。</p></li><li><p>当 LWIP 功能不再需要时，LTE 基站或 5G 终端可以通过 Xw 接口发送 LWIP 去激活指示，关闭 LWIP 功能。2</p></li><li><p>LWDC：当 5G 终端通过 LTE 接入网络建立 PDU 会话后，可以同时通过 WLAN 接入网络建立另一个 PDU 会话。<br>  此时，5G 终端有两个独立的 PDU 会话，一个通过 LTE 连接到核心网，一个通过 WLAN 连接到互联网。<br>  5G 终端可以根据自己的服务需求和网络状况，在两个 PDU 会话之间进行切换或同时使用。当两个 PDU 会话不再需要时，5G 终端可以分别释放它们。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信 </tag>
            
            <tag> 边缘计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/2023/09/28/git-study-note/"/>
      <url>/2023/09/28/git-study-note/</url>
      
        <content type="html"><![CDATA[<h1 id="git管理工程文件"><a href="#git管理工程文件" class="headerlink" title="git管理工程文件"></a>git管理工程文件</h1><h2 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h2><p>Git本地有四个个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)、远程的git仓库(Remote Directory)。</p><ul><li>Workspace：工作区，存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有提交的所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器</li></ul><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><ul><li>设置用户名：<code>git config --global user.name "name"</code></li><li>设置用户邮箱：<code>git config --global user.email address</code>、</li></ul><h3 id="git配置命令"><a href="#git配置命令" class="headerlink" title="git配置命令"></a>git配置命令</h3><ul><li>查看配置：<code>git config -l</code></li><li>查看系统配置：<code>git config --system --list</code></li><li>查看用户配置：<code>git config --global --list</code></li><li>编辑当前仓库 git 配置文件:<code>git config -e </code></li><li>编辑系统上所有仓库的 git 配置文件：<code>git config -e --global</code></li></ul><h2 id="生成SSH链接Github"><a href="#生成SSH链接Github" class="headerlink" title="生成SSH链接Github"></a>生成SSH链接Github</h2><ol><li><p>创建SSH密钥：<code>ssh-keygen -t rsa -C "emailaddress"</code></p></li><li><p>配置密钥生成方式</p><ol><li>确认密钥保存位置（直接回车，不修改）</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖</li><li>创建密码（直接回车，不创建密码）</li><li>确认密码</li></ol></li><li><p>使用SSH链接Github</p><ol><li>在GitHub设置中的 <code>SSh and GPC keys</code> 中点击 <code>New SSH key</code></li><li>将之前生成的 <code>id_rsa.pub</code> 文件中的内容都复制粘贴到 <code>key</code> 栏</li><li>点击 <code>Add SSH key</code> 添加链接</li></ol></li></ol><h2 id="为Git配置代理"><a href="#为Git配置代理" class="headerlink" title="为Git配置代理"></a>为Git配置代理</h2><ul><li><p>全局设置</p><ul><li><p>使用http代理 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy http://localhost:port<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy https://localhost:port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用socks5代理</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy socks5://localhost:port<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy socks5://localhost:port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>设置SSH代理<br>  在 <code>.ssh</code> 文件中新建 <code>config</code> 文件, 并添加：</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host gitHub.com    User    <span class="token function">git</span>    Hostname        github.com    Port    <span class="token number">22</span>    <span class="token comment"># Linux/Mac:</span>    <span class="token comment"># Proxycommand    /usr/bin/ncat --proxy 127.0.0.1:7890 --proxy-type socks5 %h %p</span>    <span class="token comment"># Windows:</span>    Proxycommand   connect <span class="token parameter variable">-S</span> <span class="token number">127.0</span>.0.1:10809 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>取消代理</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> http.proxy<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>取消 <code>SSH</code> 代理只需将之前添加的 <code>config</code> 文件删除</p><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><ul><li><p>创建新仓库</p><ul><li>在当前目录创建新仓库：<code>git init</code></li><li>在指定目录创建新仓库：<code>git init newrepo</code>:</li></ul></li><li><p>添加远程仓库<br>  <code>git remote add origin  git@github.com:xxxxxx/ssssss</code></p></li><li><p>推送代码到远程仓库<br>  <code>git push</code></p></li><li><p>更新代码到本地<br>  <code>git pull</code></p></li><li><p>克隆仓库</p><ul><li>克隆仓库到本地：<code>git clone &lt;repo&gt;</code></li><li>克隆到指定的目录：<code>git clone &lt;repo&gt; &lt;directory&gt;</code></li></ul></li><li><p>添加Git仓库作为子模块<br>  <code>git submodule add git@github.com:xxxxxx/ssssss target_dir</code></p></li></ul><h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><ul><li>cd：改变目录</li><li>cd..：会到上一级目录</li><li>pwb：显示当前所在路径</li><li>clear：清屏</li><li>ls：列出当前文件夹内的所有文件</li><li>touch：新建文件</li><li>rm：删除文件</li><li>mkdir：创建文件夹</li><li>rm -r：删除文件夹</li><li>mv：移动文件</li><li>history：查看历史命令</li><li>help</li><li>exit：退出</li></ul><hr><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.bilibili.com/video/BV1FE411P7B3?p=1">Git教程：B站</a><br><a href="https://www.runoob.com/git/git-tutorial.html">Git教程：RUNOOB</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2023/09/28/game-theory/"/>
      <url>/2023/09/28/game-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/2023/09/28/network-protocol/"/>
      <url>/2023/09/28/network-protocol/</url>
      
        <content type="html"><![CDATA[<h1 id="Network-communication"><a href="#Network-communication" class="headerlink" title="Network communication"></a>Network communication</h1><h2 id="OSI-Open-Systems-Interconnection"><a href="#OSI-Open-Systems-Interconnection" class="headerlink" title="OSI (Open Systems Interconnection)"></a>OSI (Open Systems Interconnection)</h2><p>OSI（开放系统互联）模型是一个概念性框架，将电信或网络系统的功能标准化为七个不同的层次。这些层次有助于通过将数据传输的复杂过程拆分为更易管理和模块化的组件来理解和设计通信系统。</p><table><thead><tr><th>OSI 模型层</th><th>功能</th><th>职责</th><th>工作流程</th><th>主要协议和技术</th></tr></thead><tbody><tr><td><strong>物理层</strong></td><td>OSI模型的最低层，处理物理介质和原始二进制数据传输。</td><td>编码、调制、传输、接收原始位，定义物理媒体的特性。</td><td>数据编码、数据传输、电压电流规范、物理接口。</td><td>电缆、连接器、网络接口</td></tr><tr><td><strong>数据链路层</strong></td><td>提供错误检测、纠正和数据帧分割，确保直接连接节点的数据可靠传输。</td><td>寻址、帧分割、错误检测和纠正、流量控制。</td><td>数据帧封装、地址分配（如MAC地址）、流量控制。</td><td>以太网、PPP等协议</td></tr><tr><td><strong>网络层</strong></td><td>在不同网络间路由数据包，处理逻辑寻址和数据包转发。</td><td>逻辑寻址（如IP地址）、路由、路径确定。</td><td>数据包分组、IP地址分配、根据目标地址路由。</td><td>IP（Internet Protocol）等协议</td></tr><tr><td><strong>传输层</strong></td><td>确保不同网络设备之间的端到端通信、可靠性和流量控制。</td><td>数据分段和重新组装、流量控制、错误检测、端到端通信。</td><td>数据分段、流量控制、错误检测、端到端通信。</td><td>TCP、UDP等协议</td></tr><tr><td><strong>会话层</strong></td><td>建立、维护和终止通信会话，管理会话同步和恢复。</td><td>会话的建立、维护和终止，会话中断时的同步和恢复。</td><td>会话建立、维护、终止、同步和恢复。</td><td></td></tr><tr><td><strong>表示层</strong></td><td>处理数据翻译、加密和压缩，确保数据可跨不同系统读取。</td><td>数据翻译、加密、压缩、字符编码。</td><td>数据格式转换、编码、加密、字符集转换。</td><td>数据翻译、加密、字符编码等技术</td></tr><tr><td><strong>应用层</strong></td><td>与最终用户应用程序进行交互，提供服务和接口。</td><td>应用程序特定功能、用户界面、通信服务。</td><td>用户应用程序与网络的交互、协议和服务。</td><td>HTTP、SMTP、FTP等协议</td></tr></tbody></table><blockquote><p>需要注意的是，OSI模型是一个理论性的框架，不直接对应现代网络技术的实现方式。相反，它作为一个概念性指南，用于理解网络通信，并经常用于讨论和比较网络协议和技术。在实际中，许多网络模型，如TCP/IP模型，简化了这些层次并合并了一些功能以提高效率和实用性。</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><blockquote><p>TCP/IP协议是互联网协议族中的一个协议。它是指传输控制协议（TCP，Transmission Control Protocol）和互联网协议（IP，Internet Protocol）的合称，用于在因特网中的不同计算机之间进行通信。</p></blockquote><blockquote><p>TCP/IP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。它提供了端到端的数据传输服务，保证了数据能够准确、完整地从一个节点传输到另一个节点。</p></blockquote><blockquote><p>TCP/IP协议是因特网的核心协议，它使得不同类型的计算机和网络能够互相通信。TCP/IP协议是由美国国防部高级研究计划局（ARPA）在20世纪60年代末期为了实现分布式计算机网络而设计开发的。</p></blockquote><p>TCP/IP协议是一种用于在不同的网络之间进行数据传输的协议族，它由四层或五层构成，每一层都有不同的功能和协议。TCP/IP协议的四层或五层分别是：</p><table><thead><tr><th>OSI 模型层</th><th>描述</th><th>举例和主要协议</th></tr></thead><tbody><tr><td><strong>应用层（Application Layer）</strong></td><td>提供应用程序所需的网络服务和通信协议，例如HTTP、SMTP、FTP等。</td><td>HTTP、SMTP、FTP等协议</td></tr><tr><td><strong>传输层（Transport Layer）</strong></td><td>提供端到端的可靠或不可靠的数据传输服务，实现流量控制和多路复用。例如TCP、UDP。</td><td>TCP、UDP等协议</td></tr><tr><td><strong>网络层（Network Layer）</strong></td><td>在多个网络之间进行数据包的路由和转发，实现网络互连和寻址。例如IP、ICMP、ARP。</td><td>IP、ICMP、ARP等协议</td></tr><tr><td><strong>数据链路层（Data Link Layer）</strong></td><td>建立可靠的数据传输，在物理链路上进行错误检测和纠正，定义数据帧格式和设备寻址。例如以太网协议。</td><td>以太网协议</td></tr><tr><td><strong>物理层（Physical Layer）</strong></td><td>负责传输比特流，定义物理传输介质和特性。例如双绞线、光纤、无线电波等。</td><td>双绞线、光纤、无线电波等传输介质</td></tr></tbody></table><blockquote><p>TCP/IP的四层协议将物理层和数据链路层合并为网络接口层，而五层协议则将它们分开。这样做的原因是，TCP/IP的四层协议是为了实现网络互连而设计的，它不关心具体的物理介质和链路技术，只关心如何在不同的网络之间传输数据。而五层协议则是为了学习网络原理而设计的，它更加细致地划分了每一层的功能和协议，以便于理解和分析</p></blockquote><h3 id="三次握手，建立连接"><a href="#三次握手，建立连接" class="headerlink" title="三次握手，建立连接"></a>三次握手，建立连接</h3><p>TCP（Transmission Control Protocol）是一种面向连接的协议，它使用三次握手来建立连接。下面是三次握手建立连接的具体过程：</p><ol><li><p><strong>客户端发送请求（SYN）：</strong></p><ul><li>客户端（通常是发起连接的一方）首先向服务器发送一个TCP报文段，这个报文段被称为”SYN”（同步）报文段。</li><li>这个报文段包含以下信息：<ul><li>初始序列号（ISN）：一个随机生成的序列号，用于标识报文段在数据流中的位置。</li><li>SYN标志位：被设置为1，表示这是一个连接请求。</li></ul></li><li>客户端选择一个随机的初始序列号，并向服务器发起连接请求。</li></ul></li><li><p><strong>服务器回应（SYN-ACK）：</strong></p><ul><li>一旦服务器收到客户端的SYN报文段，它会发送一个回应，称为”SYN-ACK”报文段，以确认连接请求。</li><li>这个报文段包含以下信息：<ul><li>确认序列号（ACK）：设置为客户端的初始序列号加1，表示服务器已经收到了客户端的请求。</li><li>初始序列号（ISN）：服务器选择一个随机的初始序列号，用于服务器和客户端之间的数据传输。</li><li>SYN标志位：被设置为1，表示这是对连接请求的确认。</li></ul></li><li>服务器同时也会把ACK标志位设置为1，表示它已经确认了客户端的请求，并且将其序列号设置为客户端的初始序列号加1。</li></ul></li><li><p><strong>客户端确认（ACK）：</strong></p><ul><li>最后，客户端收到服务器的SYN-ACK报文段后，会发送一个”ACK”（确认）报文段作为对服务器的确认。</li><li>这个报文段包含以下信息：<ul><li>确认序列号（ACK）：设置为服务器的初始序列号加1，表示客户端已经收到了服务器的确认。</li><li>SYN标志位：设置为0，因为此时连接已经建立，不再是一个连接请求。</li></ul></li><li>此时，连接已经建立，客户端和服务器可以开始通过这个连接进行数据传输。</li></ul></li></ol><blockquote><p>总结三次握手的过程：客户端首先发送一个SYN报文段来请求建立连接，服务器接收后回应一个SYN-ACK报文段以确认连接请求，最后客户端发送一个ACK报文段，表示连接已经建立。这个过程确保了客户端和服务器都同意建立连接，并且双方已经准备好开始数据传输。</p></blockquote><h3 id="四次挥手，断开连接"><a href="#四次挥手，断开连接" class="headerlink" title="四次挥手，断开连接"></a>四次挥手，断开连接</h3><p>TCP连接的四次握手是用于安全地关闭一个已经建立的连接。下面是四次握手断开连接的具体过程：</p><ol><li><p><strong>发起关闭请求（FIN）：</strong></p><ul><li>需要关闭连接的一方（通常是其中一方的应用程序）首先向对方发送一个TCP报文段，称为”FIN”（结束）报文段，以表示它希望关闭连接。</li><li>这个报文段包含以下信息：<ul><li>序列号（SEQ）：表示报文段的序列号。</li><li>FIN标志位：被设置为1，表示这是一个关闭请求。</li></ul></li><li>此时，发起关闭请求的一方进入FIN-WAIT状态，等待对方的确认。</li></ul></li><li><p><strong>确认关闭请求（ACK）：</strong></p><ul><li>接收到关闭请求的一方（通常为服务器）收到FIN报文段后，会发送一个确认报文段，其中ACK标志位被设置为1，表示已经收到了关闭请求。</li><li>这个确认报文段可能包含一些未确认的数据（如果还有未传输完的数据），因为TCP是全双工的，允许双方同时发送和接收数据。</li><li>此时，接收到关闭请求的一方进入CLOSE-WAIT状态，等待应用程序决定是否关闭连接。</li></ul></li><li><p><strong>服务器发送关闭请求（FIN）：</strong></p><ul><li>如果接收到关闭请求的一方（通常为服务器方）的应用程序也希望关闭连接，它会向另一方发送一个FIN报文段，表示它也要关闭连接。</li><li>这个FIN报文段包含相应的序列号和FIN标志位。</li><li>此时，发起关闭请求的一方接收到这个FIN报文段后，进入LAST-ACK状态，表示它已经接受到了关闭请求，但还需要一次确认。</li></ul></li><li><p><strong>确认关闭请求（ACK）：</strong></p><ul><li>最后，接收到关闭请求的一方（发起关闭请求的一方）再次发送一个确认报文段，其中ACK标志位被设置为1，表示已经收到了对方的关闭请求确认。</li><li>一旦另一方收到这个确认报文段，它会进入TIME-WAIT状态，等待足够长的时间，确保对方已经接收到了确认，然后才会关闭连接。</li><li>这个TIME-WAIT状态的等待时间是为了处理可能在网络中延迟的报文段，以确保连接的正常关闭。</li></ul></li></ol><p>一旦TIME-WAIT状态结束，连接就会被正式关闭，双方都可以安全地释放资源并结束连接。这个四次握手的过程确保了双方都同意关闭连接，并在关闭后处理可能存在的未传输完的数据和网络延迟。这提供了可靠的连接终止机制。</p><h1 id="Network-Protocol"><a href="#Network-Protocol" class="headerlink" title="Network Protocol"></a>Network Protocol</h1><p>无线传输技术按传输距离可划分为两类：</p><ol><li>低功耗、短距离、局域网通信技术(几米-几百米)：LP-LAN(Iow-power Local-Area Network)<br>包括<a href="#zigbee%E5%8D%8F%E8%AE%AE">Zigbee</a>、<a href="#wifi%E5%8D%8F%E8%AE%AE">WiFi</a>、<a href="#%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE">蓝牙</a>等为代表的短距离传输技术。</li><li>低功耗、长距离、广域网通信技术（几千米到几十千米）：LP-WAN(Iow-power Wide-Area Network)<br>LPWAN又可分为两类：<ol><li>工作于未授权免费频谱：如<a href="#lora">LoRa</a>、<a href="#sigfox">Sigfox</a>等技术；</li><li>工作于授权收费频谱下：3GPP支持的2/3/4/5G蜂窝通信技术，比如eMTC（enhanced machinetype of communication,增强机器类通信）、<a href="#nb-iot">NB-loT</a>(Narrow Band Internet of Things,窄带物联网)</li></ol></li></ol><h2 id="LP-LAN-Iow-power-Local-Area-Network"><a href="#LP-LAN-Iow-power-Local-Area-Network" class="headerlink" title="LP-LAN(Iow-power Local-Area Network)"></a>LP-LAN(Iow-power Local-Area Network)</h2><h3 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h3><p>Wi-Fi（无线局域网）是一种无线网络技术，用于无线数据传输和连接设备到互联网或局域网。Wi-Fi传输协议是定义Wi-Fi网络如何工作的一组规则和标准。以下是一些Wi-Fi传输协议的基本元素：</p><ol><li><p>[<strong>IEEE 802.11协议族</strong>](：IEEE（电子与电气工程师协会）定义了一系列的Wi-Fi标准，通常以802.11开头。这些标准包括802.11a、802.11b、802.11g、802.11n、802.11ac和802.11ax等。每个标准都定义了不同的频段、传输速率、信道宽度和其他参数，以满足不同的无线通信需求。</p></li><li><p><strong>无线接入点（Access Point）</strong>：Wi-Fi网络通常包括一个或多个无线接入点，它们充当中继站点，将有线网络连接扩展到无线设备。Wi-Fi接入点通常遵循802.11标准，以创建可用于连接的无线网络。</p></li><li><p><strong>WEP（Wired Equivalent Privacy）</strong>：WEP是早期的Wi-Fi安全协议，用于加密数据传输。然而，WEP已经被证明不安全，易于破解，不建议使用。</p></li><li><p><strong>WPA（Wi-Fi Protected Access）</strong>：WPA是WEP的替代品，提供更强的安全性。WPA使用TKIP（Temporal Key Integrity Protocol）或更强的AES（Advanced Encryption Standard）加密算法来保护数据传输。</p></li><li><p><strong>WPA2和WPA3</strong>：WPA2是WPA的进化版本，使用更强的加密算法，如CCMP（Counter Mode with Cipher Block Chaining Message Authentication Code Protocol）。WPA3是WPA2的下一代，引入更多的安全功能，提供更好的保护。</p></li><li><p><strong>SSID（Service Set Identifier）</strong>：SSID是Wi-Fi网络的名称，用于区分不同的网络。当您搜索可用的Wi-Fi网络时，会看到各种SSID，您可以选择连接到其中一个。</p></li><li><p><strong>MAC地址过滤</strong>：许多Wi-Fi路由器支持MAC地址过滤，这意味着只有在已经授权的设备的MAC地址在路由器中注册时才能连接到网络。这提供了一定的安全性，但也需要管理员手动管理。</p></li><li><p><strong>频段</strong>：Wi-Fi运行在2.4 GHz和5 GHz频段。2.4 GHz频段通常有更好的穿透性，但更容易受到干扰，5 GHz频段提供更高的速度和更少的干扰。</p></li><li><p><strong>双频Wi-Fi</strong>：某些路由器支持同时在2.4 GHz和5 GHz频段上运行，以提供更好的性能和覆盖范围。</p></li><li><p><strong>Mesh网络</strong>：Mesh网络是一种Wi-Fi配置，其中多个无线接入点协同工作，以覆盖大面积区域并提供更好的覆盖范围和性能。</p></li></ol><h4 id="WiFi协议栈"><a href="#WiFi协议栈" class="headerlink" title="WiFi协议栈"></a>WiFi协议栈</h4><p>Wi-Fi协议栈是一种层次化的网络协议体系结构，用于描述Wi-Fi网络通信的各个层次和组件。这个协议栈通常可以划分为以下不同的层次，类似于OSI（开放系统互连）模型的七层协议模型：</p><ol><li><p><strong>物理层（Physical Layer）</strong>：物理层是Wi-Fi协议栈的底层，负责处理与物理媒体（空气）的交互。它定义了Wi-Fi信号的传输方式、频段、调制解调方式以及无线传输的一些特性。不同的Wi-Fi标准可以在不同的频段上运行，例如2.4 GHz和5 GHz。</p></li><li><p><strong>数据链路层（Data Link Layer）</strong>：数据链路层分为两个子层：</p><ul><li><p><strong>逻辑链路控制（Logical Link Control，LLC）</strong>：LLC子层负责处理数据帧的逻辑控制，例如帧的识别和数据帧的路由。</p></li><li><p><strong>介质访问控制（Medium Access Control，MAC）</strong>：MAC子层负责管理多个设备在共享无线媒体上的访问。它定义了如何分配时间片（时间分割多路复用）、如何处理冲突以及如何进行帧的发送和接收。</p></li></ul></li><li><p><strong>网络层（Network Layer）</strong>：网络层负责处理设备之间的路由和数据包转发。在Wi-Fi网络中，通常使用的是IP协议（Internet Protocol）来管理设备的地址分配和数据包的路由。</p></li><li><p><strong>传输层（Transport Layer）</strong>：传输层负责提供端到端的通信服务，通常使用TCP（Transmission Control Protocol）或UDP（User Datagram Protocol）来管理数据包的可靠传输。</p></li><li><p><strong>会话层（Session Layer）</strong>：在Wi-Fi协议栈中，通常没有专门的会话层，因为Wi-Fi通常在OSI模型之上运行，而不直接处理会话级别的通信。</p></li><li><p><strong>表示层（Presentation Layer）</strong>：与会话层一样，Wi-Fi协议栈通常不包括专门的表示层，因为它们主要关注物理层到传输层之间的数据处理。</p></li><li><p><strong>应用层（Application Layer）</strong>：应用层包含各种应用程序和协议，它们使用Wi-Fi网络进行通信。这包括Web浏览器、电子邮件客户端、视频流媒体应用程序等。</p></li></ol><blockquote><p>Wi-Fi协议栈是一个多层次的网络协议堆栈，每个层次都有特定的功能和责任。这个堆栈允许Wi-Fi设备在无线网络上进行通信，从物理层的无线信号传输到应用层的网络应用程序。不同的Wi-Fi标准和技术可以在这个通用协议栈的基础上进行扩展和定制，以满足不同的通信需求。</p></blockquote><h4 id="WiFi所用技术"><a href="#WiFi所用技术" class="headerlink" title="WiFi所用技术"></a>WiFi所用技术</h4><p>Wi-Fi（无线局域网）技术涉及多个方面，包括物理层和数据链路层的技术，以及网络和安全性方面的技术。以下是Wi-Fi所用到的关键技术：</p><ol><li><p><strong>物理层技术</strong>：</p><p>a. <strong>频段</strong>：Wi-Fi工作在不同的频段，如2.4 GHz和5 GHz。不同频段有不同的特性，2.4 GHz信号穿透性较好，但容易受到干扰，而5 GHz提供更高的速度和更少的干扰。</p><p>b. <strong>调制解调技术</strong>：Wi-Fi使用不同的调制解调技术来传输数据，包括QPSK、16-QAM、64-QAM等，这些技术决定了每个符号传输多少比特。</p><p>c. <strong>MIMO（Multiple Input Multiple Output）</strong>：MIMO技术允许设备使用多个天线来同时传输和接收多个数据流，提高了数据传输速度和可靠性。</p></li><li><p><strong>数据链路层技术</strong>：</p><p>a. <strong>CSMA/CA（Carrier Sense Multiple Access with Collision Avoidance）</strong>：这是一种多访问技术，用于协调多个设备在共享无线媒体上的访问，以防止碰撞。</p><p>b. <strong>帧结构</strong>：Wi-Fi数据通过不同类型的帧进行传输，包括管理帧、控制帧和数据帧，每种帧类型有不同的功能和用途。</p><p>c. <strong>帧聚合</strong>：802.11n以及更高版本的Wi-Fi标准支持帧聚合，将多个数据帧组合成一个较大的帧，以提高效率。</p></li><li><p><strong>网络技术</strong>：</p><p>a. <strong>IP协议</strong>：Wi-Fi网络通常运行在TCP/IP协议栈之上，使用IP地址来标识和路由数据包。</p><p>b. <strong>DHCP（Dynamic Host Configuration Protocol）</strong>：DHCP用于自动分配IP地址给连接到Wi-Fi网络的设备，简化了网络配置。</p><p>c. <strong>NAT（Network Address Translation）</strong>：NAT用于将内部网络中的多个设备映射到单个公共IP地址，允许多个设备共享一个IP地址访问互联网。</p></li><li><p><strong>安全性技术</strong>：</p><p>a. <strong>WEP（Wired Equivalent Privacy）</strong>：虽然不再安全，但WEP曾经用于对Wi-Fi数据进行基本的加密。</p><p>b. <strong>WPA（Wi-Fi Protected Access）</strong>：WPA是一种更安全的加密协议，使用TKIP或AES加密算法来保护数据传输。</p><p>c. <strong>WPA2和WPA3</strong>：WPA2和WPA3是WPA的进化版本，提供更强的安全性，采用更先进的加密和认证技术。</p><p>d. <strong>802.1X认证</strong>：802.1X认证用于身份验证设备并授权其访问Wi-Fi网络。</p></li><li><p><strong>管理和漫游技术</strong>：</p><p>a. <strong>SSID（Service Set Identifier）</strong>：SSID用于标识无线网络，用户可以选择连接到的网络。</p><p>b. <strong>漫游</strong>：漫游允许设备在不同的接入点之间切换，以保持网络连接的连续性。</p></li></ol><blockquote><p>Wi-Fi技术包括多个层次的技术，从物理层到网络层和安全性层，以实现无线数据传输和连接。这些技术不断发展和改进，以满足不断增长的无线通信需求，并提供更好的性能、安全性和可靠性。</p></blockquote><h4 id="Wi-Fi协议的传输框架和工作原理"><a href="#Wi-Fi协议的传输框架和工作原理" class="headerlink" title="Wi-Fi协议的传输框架和工作原理"></a>Wi-Fi协议的传输框架和工作原理</h4><p><strong>1. 传输框架（Frame Structure）：</strong></p><p>Wi-Fi数据传输使用不同类型的帧（frame）来组织和传输数据。这些帧主要包括以下几种类型：</p><ul><li><p><strong>管理帧（Management Frames）</strong>：管理帧用于建立和管理Wi-Fi连接，包括扫描附近的网络、建立连接、认证和协商加密等。例如，关联请求（Association Request）和关联响应（Association Response）是用于建立连接的管理帧。</p></li><li><p><strong>控制帧（Control Frames）</strong>：控制帧用于控制数据传输和管理网络拓扑，例如，通知接收方暂停传输或重新发送数据等。控制帧对于Wi-Fi网络的正常运行至关重要。</p></li><li><p><strong>数据帧（Data Frames）</strong>：数据帧用于传输实际数据，例如，从一个设备发送到另一个设备的数据包。数据帧包含了数据的有效载荷，以及一些控制信息，如源地址和目的地址。</p></li></ul><p><strong>2. 工作原理：</strong></p><ul><li><p><strong>Access Point (AP)（接入点）</strong>：Wi-Fi网络通常由一个或多个接入点组成，它们是连接无线设备到有线网络的桥梁。接入点负责无线设备的关联和数据传输。</p></li><li><p><strong>无线设备</strong>：这些设备可以是笔记本电脑、智能手机、平板电脑、IoT设备等，它们通过Wi-Fi接口与接入点连接。</p></li><li><p><strong>SSID（Service Set Identifier）</strong>：SSID是一个用于识别Wi-Fi网络的名称。当您搜索可用的Wi-Fi网络时，将看到各种SSID，您可以选择要连接的网络。</p></li><li><p><strong>关联（Association）</strong>：在设备连接到Wi-Fi网络之前，它必须与接入点建立关联。关联涉及设备发送关联请求帧，接入点回应关联响应帧，之后设备就可以与网络通信。</p></li><li><p><strong>认证（Authentication）</strong>：认证是另一个安全步骤，确保设备有权限连接到网络。常见的认证方法包括使用预共享密钥（PSK）或基于802.1X的认证。</p></li><li><p><strong>加密（Encryption）</strong>：为了保护数据的机密性，Wi-Fi网络通常使用加密算法对数据进行加密。常见的加密方法包括WEP、WPA2和WPA3。</p></li><li><p><strong>信道管理（Channel Management）</strong>：Wi-Fi网络运行在不同的频段，如2.4 GHz和5 GHz，这些频段被分成多个信道。信道管理是确保不同网络之间不干扰的重要部分。</p></li><li><p><strong>漫游（Roaming）</strong>：当无线设备在网络覆盖范围内移动时，它可以自动切换到最强信号的接入点，以确保稳定的连接。</p></li></ul><blockquote><p>Wi-Fi的工作原理涉及上述步骤，设备通过管理帧和数据帧在网络中通信，接入点和其他设备根据协议来协调通信，确保数据的可靠传输和网络的稳定性。同时，Wi-Fi网络还提供了各种安全措施，以确保数据的保密性和完整性。</p></blockquote><h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><p>蓝牙通信协议是一组规范，用于在短距离范围内（通常为数米）实现无线数据传输和连接设备。蓝牙通信协议定义了通信设备之间的通信方式、数据传输速率、电源管理和安全性等方面的规则。以下是蓝牙通信协议的关键部分：</p><ol><li><p><strong>蓝牙核心规范</strong>：</p><ul><li><p><strong>物理层</strong>：蓝牙设备通常使用2.4 GHz的ISM（工业、科学和医疗）频段进行通信，采用GFSK（Gaussian Frequency Shift Keying）调制方式。物理层规范定义了无线传输的基本参数。</p></li><li><p><strong>数据链路层</strong>：蓝牙数据链路层包括两个子层：主从子层和逻辑链路控制子层（LLC）。主从子层负责建立连接并进行数据传输，而LLC子层处理逻辑链路控制和数据帧管理。</p></li></ul></li><li><p><strong>蓝牙通信模式</strong>：</p><ul><li><p><strong>经典蓝牙</strong>：用于传输音频、数据和图像等多种类型的信息。包括蓝牙基本速率（BR）和增强数据速率（EDR）两种模式，支持最高3 Mbps的数据传输速率。</p></li><li><p><strong>低功耗蓝牙（Bluetooth Low Energy，BLE）</strong>：设计用于低功耗设备，如传感器、健康监测设备和可穿戴设备。BLE具有较低的数据传输速率，但非常节能，允许设备在数月或数年内持续运行。</p></li></ul></li><li><p><strong>蓝牙连接和通信</strong>：</p><ul><li><p><strong>蓝牙连接</strong>：蓝牙设备可以建立点对点连接（例如，手机与耳机）或点对多点连接（例如，手机与多个耳机）。连接由一个主设备和一个或多个从设备组成。</p></li><li><p><strong>蓝牙服务和特征</strong>：蓝牙设备通过服务和特征来组织和交换数据。服务表示设备可提供的功能，而特征表示服务中的数据点。</p></li><li><p><strong>蓝牙配置文件</strong>：蓝牙配置文件定义了特定用途的设备之间的通信方式。例如，HFP（Hands-Free Profile）用于蓝牙耳机和手机之间的通话。</p></li></ul></li><li><p><strong>蓝牙安全性</strong>：</p><ul><li><p><strong>蓝牙配对</strong>：为了建立安全连接，蓝牙设备需要在配对过程中交换密钥。常见的配对方法包括PIN码输入、数字签名和自动确认。</p></li><li><p><strong>数据加密</strong>：蓝牙支持数据加密，以保护数据的机密性。通常使用AES（Advanced Encryption Standard）加密算法来加密传输的数据。</p></li></ul></li><li><p><strong>蓝牙应用</strong>：</p><ul><li><p><strong>音频传输</strong>：蓝牙用于耳机、音箱、车载音响等音频设备的连接和音频传输。</p></li><li><p><strong>数据传输</strong>：蓝牙用于文件传输、数据同步和键盘鼠标等外设的连接。</p></li><li><p><strong>位置服务</strong>：BLE用于定位和跟踪设备，如室内导航和物品追踪。</p></li><li><p><strong>健康和医疗设备</strong>：BLE用于连接健康监测设备、心率监测器和药品管理器等。</p></li></ul></li></ol><blockquote><p>蓝牙通信协议的灵活性和广泛应用使其成为连接各种设备和实现无线通信的重要技术。无论是通过经典蓝牙还是低功耗蓝牙，蓝牙技术都在多个领域提供了便捷的无线通信解决方案。</p></blockquote><h4 id="蓝牙协议栈"><a href="#蓝牙协议栈" class="headerlink" title="蓝牙协议栈"></a>蓝牙协议栈</h4><p>蓝牙协议栈是一组层次化的协议和协议层，用于管理蓝牙设备之间的通信。它定义了蓝牙通信的各个层次和组件，包括物理层、链路层、主机控制器接口（HCI）、L2CAP（逻辑链路控制和适配层协议）、SDP（服务发现协议）、RFCOMM（串行端口协议）和各种蓝牙配置文件。以下是蓝牙协议栈的主要组成部分：</p><ol><li><p><strong>物理层</strong>：蓝牙物理层定义了蓝牙设备之间的无线通信方式，包括频率、调制方式和传输功率。蓝牙通常在2.4 GHz ISM（工业、科学和医疗）频段上运行，使用频率跳跃扩频技术。</p></li><li><p><strong>链路层</strong>：链路层包括两个子层，即主从子层和逻辑链路控制子层（LLC）。主从子层负责建立连接和管理数据传输，而LLC子层处理逻辑链路控制和数据帧管理。</p></li><li><p><strong>主机控制器接口（HCI）</strong>：HCI定义了蓝牙协议栈与蓝牙硬件之间的接口，允许上层协议栈与底层硬件通信。HCI层负责将高级命令翻译成硬件操作，同时处理来自硬件的事件和数据。</p></li><li><p><strong>逻辑链路控制和适配层协议（L2CAP）</strong>：L2CAP层用于管理数据分组的传输，支持可靠和不可靠的数据传输。它还允许多个逻辑通道的复用和分解。</p></li><li><p><strong>服务发现协议（SDP）</strong>：SDP用于发现和描述远程蓝牙设备提供的服务和特性。它允许设备查找和连接到特定的蓝牙服务。</p></li><li><p><strong>串行端口协议（RFCOMM）</strong>：RFCOMM是蓝牙协议栈中的串行端口协议，允许模拟串口连接，使蓝牙设备可以与传统串口设备进行通信。</p></li><li><p><a href="#%E8%93%9D%E7%89%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><strong>蓝牙配置文件</strong></a>：蓝牙配置文件定义了设备之间通信的规则和协议，以满足特定用途的需求。例如，蓝牙耳机和手机之间的通信可能使用Hands-Free Profile（HFP）配置文件。</p></li></ol><blockquote><p>蓝牙协议栈的灵活性和可扩展性使其适用于各种不同类型的应用，从音频传输到数据同步，再到位置服务和健康监测。不同的设备可以使用不同的配置文件和协议来满足其通信需求。这个协议栈的层次化结构使蓝牙设备能够有效地进行通信，并支持各种蓝牙应用的开发和部署。</p></blockquote><h4 id="蓝牙通信框架和工作方式"><a href="#蓝牙通信框架和工作方式" class="headerlink" title="蓝牙通信框架和工作方式"></a>蓝牙通信框架和工作方式</h4><p>蓝牙通信协议的通信框架和工作方式是建立在蓝牙核心规范之上的，用于在蓝牙设备之间实现无线通信的基本结构和原理。下面是蓝牙协议的通信框架和工作方式的概述：</p><p><strong>通信框架</strong>：</p><ol><li><p><strong>蓝牙设备</strong>：蓝牙通信涉及两个或多个蓝牙设备，它们可以是手机、耳机、键盘、鼠标、传感器、汽车音响等各种设备。</p></li><li><p><strong>蓝牙协议栈</strong>：蓝牙协议栈是一组层次化的协议和协议层，它们规定了蓝牙设备之间的通信方式和规则。协议栈包括物理层、数据链路层、主机控制器接口（Host Controller Interface，HCI）、蓝牙管理器等。</p></li><li><p><strong>蓝牙连接</strong>：蓝牙设备之间建立连接是通信的第一步。通常，一个设备充当主设备（Master），而其他设备充当从设备（Slave）。主设备负责管理连接，从设备响应主设备的请求。</p></li><li><p><strong>蓝牙配置文件和服务</strong>：蓝牙通信依赖于配置文件和服务的定义，它们描述了设备之间可以交换的数据和功能。例如，蓝牙耳机和手机之间的通信可能使用Hands-Free Profile（HFP）配置文件。</p></li><li><p><strong>蓝牙特征和描述符</strong>：配置文件中的服务包含一个或多个特征，特征包含要交换的具体数据或命令。特征通常有相关的描述符，用于描述特征的属性和数据格式。</p></li></ol><p><strong>工作方式</strong>：</p><ol><li><p><strong>设备发现和配对</strong>：在建立连接之前，蓝牙设备必须进行发现和配对过程。设备会广播其存在，并等待其他设备响应。一旦两个设备发现彼此，它们可以进行配对，这通常涉及到安全的密钥交换。</p></li><li><p><strong>连接建立</strong>：一旦设备配对成功，它们可以建立连接。连接过程包括主设备和从设备之间的通信协商，选择通信通道和频率等。</p></li><li><p><strong>数据传输</strong>：一旦连接建立，设备可以开始交换数据。数据传输可以是双向的，涉及从一个设备发送数据并在另一个设备上接收数据。数据传输的速率和方式取决于设备的蓝牙版本和配置。</p></li><li><p><strong>断开连接</strong>：设备可以随时断开连接。连接可以是主动断开（由设备发起）或被动断开（由另一个设备或外部因素引起）。</p></li><li><p><strong>电源管理</strong>：蓝牙设备通常具有电源管理功能，可以进入低功耗模式以延长电池寿命。这在低功耗蓝牙（BLE）设备中尤为重要。</p></li></ol><blockquote><p>蓝牙通信协议的工作方式涉及设备之间的发现、配对、连接、数据传输和断开连接等步骤，所有这些都受到蓝牙核心规范的规则和定义的影响。</p></blockquote><h3 id="Zigbee"><a href="#Zigbee" class="headerlink" title="Zigbee"></a>Zigbee</h3><p>Zigbee是一种低功耗、短距离、无线通信协议，专为物联网（IoT）设备和传感器之间的通信而设计。它基于IEEE 802.15.4标准，并提供了一种低成本、低功耗的无线通信解决方案。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>低功耗：</strong> Zigbee设备通常在电池供电下工作，并采用了一系列的低功耗技术，包括睡眠模式和功率管理，以延长电池寿命。</p></li><li><p><strong>自组织mesh网络：</strong> Zigbee设备可以自动建立和维护自组织的网络，其中一个设备充当协调器（Coordinator），而其他设备（终端设备或路由器设备）加入网络并与协调器通信。</p></li><li><p><strong>低数据速率：</strong> Zigbee的数据传输速率通常较低，适用于传感器、监控和控制应用，而不是高带宽的数据传输。</p></li><li><p><strong>短距离通信：</strong> Zigbee通信通常在几十米到数百米的范围内，适用于局部网络和低范围设备之间的通信。</p></li><li><p><strong>多通道和多频率：</strong> Zigbee支持多通道和多频率操作，以减少干扰和提高可靠性。</p></li><li><p><strong>安全性：</strong> Zigbee提供了多种安全特性，包括加密、身份验证和密钥管理，以保护通信中的数据安全。</p></li></ol><h4 id="Zigbee通信框架："><a href="#Zigbee通信框架：" class="headerlink" title="Zigbee通信框架："></a>Zigbee通信框架：</h4><p>Zigbee通信框架包括协调器（Coordinator）、路由器设备（Router Device）和终端设备（End Device），这些设备协同工作以建立和维护Zigbee网络。</p><ol><li><p><strong>协调器（Coordinator）：</strong></p><ul><li>每个Zigbee网络中都有一个协调器，通常是一个主设备，负责管理整个网络。</li><li>协调器负责创建网络、处理加入请求、分配短地址和长地址、管理路由信息，以及协调设备之间的通信。</li></ul></li><li><p><strong>路由器设备（Router Device）：</strong></p><ul><li>路由器设备具有中继数据的功能，它们帮助扩展网络范围和提高通信可靠性。</li><li>路由器设备可以处理数据转发，允许数据在网络中传递，从而构建多跳（multi-hop）通信路径。</li></ul></li><li><p><strong>终端设备（End Device）：</strong></p><ul><li>终端设备是低功耗设备，通常由电池供电，它们可以与协调器或路由器设备通信，但不能用于中继数据。</li><li>终端设备通常处于睡眠模式，以延长电池寿命，只在需要发送或接收数据时才唤醒。</li></ul></li></ol><h4 id="Zigbee通信工作流程："><a href="#Zigbee通信工作流程：" class="headerlink" title="Zigbee通信工作流程："></a>Zigbee通信工作流程：</h4><ol><li><p><strong>网络初始化：</strong></p><ul><li>协调器初始化网络并分配短地址和长地址给参与的设备。</li><li>路由器设备加入网络并建立与协调器的连接。</li></ul></li><li><p><strong>设备加入：</strong></p><ul><li>新设备想要加入Zigbee网络时，它会发送一个加入请求给协调器或路由器。</li><li>协调器或路由器确认并分配地址给新设备，将其纳入网络。</li></ul></li><li><p><strong>数据传输：</strong></p><ul><li>当设备想要传输数据时，它会封装数据成为数据帧，并将其发送给目标设备。</li><li>如果目标设备不在直接通信范围内，数据将通过路由器设备中继到达目标设备。</li></ul></li><li><p><strong>自组织网络：</strong></p><ul><li>Zigbee网络是自组织的，设备之间可以根据需要重新组织通信路径。</li><li>路由器设备可用于创建多跳通信路径，以便在设备之间进行数据中继。</li></ul></li><li><p><strong>低功耗模式：</strong></p><ul><li>终端设备通常处于睡眠模式，以节省能量。它们会定期唤醒以接收来自协调器或路由器的数据。</li></ul></li><li><p><strong>安全性：</strong></p><ul><li>Zigbee提供了安全特性，包括数据加密和身份验证，以保护通信的安全性。</li></ul></li></ol><p>总结来说，Zigbee协议的通信框架基于自组织的网络，包括协调器、路由器设备和终端设备。通信工作流程涉及设备的加入、数据传输、网络管理和低功耗模式。这使Zigbee成为物联网设备之间低功耗、可靠通信的理想协议。</p><blockquote><p>Zigbee是一种用于低功耗、短距离、无线通信的协议，适用于许多不同的物联网应用领域。它的自组织网络能力、低功耗特性和安全性使其成为物联网设备之间通信的理想选择。</p></blockquote><h3 id="三种技术间的区别"><a href="#三种技术间的区别" class="headerlink" title="三种技术间的区别"></a>三种技术间的区别</h3><table><thead><tr><th>技术</th><th>WiFi</th><th>蓝牙</th><th>Zigbee</th></tr></thead><tbody><tr><td>覆盖范围</td><td>100-300米，受环境影响</td><td>2-30米，受环境影响</td><td>50-300米，受环境影响</td></tr><tr><td>关键技术</td><td>OFDM调制，支持多用户多入</td><td>FHSS调制，支持多用户多入</td><td>DSSS调制，支持多用户多入</td></tr><tr><td>网络拓扑结构</td><td>星型或网状，支持WiFi Mesh</td><td>星型或网状，支持Sig Mesh</td><td>星型或网状，支持自组网和星型网络</td></tr><tr><td>频段</td><td>2.4GHz或5.8GHz</td><td>2.4GHz</td><td>2.4GHz或868/915MHz</td></tr><tr><td>带宽</td><td>20-160MHz</td><td>1MHz</td><td>0.6-2MHz</td></tr><tr><td>传输速率</td><td>高，可达300Mbps</td><td>中等，可达1Mbps</td><td>低，250kbps</td></tr><tr><td>安全性</td><td>WPA2加密算法，保证通信的安全性</td><td>AES加密算法，保证通信的安全性</td><td>AES加密算法，保证通信的安全性</td></tr><tr><td>电池寿命</td><td>短，几小时至几天，受使用频率和数据量影响</td><td>中等，几个月至几年，受使用频率和数据量影响</td><td>长，几年至十几年，受使用频率和数据量影响</td></tr><tr><td>互操作性</td><td>高，可以与任何支持WiFi技术的设备互操作</td><td>高，可以与任何支持蓝牙技术的设备互操作</td><td>中等，需要使用Zigbee协议栈和Zigbee网关设备</td></tr><tr><td>成本</td><td>中等至高，芯片成本高，需付授权费用</td><td>低，芯片成本低，无需付授权费用</td><td>高，芯片成本高，需付授权费用</td></tr><tr><td>适用场景</td><td>主要应用于高传输速率的场合，比如移动设备连接互联网、监控摄像头等。对稳定性、功耗等不敏感的场合。</td><td>主要应用于低成本低功耗的场合，比如智能手环、智能音箱、智能家居等。对传输速率和距离不敏感的场合。</td><td>主要应用于工业场合的组网。成本较高，但抗干扰性能强，组网稳定，延迟也较低。对传输速率和距离不敏感的场合。</td></tr></tbody></table><h2 id="LP-WAN-Iow-power-Wide-Area-Network"><a href="#LP-WAN-Iow-power-Wide-Area-Network" class="headerlink" title="LP-WAN(Iow-power Wide-Area Network)"></a>LP-WAN(Iow-power Wide-Area Network)</h2><h3 id="Lora"><a href="#Lora" class="headerlink" title="Lora"></a>Lora</h3><p>LoRa通信协议是一种用于低功耗、远距离无线通信的协议，适用于物联网（IoT）应用。LoRa（长程低功耗射频）技术采用了扩频调制方法，以实现在长距离范围内传输数据，并具有出色的抗干扰能力。LoRa通信协议通常分为两个主要变种：LoRaWAN和私有LoRa协议。</p><ol><li><p>LoRaWAN（LoRa Wide Area Network）：</p><p> LoRaWAN是一种公共开放标准的LoRa通信协议，旨在支持大规模的IoT应用。它具有以下主要特点：</p><ul><li><p><strong>开放标准</strong>：LoRaWAN是一个开放标准，可供不同厂商和组织使用，以确保互操作性。</p></li><li><p><a href="#%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91"><strong>星型拓扑</strong></a>：LoRaWAN通常采用星型网络拓扑，其中终端设备通过LoRa网关连接到网络服务器。</p></li><li><p><strong>安全性</strong>：LoRaWAN提供了数据加密和认证机制，以确保数据的安全性和完整性。</p></li><li><p><strong>多类别服务质量</strong>：LoRaWAN支持不同的服务质量类别，包括低延迟、低功耗和高容量模式。</p></li><li><p><strong>设备管理</strong>：LoRaWAN定义了设备注册、激活和管理机制，以便有效地管理大规模设备。</p></li></ul></li><li><p>私有LoRa协议：</p><p> 私有LoRa协议通常由组织或企业自行开发和实施，用于特定应用场景。这些协议通常不开放给其他组织使用，因此缺乏LoRaWAN的互操作性。私有LoRa协议可以根据特定需求进行定制，适应特定的通信范围、数据速率和安全性需求。</p></li></ol><blockquote><p>无论是LoRaWAN还是私有LoRa协议，LoRa通信协议的工作原理基本相似。它们都使用LoRa调制技术，以扩频的方式传输数据，从而实现了长距离通信和低功耗。终端设备通过LoRa网关连接到网络，数据经过网络服务器路由到应用服务器进行处理。</p></blockquote><blockquote><p>LoRa通信协议是一种强大的通信技术，适用于各种IoT应用，包括智能城市、农业、工业自动化和环境监测等领域。不同的协议变种可以根据具体需求选择，以满足不同应用场景的要求。</p></blockquote><h4 id="LoRa协议栈"><a href="#LoRa协议栈" class="headerlink" title="LoRa协议栈"></a>LoRa协议栈</h4><ol><li><p><strong>物理层（Physical Layer）</strong>：物理层是LoRa协议栈的底层，负责无线通信的硬件和无线信号传输。它包括以下方面：</p><ul><li><a href="#%E6%89%A9%E9%A2%91%E8%B0%83%E5%88%B6"><strong>扩频调制（Spread Spectrum Modulation）</strong></a>：LoRa使用扩频技术来传输数据，以提供长距离和高抗干扰性。</li><li><strong>频率选择（Frequency Selection）</strong>：LoRa设备可以在不同的频段操作，以避免干扰和选择适当的通信频率。</li><li><strong>功率控制（Power Control）</strong>：LoRa设备通常使用低功率，以延长电池寿命，并减少干扰。</li></ul></li><li><p><strong>数据链路层（Data Link Layer）</strong>：数据链路层包括以下子层，用于管理数据传输的可靠性和安全性：</p><ul><li><strong>LoRaWAN MAC层（LoRaWAN Media Access Control Layer）</strong>：LoRaWAN（LoRa Wide Area Network）是LoRa协议栈中最常用的协议，它定义了如何处理数据的传输、接入、帧结构和设备管理等问题。</li><li><strong>适配层（Adaptation Layer）</strong>：适配层用于将上层应用程序数据适配到LoRaWAN MAC层。</li></ul></li><li><p><strong>网络层（Network Layer）</strong>：网络层负责路由和管理数据的流动，确保数据从终端设备到应用服务器的传输。网络层通常由LoRaWAN协议定义。</p></li><li><p><strong>应用层（Application Layer）</strong>：应用层包括应用程序和相关的协议，用于处理传输的数据。这是最高层，通常由应用开发人员定义。</p></li></ol><p>总之，LoRa协议栈是一个多层次的协议体系结构，旨在支持长距离、低功耗的物联网通信。物理层负责无线信号传输，数据链路层和网络层负责管理数据的可靠传输，应用层则用于处理和应用数据。不同的LoRa应用可以使用不同的协议层次，但LoRaWAN是最常见和广泛应用的协议。</p><h4 id="LoRa系统框架"><a href="#LoRa系统框架" class="headerlink" title="LoRa系统框架"></a>LoRa系统框架</h4><ol><li><p><strong>终端设备（End Devices）</strong>：终端设备是物联网设备，例如传感器、监控摄像头或其他传感器节点。它们通过LoRa无线通信与网关通信。</p></li><li><p><strong>LoRa网关（Gateway）</strong>：LoRa网关是连接终端设备与网络服务器的设备。它们通常位于城市或地区内，负责接收来自终端设备的数据，并将其传输到网络服务器。</p></li><li><p><strong>网络服务器（Network Server）</strong>：网络服务器负责管理多个LoRa网关，并处理终端设备的数据。它协调数据的传输和处理，以确保数据可靠地传送到应用服务器。</p></li><li><p><strong>应用服务器（Application Server）</strong>：应用服务器是最终数据处理的地方。它接收来自网络服务器的数据，并执行数据处理、存储或触发应用程序逻辑。</p></li><li><p><strong>云服务/应用程序（Cloud Services/Application）</strong>：在一些情况下，云服务可以进一步处理数据，或者应用程序可以提供用户界面和控制。</p></li></ol><h4 id="LoRa工作原理"><a href="#LoRa工作原理" class="headerlink" title="LoRa工作原理"></a>LoRa工作原理</h4><p>LoRa通信使用了一种调制技术，称为<strong>扩频调制（Spread Spectrum Modulation）</strong>，以在长距离范围内传输数据。<br>以下是LoRa通信的工作原理：</p><ol><li><p><strong>数据编码和调制</strong>：在终端设备中，要传输的数据被编码并调制为LoRa信号。这包括将数字数据转换为符号序列，并使用扩频技术将它们传输出去。</p></li><li><p><strong>LoRa射频传输</strong>：LoRa信号以低功耗的方式通过无线信道传输到附近的LoRa网关。LoRa的长距离传输特性使得信号可以在数千米的范围内传输，而且对于穿透性较强的物体也有良好的适应性。</p></li><li><p><strong>LoRa网关接收</strong>：LoRa网关接收来自多个终端设备的信号，并将它们传输到网络服务器。</p></li><li><p><strong>网络服务器处理</strong>：网络服务器接收到来自多个网关的数据，协调数据的处理和路由。它确保数据按照指定的应用程序逻辑传输到应用服务器。</p></li><li><p><strong>应用服务器处理</strong>：应用服务器接收数据并进行处理。这可以包括数据解码、验证、存储和触发相应的应用程序逻辑。</p></li><li><p><strong>反向传输</strong>：如果需要向终端设备发送命令或控制信号，应用服务器可以将数据传输回网络服务器，再由网络服务器传输回终端设备。</p></li></ol><blockquote><p>LoRa通信协议允许长距离、低功耗的数据传输，适用于广泛的物联网应用，如智能城市、农业监测、工业自动化等。它的灵活性和可扩展性使得它成为许多物联网解决方案的选择。</p></blockquote><h3 id="Sigfox"><a href="#Sigfox" class="headerlink" title="Sigfox"></a>Sigfox</h3><p>Sigfox技术是一种专门为低功耗、低成本、低数据量的物联网（IoT）和机器对机器（M2M）应用而设计的远程蜂窝无线通信技术。它使用超窄带（UNB）调制技术在公共频段下传输信号，具有高抗干扰能力和远距离覆盖能力。<br>Sigfox是一种低功耗、远距离通信的LPWAN技术，适用于各种物联网应用，包括智能城市、农业监测、工业自动化和环境监测等。由于其低成本和长时间运行的能力，Sigfox已经在全球范围内得到广泛应用。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li><p><strong>低功耗</strong>：Sigfox设备非常省电，因此适用于电池供电的远程设备，可以运行多年而不需要更换电池。</p></li><li><p><strong>远距离通信</strong>：Sigfox通信具有出色的通信范围，可以覆盖数十公里的距离，这使其在大范围区域内的设备连接方面非常有用。</p></li><li><p><strong>低数据速率</strong>：Sigfox通信速率相对较低，适用于传输小量数据，例如传感器读数或报警信息。</p></li><li><p><strong>成本效益</strong>：Sigfox的设备和服务通常成本较低，这使其成为许多低成本IoT应用的选择。</p></li><li><p><strong>云集成</strong>：Sigfox通常与云平台集成，以便设备数据可以轻松地上传到云端进行处理和存储。</p></li><li><p><strong>全球覆盖</strong>：Sigfox提供了全球性的网络覆盖，使设备可以在全球范围内连接到云服务。</p></li></ol><h4 id="通信框架："><a href="#通信框架：" class="headerlink" title="通信框架："></a>通信框架：</h4><ol><li><p><strong>设备（Devices）</strong>：Sigfox网络中的设备通常是物联网（IoT）设备，如传感器、追踪器或监控设备。这些设备用于采集数据并将其传输到Sigfox网络。</p></li><li><p><strong>Sigfox基站（Sigfox Base Stations）</strong>：Sigfox基站是部署在城市和农村地区的设备，负责接收来自设备的数据。它们使用特殊的硬件和通信协议与设备通信。</p></li><li><p><strong>Sigfox云平台（Sigfox Cloud Platform）</strong>：Sigfox云平台用于接收、处理和存储设备发送的数据。它还支持设备管理和安全性。</p></li><li><p><strong>应用程序服务器（Application Server）</strong>：应用程序服务器是可选的组件，用于进一步处理设备数据并执行特定的应用程序逻辑。它与Sigfox云平台集成，可以将数据传输到用户自定义的应用程序中。</p></li></ol><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><ol><li><p><strong>设备数据采集</strong>：设备采集环境数据或其他相关信息，并将其准备好以供传输。这可以是温度、湿度、位置信息等等。</p></li><li><p><strong>数据传输</strong>：设备使用Sigfox通信协议将数据发送到最近的Sigfox基站。这通常涉及到设备以低功率发送小量数据。</p></li><li><p><strong>基站接收</strong>：Sigfox基站接收设备发送的数据，并对其进行处理。这些基站通常分布在城市和乡村，以提供广泛的覆盖范围。</p></li><li><p><strong>数据上传到Sigfox云平台</strong>：Sigfox基站将接收到的数据上传到Sigfox云平台。云平台会处理数据并存储它，以便用户后续访问和分析。</p></li><li><p><strong>应用程序服务器集成（可选）</strong>：如果用户需要进一步处理数据或将数据传输到自定义应用程序中，可以将应用程序服务器集成到Sigfox云平台中。应用程序服务器可以执行数据处理、警报触发或其他应用逻辑。</p></li><li><p><strong>用户应用程序</strong>：最终，用户可以访问Sigfox云平台或应用程序服务器，以查看和分析设备数据，执行控制操作或生成报告。</p></li></ol><h3 id="NB-IoT"><a href="#NB-IoT" class="headerlink" title="NB-IoT"></a>NB-IoT</h3><p>NB-IOT (Narrow Band Internet of Things)是物联网领域的一个新兴技术，支持低功耗设备在广域网的蜂窝数据连接，也被叫作低功耗广域网 (LPWAN)。NB-IOT基于蜂窝的窄带物联网，是3GPP LTE Release 13的新增网络协议，与现有LTE网络兼容. NB-IOT构建于蜂窝网络，只消耗大约180KHz的带宽，可直接部署于GSM网络、UMTS网络或LTE网络，以降低部署成本、实现平滑升级.</p><h4 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h4><ol><li><p><strong>低功耗：</strong> NB-IoT设备具有极低的功耗特性，可以长时间运行，通常使用电池供电。这使其非常适用于远程、难以维护的设备。</p></li><li><p><strong>长距离通信：</strong> NB-IoT通信具有出色的通信范围，可以覆盖几公里到数十公里的距离，这取决于信号强度和环境条件。</p></li><li><p><strong>窄带宽：</strong> NB-IoT通信采用窄带宽信号，通常在200 kHz以下，这有助于减少通信设备的功耗，同时允许多个设备在相同的频段上进行通信。</p></li><li><p><strong>低成本：</strong> NB-IoT设备成本相对较低，因为它们可以使用现有的移动通信基础设施和频谱资源。</p></li><li><p><strong>互操作性：</strong> NB-IoT是一个标准化的通信技术，确保不同厂商的设备可以互操作，并能够在全球范围内运行。</p></li><li><p><strong>安全性：</strong> NB-IoT通信具有内置的安全功能，包括数据加密和身份验证，以确保数据的保密性和完整性。</p></li></ol><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ol><li><p><strong>窄带宽调制（Narrowband Modulation）</strong>：NB-IoT通信使用窄带宽信号进行通信，通常在200 kHz以下。这种窄带宽信号可以有效减小功耗，并提供长距离通信能力。</p></li><li><p><strong>低功耗设计</strong>：NB-IoT设备采用了多种低功耗设计技术，包括深度睡眠模式、功耗优化的硬件和通信堆栈，以确保设备能够长时间运行，通常使用电池供电。</p></li><li><p><strong>覆盖增强技术</strong>：NB-IoT通过使用信号重复、波束成形和室内覆盖技术等方法来提高信号的覆盖范围，使其能够穿越障碍物和进入深层室内区域。</p></li><li><p><strong>信号增强技术</strong>：在低信号强度环境下，NB-IoT使用信号增强技术，如接收多路径信号、错误纠正码和自动重传请求（ARQ），以提高通信的可靠性。</p></li><li><p><strong>多连接技术</strong>：NB-IoT支持多设备同时连接到同一基站，这使其能够处理大规模的设备连接，同时提供高质量的服务。</p></li><li><p><strong>安全性技术</strong>：NB-IoT通信包括数据加密、身份验证和认证，以确保数据的保密性和完整性，防止未经授权的访问和攻击。</p></li><li><p><strong>频谱分配</strong>：NB-IoT通信通常使用现有的无线电频谱资源，以便降低运营商的成本，并提高物联网设备的互操作性。</p></li><li><p><strong>云集成</strong>：NB-IoT设备通常与云平台集成，以便设备数据可以上传到云端进行处理、存储和分析。</p></li><li><p><strong>低数据速率</strong>：NB-IoT通信通常以低数据速率传输小量数据，适用于传感器读数、监控信息等应用。</p></li><li><p><strong>全球覆盖</strong>：NB-IoT通信技术可以通过现有的4G和5G网络基础设施实现全球范围的覆盖，因此在全球范围内提供了通信服务。</p></li></ol><blockquote><p>这些关键技术使NB-IoT成为一种强大的低功耗广域网通信技术，适用于各种物联网应用，包括智能城市、农业、工业自动化、健康监测和环境监测等领域。它的特点包括长距离通信、低成本、低功耗和高度安全性，使其成为物联网设备的首选通信技术之一。</p></blockquote><h4 id="通信框架：-1"><a href="#通信框架：-1" class="headerlink" title="通信框架："></a>通信框架：</h4><p>NB-IoT通信框架包括以下关键组件：</p><ol><li><p><strong>NB-IoT设备</strong>：这些设备是物联网（IoT）设备，如传感器、监测器、计量器等，用于采集数据或执行特定任务。</p></li><li><p><strong>NB-IoT基站</strong>：NB-IoT基站是无线通信设备，用于与NB-IoT设备进行通信。它们通常由移动网络运营商部署，并负责管理通信连接。</p></li><li><p><strong>核心网络</strong>：核心网络是移动网络运营商的一部分，它负责管理设备的连接、数据传输和安全性。它包括各种功能，如数据路由、设备身份验证和计费。</p></li><li><p><strong>云平台</strong>：云平台通常是第三方提供的服务，用于接收、存储和处理来自NB-IoT设备的数据。它还支持数据分析、可视化和用户接口。</p></li><li><p><strong>应用程序服务器</strong>：应用程序服务器是用户自定义的服务器，用于进一步处理设备数据、生成警报、执行远程控制和集成到其他应用程序中。</p></li></ol><h4 id="工作流程：-1"><a href="#工作流程：-1" class="headerlink" title="工作流程："></a>工作流程：</h4><ol><li><p><strong>设备通信</strong>：</p><ul><li>NB-IoT设备采集环境数据或执行特定任务。</li><li>设备使用NB-IoT通信协议与最近的NB-IoT基站建立通信连接。</li></ul></li><li><p><strong>数据传输</strong>：</p><ul><li>设备将采集到的数据封装成数据包，并以低功耗方式发送给NB-IoT基站。</li><li>数据包经过NB-IoT基站的处理，包括数据解码和解密。</li></ul></li><li><p><strong>核心网络处理</strong>：</p><ul><li>NB-IoT基站将数据传输到核心网络，核心网络负责路由数据包并将其发送到目标位置。</li><li>核心网络执行设备身份验证，确保只有授权设备能够连接和传输数据。</li></ul></li><li><p><strong>数据上传到云平台</strong>：</p><ul><li>核心网络将数据上传到云平台，云平台接收并存储数据。</li><li>云平台可以执行数据处理、数据分析和可视化等操作，以帮助用户理解设备数据。</li></ul></li><li><p><strong>应用程序服务器集成（可选）</strong>：</p><ul><li>用户可以选择将应用程序服务器集成到云平台中，以进一步处理数据或执行特定的应用程序逻辑。</li><li>应用程序服务器可以执行警报生成、远程控制设备、数据分析等操作。</li></ul></li><li><p><strong>用户应用程序</strong>：</p><ul><li>最终，用户可以通过用户应用程序或Web界面访问云平台，以查看设备数据、生成报告、控制设备或执行其他操作。</li></ul></li></ol><blockquote><p>通过NB-IoT设备、基站、核心网络、云平台和应用程序服务器等组件，实现了设备数据的采集、传输、处理和分析。这使用户能够实时监控和管理物联网设备，从而支持各种应用场景，包括智能城市、农业、工业自动化和健康监测。</p></blockquote><h3 id="Lora，Sigfox，NB-IoT比较"><a href="#Lora，Sigfox，NB-IoT比较" class="headerlink" title="Lora，Sigfox，NB-IoT比较"></a>Lora，Sigfox，NB-IoT比较</h3><table><thead><tr><th>技术</th><th>LoRa</th><th>Sigfox</th><th>NB-IoT</th></tr></thead><tbody><tr><td><strong>覆盖范围</strong></td><td>1-20公里，受环境影响</td><td>3-50公里，受环境影响</td><td>15公里以上，信号穿透能力强</td></tr><tr><td><strong>关键技术</strong></td><td>扩频调制，抗干扰能力强</td><td>超窄带调制，抗干扰能力强</td><td>窄带调制，与现有LTE网络兼容</td></tr><tr><td><strong>网络拓扑结构</strong></td><td>星型或网状，可自组网或接入云端平台</td><td>星型，接入云端平台，提供全球性的网络服务</td><td>星型或网状，接入电信运营商的网络基站和云端平台</td></tr><tr><td><strong>频段</strong></td><td>免授权的ISM频段，如433MHz，470MHz等</td><td>免授权的ISM频段，如868MHz，915MHz等</td><td>授权频段，如800MHz，900MHz等</td></tr><tr><td><strong>带宽</strong></td><td>125-500KHz</td><td>&lt;100Hz</td><td>180KHz</td></tr><tr><td><strong>数据速率</strong></td><td>0.3-50kbps，可调节速率和距离</td><td>0.1kbps，固定速率和距离</td><td>200kbps以下，可调节速率和距离</td></tr><tr><td><strong>安全性</strong></td><td>AES加密算法，保证通信的安全性</td><td>AES加密算法，保证通信的安全性</td><td>AES加密算法，保证通信的安全性</td></tr><tr><td><strong>开放标准</strong></td><td>LoRaWAN协议栈，由LoRa联盟制定和管理</td><td>Sigfox协议栈，由Sigfox公司制定和管理</td><td>NB-IoT协议栈，由3GPP制定和管理</td></tr><tr><td><strong>电池寿命</strong></td><td>5-10年，受传输次数和数据量影响</td><td>10年以上，受传输次数和数据量影响</td><td>5-10年，受传输次数和数据量影响</td></tr><tr><td><strong>互操作性</strong></td><td>低，需要使用LoRaWAN协议栈和LoRa网关设备</td><td>高，可以与任何支持Sigfox技术的设备互操作³</td><td>高，可以与任何支持NB-IoT技术的设备互操作</td></tr><tr><td><strong>部署成本</strong></td><td>中等，需要购买和安装LoRa网关设备</td><td>低，无需自行部署网络基站或网关设备</td><td>中等至高，需要购买和安装NB-IoT模块，并依赖电信运营商的网络覆盖</td></tr><tr><td><strong>维护成本</strong></td><td>中等，需要管理和维护LoRa网关设备和网络</td><td>低，无需自行管理和维护网络基站或网关设备</td><td>中等至高，需要管理和维护NB-IoT模块，并依赖电信运营商的网络服务</td></tr><tr><td><strong>总成本</strong></td><td>中等至低，芯片成本低，无需付授权费用</td><td>中等至高，芯片成本低，需付月租费用</td><td>高，芯片成本高，需付授权费用</td></tr><tr><td><strong>适用场景</strong></td><td>适合于远距离、低速率、低功耗的物联网应用，如智能农业、智能停车、智能照明等</td><td>适合于远距离、极低速率、极低功耗的物联网应用，如资产追踪、环境监测、安防报警等</td><td>适合于远距离、低至中速率、低功耗的物联网应用，如智能水表、智能电表、智能燃气表等</td></tr></tbody></table><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="WiFi标准"><a href="#WiFi标准" class="headerlink" title="WiFi标准"></a>WiFi标准</h3><p>Wi-Fi标准是一组IEEE 802.11系列规范，用于定义无线局域网络（Wi-Fi）的技术和协议。以下是一些主要的Wi-Fi标准，以及它们的详细解释：</p><table><thead><tr><th>Wi-Fi标准</th><th>速度</th><th>频段</th><th>特点</th></tr></thead><tbody><tr><td><strong>802.11b</strong></td><td>最高11 Mbps</td><td>2.4 GHz</td><td>802.11b是第一个广泛采用的Wi-Fi标准，使用2.4 GHz频段和DSSS调制技术。虽然速度较低，但为Wi-Fi技术的发展铺平了道路。</td></tr><tr><td><strong>802.11a</strong></td><td>最高54 Mbps</td><td>5 GHz</td><td>802.11a是第一个在5 GHz频段上运行的Wi-Fi标准，提供更高的速度和更少的干扰，但覆盖范围较小。</td></tr><tr><td><strong>802.11g</strong></td><td>最高54 Mbps</td><td>2.4 GHz</td><td>802.11g标准兼容802.11b，提供了更高的速度，并在2.4 GHz频段上成为主流Wi-Fi技术。</td></tr><tr><td><strong>802.11n (Wi-Fi 4)</strong></td><td>最高600 Mbps</td><td>2.4 GHz和5 GHz</td><td>802.11n引入了MIMO技术，提供更高的速度和更好的覆盖范围，可在2.4 GHz和5 GHz频段上运行。</td></tr><tr><td><strong>802.11ac (Wi-Fi 5)</strong></td><td>最高1.3 Gbps</td><td>5 GHz</td><td>802.11ac进一步提高了速度，使用更多的MIMO流和更宽的信道宽度，通常在5 GHz频段上运行。</td></tr><tr><td><strong>802.11ax (Wi-Fi 6)</strong></td><td>最高10 Gbps</td><td>2.4 GHz和5 GHz</td><td>802.11ax引入了OFDMA和MU-MIMO等技术，旨在提供更高的速度和性能，减少网络拥塞。</td></tr><tr><td><strong>802.11ay</strong></td><td>最高20 Gbps</td><td>60 GHz</td><td>802.11ay是在60 GHz频段上运行的Wi-Fi标准，提供极高的速度，适用于高速数据传输和低延迟的场景。</td></tr><tr><td><strong>802.11ad</strong></td><td>最高7 Gbps</td><td>60 GHz</td><td>802.11ad是WiGig标准的前身，也在60 GHz频段上运行，用于高速数据传输，例如无线视频传输。</td></tr></tbody></table><blockquote><p>每个Wi-Fi标准都引入了不同的技术和改进，以适应不同的应用场景和需求。用户可以根据其设备和网络需求选择合适的Wi-Fi标准来获得最佳性能和覆盖范围。值得注意的是，Wi-Fi联盟通常会对这些标准进行认证，并使用术语如“Wi-Fi 4”（802.11n）、“Wi-Fi 5”（802.11ac）和“Wi-Fi 6”（802.11ax）来标识不同的标准版本。</p></blockquote><h3 id="蓝牙配置文件"><a href="#蓝牙配置文件" class="headerlink" title="蓝牙配置文件"></a>蓝牙配置文件</h3><p>蓝牙配置文件是一组规范，用于定义蓝牙设备之间的通信方式和规则，以确保设备可以互操作并正确执行特定任务。每个配置文件都是一种蓝牙应用的规范，定义了特定用途的设备之间的通信协议。以下是一些常见的蓝牙配置文件和它们的主要功能：</p><table><thead><tr><th>蓝牙配置文件名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>Hands-Free Profile（HFP</strong>）</td><td>用于蓝牙耳机、车载通话设备和手机之间的通信，定义了音频和电话控制的交换方式。</td></tr><tr><td><strong>Advanced Audio Distribution Profile（A2DP）</strong></td><td>允许高质量音频从蓝牙源设备传输到蓝牙接收设备，支持立体声音频和音频控制。</td></tr><tr><td><strong>Audio/Video Remote Control Profile（AVRCP）</strong></td><td>扩展了A2DP，允许蓝牙设备进行音频和视频控制，如播放、暂停、跳过和音量调节等。</td></tr><tr><td><strong>Object Push Profile（OPP）</strong></td><td>用于在蓝牙设备之间交换个人数据、照片、联系人和文件，类似于传统的文件传输协议。</td></tr><tr><td><strong>File Transfer Profile（FTP）</strong></td><td>用于文件传输，提供了更丰富的文件管理功能，包括文件夹创建、重命名和删除等。</td></tr><tr><td><strong>Human Interface Device Profile（HID）</strong></td><td>用于连接蓝牙键盘、鼠标、游戏控制器等输入设备到计算机或其他蓝牙主机，允许模拟标准输入设备。</td></tr><tr><td><strong>Heart Rate Profile（HRP）</strong></td><td>用于蓝牙心率监测设备，与手机或其他设备之间的通信，用于心率传感器和智能手表等设备。</td></tr><tr><td><strong>Health Device Profile（HDP）</strong></td><td>用于健康监测设备，与医疗设备或移动应用之间的通信，适用于血压计、血糖仪和体重秤等设备。</td></tr><tr><td><strong>Generic Attribute Profile（GATT）</strong></td><td>不是单个配置文件，而是一种通用框架，用于定义自定义服务和特征，适用于各种应用，包括智能家居、物联网和可穿戴设备。</td></tr></tbody></table><p>这些是蓝牙配置文件的一些示例，每个配置文件都定义了一组特定的规则和协议，以便不同类型的蓝牙设备能够相互通信和交换数据。根据应用需求，开发者可以选择合适的配置文件来确保蓝牙设备之间的兼容性和互操作性。</p><h3 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h3><p>星型拓扑是一种计算机网络结构，其中所有设备都直接连接到一个中央节点或中心点，通常称为”中继器”、”集线器”或”交换机”。在星型拓扑中，所有数据流量都通过中心节点进行传输和管理。这种网络结构具有以下特点：</p><ol><li><p><strong>中心控制</strong>：星型拓扑的中心节点具有控制权，它决定了数据流量的路由和管理。这种结构使得网络的配置和管理相对容易，因为所有设备都通过中心节点连接。</p></li><li><p><strong>独立通信</strong>：在星型拓扑中，设备之间的通信是独立的。这意味着如果一个设备要与另一个设备通信，数据必须经过中心节点传输，然后由中心节点重新分发给目标设备。</p></li><li><p><strong>容易维护</strong>：由于所有设备都连接到中心节点，因此添加、删除或维护设备相对容易。不会对整个网络产生太大的干扰，只需处理相关的设备即可。</p></li><li><p><strong>单点故障</strong>：星型拓扑的一个主要缺点是中心节点是单点故障。如果中心节点出现故障或中断，整个网络可能会受到影响，因为没有直接通信路径可用于设备之间的通信。</p></li><li><p><strong>性能和扩展性</strong>：星型拓扑的性能通常受到中心节点的容量和处理能力的限制。如果需要连接大量设备，中心节点可能成为瓶颈，因此可能需要考虑使用更复杂的网络拓扑结构，如树型拓扑或网状拓扑。</p></li></ol><blockquote><p>星型拓扑通常用于小型到中型规模的局域网（LAN）或家庭网络，其中设备数量相对较少，而且维护相对容易。但对于大规模网络或需要高度容错性的应用来说，可能需要考虑其他拓扑结构，以减少单点故障的影响。</p></blockquote><h3 id="扩频调制"><a href="#扩频调制" class="headerlink" title="扩频调制"></a>扩频调制</h3><p>扩频调制（Spread Spectrum Modulation）是一种无线通信技术，其主要目的是提高通信系统的抗干扰性、隐蔽性和安全性。<br>扩频调制通过在信号中引入具有较高带宽的调制信号，将原始信息信号进行扩频，从而使信号更分散，难以被未经授权的接收器检测和干扰。<br>扩频调制有两种主要类型：</p><ul><li>直接序列扩频（Direct Sequence Spread Spectrum，DSSS）</li><li>频率跳变扩频（Frequency Hopping Spread Spectrum，FHSS）</li></ul><table><thead><tr><th>扩频技术</th><th>直接序列扩频（DSSS）</th><th>频率跳变扩频（FHSS）</th></tr></thead><tbody><tr><td><strong>工作原理</strong></td><td>使用伪随机序列（扩频码）将原始数据信号扩展，接收端通过知道正确的扩频码进行解扩，还原原始信号。</td><td>频繁改变载波频率，通信信号在不同频率上传输，形成频率序列。接收器知道频率跳变规律，以正确接收数据。</td></tr><tr><td><strong>抗干扰性</strong></td><td>强，通过选择不同的伪随机序列提高抗干扰性。</td><td>强，对窄带干扰具有很强的抵抗力，因为干扰信号只在狭窄频率带宽内工作。</td></tr><tr><td><strong>应用</strong></td><td>无线局域网（Wi-Fi）、蓝牙等通信标准，以增加通信的隐蔽性和安全性。</td><td>军事通信和一些工业应用中，因为它具有良好的隐蔽性和抗干扰性。</td></tr><tr><td><strong>特点</strong></td><td>扩频增益大，抗干扰能力强，需要较高的同步精度和较大的发射功率。</td><td>抗多径衰落能力强，不需要较大的发射功率，扩频增益小，抗干扰能力弱。</td></tr></tbody></table><blockquote><p>扩频调制技术在实际应用中有助于提高通信系统的可靠性、抗干扰性和安全性，尤其是在嘈杂或恶劣的通信环境下。它也常用于无线局域网、蓝牙、军事通信和物联网等领域。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习</title>
      <link href="/2023/09/28/stm32-study-note/"/>
      <url>/2023/09/28/stm32-study-note/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32入门学习"><a href="#STM32入门学习" class="headerlink" title="STM32入门学习"></a><a href="https://www.bilibili.com/video/BV1th411z7sn?p=1&amp;vd_source=0a3e5759a1072cc76091a2b54f770f13" title="江科大自化协教程">STM32入门学习</a></h1><p><em><strong>STM32学习基于STM32F103C8T6芯片</strong></em></p><h2 id="STM32开发环境搭建"><a href="#STM32开发环境搭建" class="headerlink" title="STM32开发环境搭建"></a>STM32开发环境搭建</h2><ul><li>安装keil5 MDK软件</li><li>安装STM32器件支持包</li><li>安装STlink驱动</li><li>安装USB转串口CH340驱动</li><li>在vscode中配置STM32开发环境<ul><li>安装C/C++插件</li><li>安装keil assistant插件</li><li>在keil assistant插件中添加keil可执行文件UV4.exe的绝对路径</li><li>在vscode中打开keil的工程文件</li></ul></li></ul><h2 id="认识STM32最小系统的基本结构"><a href="#认识STM32最小系统的基本结构" class="headerlink" title="认识STM32最小系统的基本结构"></a>认识STM32最小系统的基本结构</h2><ul><li><strong>STM32F103C8T6</strong><br><img src="/image%5CSTM32F1.jpg" alt="STM32F1"><ul><li>系列：主流系列STM32F1</li><li>内核：ARM Cortex-M3</li><li>主频：72MHz</li><li>RAM：20K（SRAM）</li><li>ROM：64K（Flash）</li><li>供电：2.0~3.6V（标准3.3V）</li><li>封装：LQFP48</li></ul></li><li>最小系统板上的资源<br><img src="/image%5CSTM32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E8%B5%84%E6%BA%90.jpg" alt="STM32"></li><li>STM32F01系列系统结构<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a><br><img src="/image/STM32%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg" alt="系统结构"><ul><li>驱动单元：<br>Cortex^TM^-M3内核DCode总线(D-bus),和系统总线(S-bus),控制总线（ICode）<br>通用DMA1和通用DMA2</li><li>被动单元<br>内部SRAM<br>内部闪存存储器<br>FSMC<br>AHB到APB的桥(AHB2APBx),它连接所有的APB设备</li><li>ICode总线<br>该总线将CortexTM-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成。</li><li>DCode总线<br>该总线将Cortex TM.-M3内核的DCode总线与闪存存储器的数据接口相连接（常量加载和调试访问）。</li><li>系统总线<br>此总线连接Cortex TM-M3内核的系统总线（外设总线）到总线矩阵，总线矩阵协调着内核和DMA间的访问。</li><li>DMA总线<br>此总线将DMA的AHB主控接口与总线矩阵相联，总线矩阵协调着CPU的DCode和DMA到SRAM、闪存和外设的访问。</li><li>总线矩阵<br>总线矩阵协调内核系统总线和DMA主控总线之间的访问仲裁，仲裁利用轮换算法。<br>AHB外设通过总线矩阵与系统总线相连，允许DMA访问。</li><li>AHB/APB桥(APB)<br>两个AHB/APB桥在AHB和2个APB总线间提供同步连接。APB1操作速度限于36MHz，APB2操作于全速(最高72MHz)。</li></ul></li><li>引脚定义<a href="%5BSTM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^2</a><br><img src="/image%5C%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png" alt="引脚定义"></li><li>启动配置<br><img src="/image/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" alt="启动配置"></li><li>最小系统电路<br><img src="/image/%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E8%B7%AF.png" alt="最小系统电路"></li></ul><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><ol><li><p>建立工程文件夹，Keil中新建工程，选择型号</p></li><li><p>在工程文件夹中添加必要的固件库文件</p><ol><li>添加启动文件（start）<br> 根据所选芯片添加对应的启动文件、系统文件、内核文件<br> <img src="/image/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.jpg" alt="启动文件"></li><li>在工程中创建Start文件夹，并将工程文件夹中的文件添加到对应的工程分组里</li><li>工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹</li><li>编译，看是否操作正确</li><li>在工程文件夹中创建User文件夹，工程中创建同名文件夹，并新建main.c文件</li><li>在main.c中写个死循环，编译，看是否能成功</li><li>在工程文件夹中创建Library文件夹，并将库函数文件放入</li><li>将*_conf.h, *_it.h, *_it.c放入User文件夹，并在工程中也同样添加</li><li>工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER</li><li>工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run</li></ol></li><li><p>点灯</p><ol><li>通过控制寄存器来点灯</li></ol><ul><li>在官方文档中<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a>查找GPIOC所在的APB2外设寄存器RCC_APB2ENR配置信息<br>为LEDpc13端口设置时钟：<code>RCC-&gt;APB2ENR = 0x00000010;</code></li><li>查找端口配置高寄存器GPIOC_ARH的端口配置信息<br>为LEDpc13端口配置端口模式：<code>GPIOC-&gt;CRH = 0x00300000;</code></li><li>查找端口输出数据寄存器GPIOC_ODR的端口配置信息<br>为为LEDpc13端口配置输出：<code>GPIOC-&gt;ODR = 0x00000000;</code></li><li>编译，下载，实现点灯<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">=</span> <span class="token number">0x00000010</span><span class="token punctuation">;</span>  GPIOC<span class="token operator">-&gt;</span>CRH <span class="token operator">=</span> <span class="token number">0x00300000</span><span class="token punctuation">;</span>  GPIOC<span class="token operator">-&gt;</span>ODR <span class="token operator">=</span> <span class="token number">0x00002000</span><span class="token punctuation">;</span><span class="token comment">//GPIOC-&gt;ODR = 0x00000000;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>利用库函数来点灯<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOC<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_13<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> GPIO_Pin_13<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//GPIO_ResetBits(GPIOC, GPIO_Pin_13);</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol><h2 id="GPIO（通用输入输出口）"><a href="#GPIO（通用输入输出口）" class="headerlink" title="GPIO（通用输入输出口）"></a>GPIO（通用输入输出口）</h2><ul><li>可配置为8种输入输出模式<br><img src="/image/GPIO%E6%A8%A1%E5%BC%8F.jpg" alt="GPIO模式"></li><li>引脚电平：0V~3.3V，部分引脚可容忍5V</li><li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</li><li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</li></ul><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="/image/GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="GPIO基本结构"></p><ul><li>寄存器每一位对应一个引脚</li><li>输出寄存器为1，引脚输出为高电平；为0，则为低电平</li><li>引脚输入为高电平，输入寄存器为1；为低电平，则为0</li><li>驱动器负责增大驱动能力</li></ul><h3 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h3><p><img src="/image/GPIO%E4%BD%8D%E7%BB%93%E6%9E%84.png" alt="GPIO位结构"><br>GPIO位结构可分为两个部分：上面的输入部分，下面的输出部分。</p><ul><li>保护二极管：对输入电压限幅<br>若输入电压大于VDD，上方的二极管导通，则电流直接流入VDD，避免电压过高损坏内部电路。<br>若输入电压小于VSS，下方的二极管导通则电流从VSS流出到IO引脚，保护内部电路。</li><li>输入部分<ul><li>上拉电阻与下拉电阻<br>在IO引脚无输入时，输入处于浮空状态，容易受到外界干扰。<br>上拉电阻接通时，可为输入提供高电平，即高电平输入模式。<br>下拉电阻接通时，可为输入提供低电平，即低电平输入模式。</li><li>TTL肖特基触发器（施密特触发器）<br>为输入电压整形：若输入大于阈值，则会直接变为高电平；若输入电压小于阈值，则会直接变为低电平。<br>整形后的电平传入输入寄存器，即可读取外部输入电平信号。</li><li>模拟输入：连接至ADC</li><li>复用功能输入：连接其他需要读取端口电平的外设上</li></ul></li><li>输出部分<ul><li>位设置/清除寄存器：能够只操作输出寄存器的某一位而不影响其它位的状态</li><li>推挽输出：控制P-MOS和N-MOS的通断输出高低电平，且有较强的驱动力<br>（单片机一般都是高电平驱动能力弱，低电平驱动能力强）</li><li>开漏输出：只能输出低电平，可作为通信协议的驱动方式</li><li>关闭：转为输入模式</li></ul></li></ul><h3 id="GPIO口输出控制"><a href="#GPIO口输出控制" class="headerlink" title="GPIO口输出控制"></a>GPIO口输出控制</h3><h4 id="LED闪烁"><a href="#LED闪烁" class="headerlink" title="LED闪烁"></a>LED闪烁</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//GPIO_ResetBits(GPIOA, GPIO_Pin_0);</span><span class="token comment">//GPIO_SetBits(GPIOA, GPIO_Pin_0);</span><span class="token comment">//GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);</span><span class="token comment">//GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> Bit_SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_0<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>了解RCC_APB2PeriphClockCmd、GPIO_Init、GPIO_ResetBits、GPIO_SetBits、GPIO_WriteBit、GPIO_WriteBit库函数的使用。</p></blockquote><h4 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_All<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0001</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0004</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0008</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0010</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0020</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0040</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0x0080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>了解GPIO_Write库函数的使用</p></blockquote><h3 id="GPIO输入控制"><a href="#GPIO输入控制" class="headerlink" title="GPIO输入控制"></a>GPIO输入控制</h3><h4 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h4><ul><li>学习模块化编程</li><li>编写功能功能模块*.c和*.h代码，来实现具体的功能</li><li>在主程序头文件声明、引用功能模块，并在程序中调用，简化主程序代码。</li></ul><h4 id="光敏电阻控制蜂鸣器"><a href="#光敏电阻控制蜂鸣器" class="headerlink" title="光敏电阻控制蜂鸣器"></a>光敏电阻控制蜂鸣器</h4><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>串口调试<br>通过串口通信，将调试信息发送至电脑，在电脑上用调试助手显示调试信息。</li><li>显示屏调试<br>用显示屏直接连接至单片机，调试信息直接显示在显示屏上。</li><li>keil调试模式<br>借助Keil软件的调试模式，可使用单步运行、设置断点、查看寄存器及变量等功能。</li></ul><h3 id="OLED显示屏"><a href="#OLED显示屏" class="headerlink" title="OLED显示屏"></a>OLED显示屏</h3><p>@import “image/1680176826998.jpg” {width=”400px” height=”300px” title=”OLED显示屏” alt=”我的 alt”}</p><h2 id="中断系统-1"><a href="#中断系统-1" class="headerlink" title="中断系统^1"></a>中断系统<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a></h2><ul><li>中断<br>在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。</li><li>中断优先级<br>当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。</li><li>中断嵌套<br>当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。</li></ul><h3 id="中断源与中断管理"><a href="#中断源与中断管理" class="headerlink" title="中断源与中断管理"></a>中断源与中断管理</h3><ul><li>中断源<ul><li>EXIT外部中断</li><li>TIM定时器</li><li>ADC模数转换器</li><li>USTART串口</li><li>SPI通信</li><li>I2C通信</li><li>RTC实时时钟</li></ul></li><li>NVIC管理<a href="%5BSTM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^2</a><br>NVIC中断、分配中断优先级（16个等级）、设置抢断优先级和响应优先级。<br>NVIC的中断优先级由4位优先级寄存器决定，可分为高n位的抢占优先级和低4-n的响应优先级。<table><thead><tr><th align="center">分组方式</th><th align="center">抢占优先级</th><th align="center">响应优先级</th></tr></thead><tbody><tr><td align="center">分组0</td><td align="center">0位，取值为0</td><td align="center">4位，取值为0~15</td></tr><tr><td align="center">分组1</td><td align="center">1位，取值为0-1</td><td align="center">3位，取值为0~7</td></tr><tr><td align="center">分组2</td><td align="center">2位，取值为0-3</td><td align="center">2位，取值为0-3</td></tr><tr><td align="center">分组3</td><td align="center">3位，取值为0~7</td><td align="center">1位，取值为0-1</td></tr><tr><td align="center">分组4</td><td align="center">4位，取值为0~15</td><td align="center">0位，取值为0</td></tr></tbody></table></li></ul><h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请。<br>经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序<br>支持的触发方式：上升沿/下降沿/双边沿/软件触发<br>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断<br>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒<br>触发响应方式：中断响应/事件响应</p><ul><li>EXIT基本结构<br>@import “image/EXIT基本结构.jpg” {width=60%}</li><li><strong>AFIO复用IO口</strong><br>AFIO主要用于引脚复用功能的选择和重定义.<br>在STM32中，AFIO主要完成两个任务：==复用功能引脚重映射、中断引脚选择==.</li></ul><h4 id="对射式红外计次"><a href="#对射式红外计次" class="headerlink" title="对射式红外计次"></a>对射式红外计次</h4><ol><li>配置RCC：开启GPIO和AFIO的时钟（EXTI,NVIC不需要配置时钟）</li><li>配置GPIO</li><li>配置AFIO</li><li>配置EXIT</li><li>配置NVIC<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token class-name">uint16_t</span> countsensor_num<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CountSensor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* 配置RCC：开启GPIO和AFIO的时钟（EXTI,NVIC不需要配置时钟）*/</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStruture<span class="token punctuation">;</span>    GPIO_InitStruture<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStruture<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_14<span class="token punctuation">;</span>    GPIO_InitStruture<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruture<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOB<span class="token punctuation">,</span> GPIO_PinSource14<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//配置AFIO</span>    <span class="token comment">/* 配置EXIT */</span>    EXTI_InitTypeDef EXTI_InitStructure<span class="token punctuation">;</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Line <span class="token operator">=</span> EXTI_Line14<span class="token punctuation">;</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_LineCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Mode <span class="token operator">=</span> EXTI_Mode_Interrupt<span class="token punctuation">;</span>    EXTI_InitStructure<span class="token punctuation">.</span>EXTI_Trigger <span class="token operator">=</span> EXTI_Trigger_Falling<span class="token punctuation">;</span>    <span class="token function">EXTI_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>EXTI_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 配置NVIC */</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    NVIC_InitTypeDef NVIC_InitStruture<span class="token punctuation">;</span>    NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI15_10_IRQn<span class="token punctuation">;</span>    NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>    NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStruture<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取计数值 */</span><span class="token class-name">uint16_t</span> <span class="token function">CountSensor_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> countsensor_num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 设置进入中断执行的计数条件 */</span><span class="token keyword">void</span> <span class="token function">EXTI15_10_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        countsensor_num <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span>EXTI_Line14<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="旋转编码计次"><a href="#旋转编码计次" class="headerlink" title="旋转编码计次"></a>旋转编码计次</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">NVIC_InitTypeDef NVIC_InitStruture<span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI0_IRQn<span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStruture<span class="token punctuation">)</span><span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> EXTI1_IRQn<span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>NVIC_InitStruture<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStruture<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>每个端口的nvic初始化都需要用<code>NVIC_Init(&amp;NVIC_InitStruture);</code></p></blockquote><h2 id="TIM定时中断"><a href="#TIM定时中断" class="headerlink" title="TIM定时中断"></a>TIM定时中断</h2><ul><li>TIM（Timer）定时器<br>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</li><li>定时器类型<table><thead><tr><th align="center">类型</th><th align="center">编号</th><th align="center">总线</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">高级定时器</td><td align="center">TIM1、TIM8</td><td align="center">APB2</td><td align="left">拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td></tr><tr><td align="center">通用定时器</td><td align="center">TIM2、TIM3、TIM4、TIM5</td><td align="center">APB1</td><td align="left">拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td></tr><tr><td align="center">基本定时器</td><td align="center">TIM6、TIM7</td><td align="center">APB1</td><td align="left">拥有定时中断、主模式触发DAC的功能</td></tr></tbody></table></li><li>基本计时器<br><img src="/image/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E6%97%B6%E5%99%A8.png"><ul><li>CNT计数器向上计数（最大值：2^16^-1）</li><li>只能选择内部时钟（72Hz）</li><li>自动重装寄存器存储计数的目标值</li><li>PSC预分频器可对时钟信号分频</li><li>UI更新中断：计数器的值与自动重装寄存器的值相同时触发，可通向NVIC</li><li>U更新事件：不会触发中断，但会触发内部器件的工作</li><li>主模式出发DAC：更新事件通过主模式映射到TAGO，然后通过TAGO触发DAC(硬件自动化)</li></ul></li><li>通用计时器<br><img src="/image/%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8.png"><ul><li>支持向上计数、向下计数、中央对齐计数</li><li>可以选择内部时钟和外部时钟<br>外部时钟模式1：ETRF<br>外部时钟模式2：ETR引脚、其它定时器、CH1引脚的边缘触发、CH1引脚、CH2引脚</li><li>输出比较电路：可用于输出PWM波形</li><li>输出捕获电路：</li></ul></li><li>高级定时器<br><img src="/image/%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8.png"><ul><li>可实现每个几个更新周期更新一次，相当于对更新信号做了一次分频</li><li>互补PWM输出</li><li>死区生成寄存器</li><li>刹车输入</li></ul></li><li>定时中断基本结构<br><img src="/image/%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84.png"></li></ul><h3 id="定时器定时中断"><a href="#定时器定时中断" class="headerlink" title="定时器定时中断"></a>定时器定时中断</h3><ol><li>打开RCC时钟</li><li>时钟源选择<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TIM_ITRxExternalClockConfig</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_InputTriggerSource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TIM_TIxExternalClockConfig</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_TIxExternalCLKSource<span class="token punctuation">,</span>                                <span class="token class-name">uint16_t</span> TIM_ICPolarity<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> ICFilter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TIM_ETRClockMode1Config</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_ExtTRGPrescaler<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_ExtTRGPolarity<span class="token punctuation">,</span>                            <span class="token class-name">uint16_t</span> ExtTRGFilter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TIM_ETRClockMode2Config</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_ExtTRGPrescaler<span class="token punctuation">,</span>                             <span class="token class-name">uint16_t</span> TIM_ExtTRGPolarity<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> ExtTRGFilter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">TIM_ETRConfig</span><span class="token punctuation">(</span>TIM_TypeDef<span class="token operator">*</span> TIMx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_ExtTRGPrescaler<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> TIM_ExtTRGPolarity<span class="token punctuation">,</span>                  <span class="token class-name">uint16_t</span> ExtTRGFilter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置时基单元<br><code>void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</code><blockquote><p>初始化时基单元后会立刻生成更新事件来重新装载预分频器和重复寄存器的值，更新中断会置更新标志位，即初始化后里刻进入中断</p></blockquote></li><li>配置输出中断控制，允许更新中断输出到 NVIC<br>  <code>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</code>   </li><li>配置nvic，打开定时器中断通道，设置优先级</li><li>运行控制</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token comment">// extern uint16_t NUM;</span><span class="token keyword">void</span> <span class="token function">Timer_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">10000</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">7200</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_ClearFlag</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_FLAG_Update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_ITConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    NVIC_InitTypeDef NVIC_InitSructure<span class="token punctuation">;</span>    NVIC_InitSructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> TIM2_IRQn<span class="token punctuation">;</span>    NVIC_InitSructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>    NVIC_InitSructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    NVIC_InitSructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitSructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*void TIM2_IRQHandler(void){    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)    {        NUM ++;        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);    }}*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定时器外部中断"><a href="#定时器外部中断" class="headerlink" title="定时器外部中断"></a>定时器外部中断</h3><p>基本步骤与定时中断相同，但需要配置GPIO引脚的状态</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TIM_ETRClockMode2Config</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_ExtTRGPSC_OFF<span class="token punctuation">,</span> TIM_ExtTRGPolarity_NonInverted<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TIM输出比较"><a href="#TIM输出比较" class="headerlink" title="TIM输出比较"></a>TIM输出比较</h3><p>输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形<br>每个高级定时器和通用定时器都拥有4个输出比较通道<br>高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p><ul><li>PWM（Pulse Width Modulation）脉冲宽度调制<br>在具有==惯性的系统==中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量</li><li>PWM参数<ul><li>频率：1/T<del>S</del></li><li>占空比：T<del>ON</del>/T<del>S</del></li><li>分辨率：占空比变化步距</li></ul></li><li>输出比较通路（通用）<br><img src="/image/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%94%B5%E8%B7%AF%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89png.png"></li><li>输出比较通路（高级）<br><img src="/image/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%94%B5%E8%B7%AF%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89.png"></li><li>输出比较模式<table><thead><tr><th align="center">模式</th><th align="center">描述</th><th align="center"></th></tr></thead><tbody><tr><td align="center">冻结</td><td align="center">CNT=CCR时，REF保持为原状态</td><td align="center"></td></tr><tr><td align="center">匹配时置有效电平</td><td align="center">CNT=CCR时，REF置有效电平</td><td align="center">高级定时器</td></tr><tr><td align="center">匹配时置无效电平</td><td align="center">CNT=CCR时，REF置无效电平</td><td align="center">^</td></tr><tr><td align="center">匹配时电平反转</td><td align="center">CNT=CCR时，REF电平翻转</td><td align="center">^</td></tr><tr><td align="center">强制为有效电平</td><td align="center">CNT与CCR无效，REF强制为有效电平</td><td align="center"></td></tr><tr><td align="center">强制为无效电平</td><td align="center">CNT与CCR无效，REF强制为无效电平</td><td align="center"></td></tr><tr><td align="center">PWM模式1</td><td align="center">向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平</td><td align="center"></td></tr><tr><td align="center">^</td><td align="center">向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平</td><td align="center"></td></tr><tr><td align="center">PWM模式2</td><td align="center">向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平</td><td align="center"></td></tr><tr><td align="center">^</td><td align="center">向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平</td><td align="center"></td></tr></tbody></table></li><li>参数计算<ul><li>PWM频率：Freq = CK_PSC / (PSC + 1) / (ARR + 1)</li><li>PWM占空比：Duty = CCR / (ARR + 1)</li><li>PWM分辨率：Reso = 1 / (ARR + 1)</li></ul></li></ul><h4 id="PWM驱动呼吸灯"><a href="#PWM驱动呼吸灯" class="headerlink" title="PWM驱动呼吸灯"></a>PWM驱动呼吸灯</h4><ol><li>开启RCC时钟</li><li>配置时基单元</li><li>配置输出比较单元</li><li>配置GPIO</li><li>运行控制</li><li>改变运行时占空比<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token keyword">void</span> <span class="token function">PWM_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// ARR</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">720</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// PSC</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_OCInitTypeDef TIM_OCInitStructure<span class="token punctuation">;</span>    <span class="token function">TIM_OCStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结构体内的变量没有都用到，但为了防止不赋值导致的结构体变量取值不确定或无法使用，先给结构体所有变量赋初始值</span>    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCMode <span class="token operator">=</span> TIM_OCMode_PWM1<span class="token punctuation">;</span>    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCPolarity <span class="token operator">=</span> TIM_OCPolarity_High<span class="token punctuation">;</span>    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OutputState <span class="token operator">=</span> TIM_OutputState_Enable<span class="token punctuation">;</span>    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_Pulse <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// CCR</span>    <span class="token function">TIM_OC1Init</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 通过设置CCR来调整占空比，从而控制LED亮度 */</span><span class="token keyword">void</span> <span class="token function">PWM_SetCompare1</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> Compare<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TIM_SetCompare1</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> Compare<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>通过设置CCR来调整占空比，从而控制LED亮度</li><li>端口重映射<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2Periphclockcmnd</span> <span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打开AFIO时钟</span><span class="token function">GPIO_PinRemapConfig</span><span class="token punctuation">(</span>GPIO_PartialRemap1_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 重映射引脚</span><span class="token function">GPIO_PinRemapConfig</span><span class="token punctuation">(</span>GPIO_Remap_SWJ_JTAGDisable<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解除端口调试</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="PWM驱动舵机"><a href="#PWM驱动舵机" class="headerlink" title="PWM驱动舵机"></a>PWM驱动舵机</h4><p>舵机的周期为20ms，频率即为50Hz，高电平取值范围0.5ms ~ 2.5ms。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">20000</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// ARR</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">72</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// PSC</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>控制舵机角度<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Servo_SetAngle</span><span class="token punctuation">(</span><span class="token keyword">float</span> Angle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">PWM_SetCompare2</span><span class="token punctuation">(</span>Angle <span class="token operator">*</span> <span class="token number">2000</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token operator">+</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="PWM驱动直流电机"><a href="#PWM驱动直流电机" class="headerlink" title="PWM驱动直流电机"></a>PWM驱动直流电机</h4><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转<br>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作<br>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"PWM.h"</span></span><span class="token keyword">void</span> <span class="token function">Motor_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_4 <span class="token operator">|</span> GPIO_Pin_5<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PWM_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Motor_SetValue</span><span class="token punctuation">(</span><span class="token class-name">int8_t</span> Speed<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Speed <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/* 控制电机旋转方向 */</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 控制电机速度 */</span>        <span class="token function">PWM_SetCompare3</span><span class="token punctuation">(</span>Speed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PWM_SetCompare3</span><span class="token punctuation">(</span><span class="token operator">-</span>Speed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TIM-IC（Input-Capture）输入捕获"><a href="#TIM-IC（Input-Capture）输入捕获" class="headerlink" title="TIM IC（Input Capture）输入捕获"></a>TIM IC（Input Capture）输入捕获</h3><p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数<br>每个高级定时器和通用定时器都拥有4个输入捕获通道<br>可配置为PWMI模式，同时测量频率和占空比<br>可配合主从触发模式，实现硬件全自动测量</p><ul><li>频率测量方法<ul><li>测频法：在闸门时间T内，对上升沿计次，得到N，则频率$𝑓_𝑥=𝑁 / 𝑇$</li><li>测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率$𝑓_𝑥=𝑓_𝑐  / 𝑁$<br>标准频率 = 预分频器频率，CNT计次即为N。</li><li>中界频率：测频法与测周法误差相等的频率点$𝑓_𝑚=\sqrt{𝑓_𝑐  / 𝑇}$<blockquote><p>高频使用测频法，低频使用测周法</p></blockquote></li></ul></li><li>捕获输入通道<br>@import “image/捕获输入通道.png”{width=60%}</li><li>主从触发模式<br>@import “image/主从触发模式.jpg”{width=60%}</li><li>输入捕获基本结构<br><img src="/image/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li><li>PWMI基本结构<br><img src="/image/PWMI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li></ul><h4 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h4><ol><li>打开RCC时钟</li><li>GPIO初始化，配置成输入模式</li><li>配置时基单元，让CNT计数器在内部时钟下自增运行</li><li>配置输入捕获单元（滤波器、极性、直连通道或交叉通道、分频器）</li><li>选择触发源（TI1FP1</li><li>触发后的操作</li><li>开启定时器<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token keyword">void</span> <span class="token function">IC_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">65536</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// ARR</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">72</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// PSC</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPolarity <span class="token operator">=</span> TIM_ICPolarity_Rising<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPrescaler <span class="token operator">=</span> TIM_ICPSC_DIV1<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICSelection <span class="token operator">=</span> TIM_ICSelection_DirectTI<span class="token punctuation">;</span>    <span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_SelectInputTrigger</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_TS_TI1FP1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_SelectSlaveMode</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_SlaveMode_Reset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">uint32_t</span> <span class="token function">IC_GetFreq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1000000</span> <span class="token operator">/</span> <span class="token function">TIM_GetCapture1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="TIMI模式测量频率占空比"><a href="#TIMI模式测量频率占空比" class="headerlink" title="TIMI模式测量频率占空比"></a>TIMI模式测量频率占空比</h4><ol><li>分别在上升沿和下降沿捕获</li><li>配置PWMI模式</li><li>测量频率和占空比<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token keyword">void</span> <span class="token function">IC_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_InternalClockConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">65536</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// ARR</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">72</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// PSC</span>    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPolarity <span class="token operator">=</span> TIM_ICPolarity_Rising<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICPrescaler <span class="token operator">=</span> TIM_ICPSC_DIV1<span class="token punctuation">;</span>    TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICSelection <span class="token operator">=</span> TIM_ICSelection_DirectTI<span class="token punctuation">;</span>    <span class="token function">TIM_PWMIConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_SelectInputTrigger</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_TS_TI1FP1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_SelectSlaveMode</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_SlaveMode_Reset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">uint32_t</span> <span class="token function">IC_GetFreq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1000000</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">TIM_GetCapture1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">uint32_t</span> <span class="token function">IC_GetDuty</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">TIM_GetCapture2</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">TIM_GetCapture1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="TIM编码器接口"><a href="#TIM编码器接口" class="headerlink" title="TIM编码器接口"></a>TIM编码器接口</h3><p>编码器接口可接收增量（正交）编码器信号，根据编码器的旋转产生正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向、旋转速度<br>相当于带有方向控制的外部时钟，同时控制着CNT的计数时钟和计数方向<br>每个高级定时器和通用定时器都有一个编码器接口<br>两个输入引脚借用输入捕获的通道1和通道2</p><ul><li>编码器基本结构<br><img src="/image/%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li><li>编码器工作模式<br><img src="/image/%E7%BC%96%E7%A0%81%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png"></li></ul><h4 id="TIM编码器接口测速"><a href="#TIM编码器接口测速" class="headerlink" title="TIM编码器接口测速"></a>TIM编码器接口测速</h4><ol><li>开启RCC时钟 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>配置GPIO<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6 <span class="token operator">|</span> GPIO_Pin_7<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置时基单元<pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">65536</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// ARR</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// PSC</span>TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置输入捕获单元<pre class="line-numbers language-c" data-language="c"><code class="language-c">TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span><span class="token function">TIM_ICStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span><span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_2<span class="token punctuation">;</span>TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span><span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置编码器接口模式<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">TIM_EncoderInterfaceConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_EncoderMode_TI12<span class="token punctuation">,</span> TIM_ICPolarity_Falling<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>启动定时器<br><code>TIM_Cmd(TIM3,ENABLE);</code></li></ol><ul><li>测速<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int16_t</span> <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">int16_t</span> Temp<span class="token punctuation">;</span>    Temp <span class="token operator">=</span> <span class="token function">TIM_GetCounter</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TIM_SetCounter</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">TIM2_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TIM_GetITStatus</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Speed <span class="token operator">=</span> <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TIM_ClearITPendingBit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="ADC-Analog-Digital-Cocerter-模拟-数字转换器"><a href="#ADC-Analog-Digital-Cocerter-模拟-数字转换器" class="headerlink" title="ADC(Analog Digital Cocerter)模拟-数字转换器"></a>ADC(Analog Digital Cocerter)模拟-数字转换器</h2><p>ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁<br>STM32的ADC为12位逼近型ADC，转换时间需要1$\mu s$，转换频率1MHz<br>输入电压范围：0 ~ 3.3V，转换结果：0 ~ 4095<br>18个输入通道，可测量16个外部和2个内部信号源（内部温度传感器、内部参考电压1.2V）<br>==规则组和注入组两个转换单元==<br>模拟看门狗自动监测输入电压范围<br>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><ul><li>逐次逼近型ADC<br>@import “image/逐次逼近型ADC.jpg”{width=60%}</li><li>ADC框图<br><img src="/image/ADC%E6%A1%86%E5%9B%BE.png"></li><li>转换模式<ul><li>单次转换，非扫描模式</li><li>连续转换，非扫描模式</li><li>单次转换，扫描模式</li><li>连续转换，扫描模式</li></ul></li><li>数据对齐方式<ul><li>右对齐</li><li>左对齐</li></ul></li><li>校准<br>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。<br>校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差<br>ADC每次上电后需执行一次校准<br>启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</li></ul><h3 id="AD单通道"><a href="#AD单通道" class="headerlink" title="AD单通道"></a>AD单通道</h3><ol><li>开启RCC时钟<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_ADCCLKConfig</span><span class="token punctuation">(</span>RCC_PCLK2_Div6<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置GPIO输入模式<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AIN<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置转换单元<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_Channel_0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ADC_SampleTime_55Cycles5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>配置ADC转换器<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADC_InitTypeDef ADC_InitStructure<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ContinuousConvMode <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_DataAlign <span class="token operator">=</span> ADC_DataAlign_Right<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ExternalTrigConv <span class="token operator">=</span> ADC_ExternalTrigConv_None<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_Mode <span class="token operator">=</span> ADC_Mode_Independent<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_NbrOfChannel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ScanConvMode <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span><span class="token function">ADC_Init</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ADC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>开启ADC<br><code>ADC_Cmd(ADC1, ENABLE);</code></li><li>校准<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ADC_ResetCalibration</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ADC_GetResetCalibrationStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_StartCalibration</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ADC_GetCalibrationStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>得到转换值<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint16_t</span> <span class="token function">AD_GetValue</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">ADC_SoftwareStartConvCmd</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 软件触发ADC</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">ADC_GetFlagStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_FLAG_EOC<span class="token punctuation">)</span> <span class="token operator">==</span>RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">ADC_GetConversionValue</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h3><h2 id="DMA-Direct-Memory-Access-直接存储器访问"><a href="#DMA-Direct-Memory-Access-直接存储器访问" class="headerlink" title="DMA(Direct Memory Access)直接存储器访问"></a>DMA(Direct Memory Access)直接存储器访问</h2><p>DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源<br>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>每个通道都支持软件触发和特定的硬件触发<br>STM32F103C8T6 DMA资源：DMA1（7个通道）</p><ul><li>存储器映像<table><thead><tr><th align="center">类型</th><th align="center">起始地址</th><th align="center">存储器</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">ROM</td><td align="center">0x0800 0000</td><td align="center">程序存储器Flash</td><td align="center">存储C语言编译后的程序代码</td></tr><tr><td align="center">^</td><td align="center">0x1FFF F000</td><td align="center">系统存储器</td><td align="center">存储BootLoader，用于串口下载</td></tr><tr><td align="center">^</td><td align="center">0x1FFF F800</td><td align="center">选项字节</td><td align="center">存储独立于程序代码的配置参数</td></tr><tr><td align="center">RAM</td><td align="center">0x2000 0000</td><td align="center">运行内存SRANM</td><td align="center">存储程序运行时的临时变量</td></tr><tr><td align="center">^</td><td align="center">0x4000 0000</td><td align="center">外设寄存器</td><td align="center">存储各个外设的配置参数</td></tr><tr><td align="center">^</td><td align="center">0xE000 0000</td><td align="center">内核外设寄存器</td><td align="center">存储内核各个外设的配置参数</td></tr></tbody></table></li><li>DAM基本结构<br><img src="/image/DMA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li><li>触发源<ul><li>硬件触发：外设寄存器和存储器之间的数据转运</li><li>软件触发：存储器之间的数据转运（不可设置自动重装）</li></ul></li><li>传输计数器：传输计数器大于0时才转运数据（可设置自动重装来连续触发）</li><li>DMA开关控制</li><li>DMA请求<br><img src="/image/DMA%E8%AF%B7%E6%B1%82.png"></li><li>数据宽度与对齐<ul><li>若数据宽度一样：正常转运</li><li>小数据到大数据：高位补0</li><li>大数据到小数据：高位舍弃</li></ul></li></ul><h3 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运 + DMA"></a>数据转运 + DMA</h3><ol><li>开启RCC的DMA时钟<br><code>RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</code><blockquote><p>DMA外设在AHB上</p></blockquote></li><li>初始化DAM的参数<pre class="line-numbers language-c" data-language="c"><code class="language-c">DMA_InitTypeDef DMA_InitStructure<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_BufferSize <span class="token operator">=</span> Size<span class="token punctuation">;</span>  <span class="token comment">// 传输计数器</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_DIR <span class="token operator">=</span> DMA_DIR_PeripheralSRC<span class="token punctuation">;</span>  <span class="token comment">// 传输方向</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_M2M <span class="token operator">=</span> DMA_M2M_Enable<span class="token punctuation">;</span>   <span class="token comment">// 触发源选择</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryBaseAddr <span class="token operator">=</span> AddrB<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryDataSize <span class="token operator">=</span> DMA_MemoryDataSize_Byte<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryInc <span class="token operator">=</span> DMA_MemoryInc_Enable<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_Mode <span class="token operator">=</span> DMA_Mode_Normal<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBaseAddr <span class="token operator">=</span> AddrA<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralDataSize <span class="token operator">=</span> DMA_PeripheralDataSize_Byte<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralInc <span class="token operator">=</span> DMA_PeripheralInc_Enable<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_Priority <span class="token operator">=</span> DMA_Priority_Medium<span class="token punctuation">;</span><span class="token function">DMA_Init</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DMA_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>开关控制<br><code>DMA_Cmd(DMA1_Channel1, DISABLE);</code></li></ol><ul><li>数据转运<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MyDMA_Transfer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_SetCurrDataCounter</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> MyDMA_Size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 只能在DMA关闭状态下 才能设置传输计数器</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">DMA_GetFlagStatus</span><span class="token punctuation">(</span>DMA1_FLAG_TC1<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待转换完成</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span>DMA1_FLAG_TC1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 需要手动清除标志位</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式 + DMA"></a>ADC扫描模式 + DMA</h3><ol><li>开启RCC时钟<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_AHBPeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHBPeriph_DMA1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>配置ADC时钟<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_ADCCLKConfig</span><span class="token punctuation">(</span>RCC_PCLK2_Div6<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>配置GPIO<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AIN<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0 <span class="token operator">|</span> GPIO_Pin_2 <span class="token operator">|</span> GPIO_Pin_3 <span class="token operator">|</span> GPIO_Pin_4<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置转换单元<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_Channel_0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ADC_SampleTime_55Cycles5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_Channel_2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> ADC_SampleTime_55Cycles5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_Channel_3<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> ADC_SampleTime_55Cycles5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_Channel_4<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> ADC_SampleTime_55Cycles5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置ADC转换器<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADC_InitTypeDef ADC_InitStructure<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ContinuousConvMode <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_DataAlign <span class="token operator">=</span> ADC_DataAlign_Right<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ExternalTrigConv <span class="token operator">=</span> ADC_ExternalTrigConv_None<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_Mode <span class="token operator">=</span> ADC_Mode_Independent<span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_NbrOfChannel <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>ADC_InitStructure<span class="token punctuation">.</span>ADC_ScanConvMode <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span><span class="token function">ADC_Init</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ADC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置DMA传输模式<pre class="line-numbers language-c" data-language="c"><code class="language-c">DMA_InitTypeDef DMA_InitStructure<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_BufferSize <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_DIR <span class="token operator">=</span> DMA_DIR_PeripheralSRC<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_M2M <span class="token operator">=</span> DMA_M2M_Disable<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>AD_Value<span class="token punctuation">;</span>  <span class="token comment">// 传输目标地址</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryDataSize <span class="token operator">=</span> DMA_MemoryDataSize_HalfWord<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryInc <span class="token operator">=</span> DMA_MemoryInc_Enable<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_Mode <span class="token operator">=</span> DMA_Mode_Normal<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ADC1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span> <span class="token comment">// ADC转换后的值所处地址</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralDataSize <span class="token operator">=</span> DMA_PeripheralDataSize_HalfWord<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralInc <span class="token operator">=</span> DMA_PeripheralInc_Disable<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_Priority <span class="token operator">=</span> DMA_Priority_Medium<span class="token punctuation">;</span><span class="token function">DMA_Init</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DMA_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>开关控制<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_DMACmd</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_Cmd</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>ADC校准<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ADC_ResetCalibration</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ADC_GetResetCalibrationStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ADC_StartCalibration</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ADC_GetCalibrationStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>转换<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">AD_GetValue</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_SetCurrDataCounter</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Channel1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ADC_SoftwareStartConvCmd</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">DMA_GetFlagStatus</span><span class="token punctuation">(</span>DMA1_FLAG_TC1<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span>DMA1_FLAG_TC1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>ADC连续扫描 + DMA循环运转<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADC_InitStructure<span class="token punctuation">.</span>ADC_ContinuousConvMode <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>DMA_InitStructure<span class="token punctuation">.</span>DMA_M2M <span class="token operator">=</span> DMA_M2M_Enable<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>转换一直进行，直接读取即可得转换和转移后的数据。转换部分代码不再需要</p></blockquote></li></ul><h2 id="USART串口通信"><a href="#USART串口通信" class="headerlink" title="USART串口通信"></a>USART串口通信</h2><ul><li>通信协议<table><thead><tr><th>名称</th><th>引脚</th><th>双工</th><th>时钟</th><th>电平</th><th>设备</th></tr></thead><tbody><tr><td>USART</td><td>TX、RX</td><td>全双工</td><td>异步</td><td>单端</td><td>点对点</td></tr><tr><td>I2C</td><td>SCL、SDA</td><td>半双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>SPI</td><td>SCLK、MOSI、MISO、CS</td><td>全双工</td><td>同步</td><td>单端</td><td>多设备</td></tr><tr><td>CAN</td><td>CAN_H、CAN_L</td><td>半双工</td><td>异步</td><td>差分</td><td>多设备</td></tr><tr><td>USB</td><td>DP、DM</td><td>半双工</td><td>异步</td><td>差分</td><td>点对点</td></tr></tbody></table></li><li>串口通信<br>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力<br>简单双向串口通信有两根通信线（发送端TX和接收端RX）<br>TX与RX要交叉连接<br>当只需单向的数据传输时，可以只接一根通信线<br>当电平标准不一致时，需要加电平转换芯片<ul><li>电平标准<br>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：<ul><li>TTL电平：+3.3V或+5V表示1，0V表示0</li><li>RS232电平：-3<del>-15V表示1，+3</del>+15V表示0</li><li>RS485电平：两线压差+2<del>+6V表示1，-2</del>-6V表示0（差分信号）</li></ul></li><li>串口参数与时序<br>波特率：串口通信的速率<br>起始位：标志一个数据帧的开始，固定为低电平<br>数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行<br>校验位：用于数据验证，根据数据位计算得来（奇偶校验）<br>停止位：用于数据帧间隔，固定为高电平</li></ul></li><li>USARTUniversal Synchronous/Asynchronous Receiver/Transmitter）通用同步/异步收发器<br>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里<br>自带波特率发生器，最高达4.5Mbits/s<br>可配置数据位长度（8/9）、停止位长度（0.5/1/1.5/2）<br>可选校验位（无校验/奇校验/偶校验）<br>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN<br>STM32F103C8T6 USART资源： USART1、 USART2、 USART3</li><li>USART框图<br><img src="/image/USART%E6%A1%86%E5%9B%BE.jpg"></li><li>波特率发生器<br>发送器和接收器的波特率由波特率寄存器BRR里的DIV确定<br>计算公式：波特率 = fPCLK2/1 / (16 * DIV)</li></ul><h3 id="串口发送"><a href="#串口发送" class="headerlink" title="串口发送"></a>串口发送</h3><ol><li>开启RCC时钟（GPIO，USART）<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_USART1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>GPIO初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_9<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置USART<pre class="line-numbers language-c" data-language="c"><code class="language-c">USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> <span class="token number">9600</span><span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span> USART_HardwareFlowControl_None<span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Tx<span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No<span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span>USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span><span class="token function">USART_Init</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置中断（接收时）</li><li>开关控制<br><code>USART_Cmd(USART1, ENABLE);</code></li></ol><ul><li>发送功能实现<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Serial_SendBit</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> Byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">USART_SendData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> Byte<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">Serial_SendArray</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>Array<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Length<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token function">USART_SendData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> Array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">Serial_SendString</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>String<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> String<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token function">USART_SendData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> String<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token class-name">uint32_t</span> <span class="token function">Serial_Pow</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> X<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> Y<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">uint32_t</span> Resualt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>Y <span class="token operator">--</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         Resualt <span class="token operator">*=</span> X<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> Resualt<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">Serial_Send_Number</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> Number<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> Length<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token function">Serial_SendBit</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Number <span class="token operator">/</span> <span class="token function">Serial_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> Length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>printf功能移植<ul><li>在keil中打开MicroLIB</li></ul><ol><li>对printf打印功能重定向，使其输出到串口 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Serial_SendBit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ch<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>只能重定向一个串口</p></blockquote></li><li>格式化打印 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> String<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> <span class="token string">"Num:%d\r\n"</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Serial_SendString</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>封装格式化打印,利用<a href="/C_Study_Note.md#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Serial_Printf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> String<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    va_list arg<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vsprintf</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> format<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Serial_SendString</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><h3 id="串口接收"><a href="#串口接收" class="headerlink" title="串口接收"></a>串口接收</h3><ol><li>查询<br>不断查询RXNE标志位。若标志位为1，则表示接收了数据，直接调用<code>ReciveData</code>读取DR寄存器<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">{</span>RxData <span class="token operator">=</span> <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">OLED_ShowHexNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> RxData<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>中断<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span>NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> USART1_IRQn<span class="token punctuation">;</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         Serial_RxData <span class="token operator">=</span> <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">;</span>         Serial_RxFlag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token function">USART_ClearFlag</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="USART串口收发数据包"><a href="#USART串口收发数据包" class="headerlink" title="USART串口收发数据包"></a>USART串口收发数据包</h3><p>在数据包前后加上包头和包尾以识别数据包的起始与结束。<br>载荷数据与包头包尾重复会导致数据识别错误。</p><ul><li>解决方案：<ul><li>对载荷数据进行限幅，使载荷数据与包头包尾不同</li><li>使用固定长度的数据包</li><li>增加包头和包尾的长度</li></ul></li><li>数据包接收（状态机表示）<br>@import “image/接收数据状态转移.jpg”{width=70%}</li></ul><h4 id="串口收发HEX数据包"><a href="#串口收发HEX数据包" class="headerlink" title="串口收发HEX数据包"></a>串口收发HEX数据包</h4><ol><li>定义缓冲区</li><li>发送数据包</li><li>接收数据包(状态转移)  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token class-name">uint8_t</span> Serial_RxState <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token class-name">uint8_t</span> Serial_RxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">uint8_t</span> RxData <span class="token operator">=</span> <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>RxData <span class="token operator">==</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                Serial_RxState <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                Serial_RxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Serial_RxPacket<span class="token punctuation">[</span>Serial_RxNum<span class="token punctuation">]</span> <span class="token operator">=</span> RxData<span class="token punctuation">;</span>            Serial_RxNum <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxNum <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                Serial_RxState <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                   <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>RxData <span class="token operator">==</span> <span class="token number">0xFE</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                Serial_RxState <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                Serial_RxFlag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">USART_ClearFlag</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="串口收发文本数据包"><a href="#串口收发文本数据包" class="headerlink" title="串口收发文本数据包"></a>串口收发文本数据包</h4><p>收数据包状态转移</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetFlagStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> RxData <span class="token operator">=</span> <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>RxData <span class="token operator">==</span> <span class="token char">'@'</span> <span class="token operator">&amp;&amp;</span> Serial_RxFlag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 避免数据包错位</span>        <span class="token punctuation">{</span>            Serial_RxState <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            Serial_RxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>RxData <span class="token operator">==</span> <span class="token char">'\r'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Serial_RxState <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            Serial_RxPacket<span class="token punctuation">[</span>Serial_RxNum<span class="token punctuation">]</span> <span class="token operator">=</span> RxData<span class="token punctuation">;</span>            Serial_RxNum <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                         <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Serial_RxState <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>RxData <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Serial_RxState <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            Serial_RxPacket<span class="token punctuation">[</span>Serial_RxNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>            Serial_RxFlag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">USART_ClearFlag</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_FLAG_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FlyMcu串口下载"><a href="#FlyMcu串口下载" class="headerlink" title="FlyMcu串口下载"></a>FlyMcu串口下载</h3><ol><li>在工程中生成.HEX文件</li><li>配置BOOT引脚：将BOOT0置1</li><li>复位后可以下载程序到单片机中</li></ol><ul><li>选项字节<ul><li>读保护</li><li>写保护</li><li>硬件参数</li><li>用户参数</li></ul></li></ul><h3 id="STLINK-Utility"><a href="#STLINK-Utility" class="headerlink" title="STLINK Utility"></a>STLINK Utility</h3><h2 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h2><p>目的：通过通信线读写外挂模块寄存器（在指定的位置写寄存器和读寄存器）</p><ul><li>I2C(Inter－Integrated Circuit)<br>需要两根信号线完成信息交换，SCL(Serial Clock)时钟信号线，SDA(Serial Data)数据输入/输出线<br>属于同步通信，由于输入输出数据均使用一根线，因此通信方向为半双工<br>一个I2C理论上最多可挂载127个设备，但除去保留地址，最多可挂载112个设备<br>有一主多从和多主多从两个模式</li><li>硬件电路<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF.jpg"><br>所有设备的SCL线连接在一起（SCL由CPU控制），SDA线连在一起<br>设备的SCL和SDA均要配置成开漏输出模式<br>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右<br>设备输出低电平时，三极管导通，输出为低电平<br>设备不输出低电平时，三极管断开，此时电压有上拉电阻控制，上拉为高电平。即设备不输出时的闲置状态都为高电平<blockquote><p>开漏加上拉电阻的输出模式杜绝了电源短路的风险，保证电路的安全<br>避免了引脚模式的频繁切换<br>线与线像：只要有一个设备输出低电平，总线就处于低电平。只有所有设备都输出高电平，总线才处于高电平</p></blockquote></li><li>I2C时序基本单元<ul><li>起始条件：SCL高电平期间，SDA从高电平变换到低电平</li><li>终止条件：SCL高电平期间，SDA从低电平变换到高电平</li><li>发送字节<br><img src="/image/I2C%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82.jpg"><br>SCL低电平期间，主机将数据依次放到SDA总线上（高位先行），然后释放SCL。<br>从机在SCL高电平期间接收数据位，在接受时SDA不允许有数据变化。<br>循环8次发送一个字节。</li><li>接收一个字节<br>SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL。<br>主机将在SCL高电平期间读取数据位，期间SDA不允许有数据变化。<br>依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）。</li><li>发送应答<br>主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</li><li>接收应答<br>主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答。<br>数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</li></ul></li><li>I2C时序<ul><li>指定地址写数据<br>对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）。<br>流程：发送7位设备地址位+1位读写位（0），判断从机应答。然后发送寄存器地址或指令控制地址，从机应答。发送数据，停止。</li><li>当前地址读数据<br>对于指定设备（Slave Address），在==当前指针指示==的地址下读取从机数据。</li><li>指定地址读数据<br>对于指定设备（Slave Address），在指定的地址下，读取从机数据（Data）。<br>流程：发送7位设备地址位+1位读写位（0），判断从机应答。然后发送寄存器地址或指令控制地址，从机应答。再重复起始，发送数据，停止。<br>如要连续读写，主机在接收数据后发送应答信号，从机则继续发送数据；若发送非应答信号，则从机停止发送数据。</li></ul></li><li>缺点：高电平驱动能力比较弱，时钟上升沿耗时比较长，限制I2C的最大通信速度。</li></ul><h3 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h3><p>MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景<a href="%5BMPU6050%E4%BA%A7%E5%93%81%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/PS-MPU-6000A.pdf)">^3</a><br>3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度，静态稳定，动态不稳定<br>3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度，动态稳定，静态不稳定</p><ul><li>参数<br>16位ADC采集传感器的模拟信号，量化范围：$-32768~32767$<br>加速度计满量程选择：$±2、±4、±8、±16（g）$<br>陀螺仪满量程选择： $±250、±500、±1000、±2000(°/sec)$<br>可配置的数字低通滤波器<br>可配置的时钟源<br>可配置的采样分频<br>I2C从机地址：<br>1101000（AD0=0）<br>  1101001（AD0=1）</li><li>硬件电路<br><img src="/image/MPU6050%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF.jpg"><table><thead><tr><th>引脚</th><th>描述</th><th>功能</th></tr></thead><tbody><tr><td>VCC、GND</td><td>电源</td><td>供电</td></tr><tr><td>SCL、SDA</td><td>I2C通信引脚</td><td>作为从设备进行通信</td></tr><tr><td>XCL、XDA</td><td>主机i2c通信引脚</td><td>扩展外接其他芯片（磁力计或气压计）</td></tr><tr><td>AD0</td><td>从机地址最低位</td><td>改变从机地址</td></tr><tr><td>INT</td><td>中断信号输出</td><td>触发中断</td></tr></tbody></table><ul><li>LDO稳压电路：获取稳定的$3.3V$供电</li></ul></li><li>内部结构<br><img src="/image/MPU6050%E6%A1%86%E5%9B%BE.png"></li><li>寄存器操作<a href="%5BMPU6050%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%83%8F%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/RM-MPU-6000A.pdf)">^4</a><table><thead><tr><th>名称</th><th>描述</th><th align="left">功能</th></tr></thead><tbody><tr><td>SMPLRT_DIV</td><td>采样频率分频器</td><td align="left"></td></tr><tr><td>CONFIG</td><td>配置寄存器外部</td><td align="left">同步和低通滤波器</td></tr><tr><td>CYRO_CONFIG</td><td>陀螺仪配置寄存器</td><td align="left">自测和量程选择</td></tr><tr><td>ACCEL_CONFIG</td><td>加速度计配置寄存器</td><td align="left">自测、量程选择、高通滤波器</td></tr><tr><td>ACCEL_XOUT_H</td><td>加速度计XYZ轴数据（_l低8位，_H高8位）</td><td align="left"></td></tr><tr><td>ACCEL_XOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>ACCEL_YOUT_H</td><td>^</td><td align="left"></td></tr><tr><td>ACCEL_YOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>ACCEL_ZOUT_H</td><td>^</td><td align="left"></td></tr><tr><td>ACCEL_ZOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>TEMP_OUT_H</td><td>温度传感器数据</td><td align="left"></td></tr><tr><td>TEMP_OUT_L</td><td>^</td><td align="left"></td></tr><tr><td>GYRO_XOUT_H</td><td>陀螺仪XYZ数据</td><td align="left"></td></tr><tr><td>GYRO_XOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>GYRO_YOUT_H</td><td>^</td><td align="left"></td></tr><tr><td>GYRO_YOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>GYRO_ZOUT_H</td><td>^</td><td align="left"></td></tr><tr><td>GYRO_ZOUT_L</td><td>^</td><td align="left"></td></tr><tr><td>PWR_MGMT_1</td><td>电源管理寄存器</td><td align="left">复位，睡眠，循环，温度传感器失能，系统时钟选择</td></tr><tr><td>PWR_MGMT_2</td><td>^</td><td align="left">睡眠唤醒，6个轴待机选择</td></tr><tr><td>WHO_AM_I</td><td>器件ID号</td><td align="left">I2C地址</td></tr></tbody></table></li></ul><h3 id="软件I2C读写MPU6050"><a href="#软件I2C读写MPU6050" class="headerlink" title="软件I2C读写MPU6050"></a>软件I2C读写MPU6050</h3><ol><li>配置I2C模块<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment">/* 设置SCL的高低电平 */</span><span class="token keyword">void</span> <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span>BitValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Delay_us</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 设置SDA的高低电平*/</span><span class="token keyword">void</span> <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_11<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span>BitValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Delay_us</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 读取SDA的值*/</span><span class="token class-name">uint8_t</span> <span class="token function">MyI2C_R_SDA</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">;</span>    BitValue <span class="token operator">=</span> <span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_11<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Delay_us</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> BitValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 初始化*/</span><span class="token keyword">void</span> <span class="token function">MyI2C_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_OD<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_10 <span class="token operator">|</span> GPIO_Pin_11<span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10 <span class="token operator">|</span> GPIO_Pin_11<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 起始条件 */</span><span class="token keyword">void</span> <span class="token function">MyI2C_Start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 终止条件*/</span><span class="token keyword">void</span> <span class="token function">MyI2C_Stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 发送一个字节 */</span><span class="token keyword">void</span> <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> Byte<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span>Byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">/* 接受一个字节 */</span><span class="token class-name">uint8_t</span> <span class="token function">MyI2C_ReceiveBit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> i<span class="token punctuation">,</span> Byte <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MyI2C_R_SDA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Byte <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Byte<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 发送应答信号 */</span><span class="token keyword">void</span> <span class="token function">MyI2C_SendAck</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> AckBit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span>AckBit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment">/* 接收应答信号*/</span><span class="token class-name">uint8_t</span> <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> AckBit<span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SDA</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AckBit <span class="token operator">=</span> <span class="token function">MyI2C_R_SDA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MyI2C_W_SCL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> AckBit<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置MPU模块<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MyI2C.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MPU6050_REG.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU6050_ADDRESS</span>     <span class="token expression"><span class="token number">0xD0</span>    </span><span class="token comment">// MPU6050设备的地址</span></span><span class="token keyword">void</span> <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> RegAddress<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> Data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MyI2C_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 启动</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>MPU6050_ADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 发送要写数据的设备地址</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接受设备应答</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>RegAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送读取设备寄存器的地址</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接受设备应答</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送数据</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接受设备应答，判断是否继续发送数据</span>    <span class="token function">MyI2C_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 停止发送</span><span class="token punctuation">}</span><span class="token class-name">uint8_t</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> RegAddress<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> Data<span class="token punctuation">;</span>    <span class="token function">MyI2C_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 启动</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>MPU6050_ADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送操作指定设备的命令</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接受设备应答</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>RegAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 发送操作设备寄存器的地址</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接受设备应答</span>    <span class="token function">MyI2C_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 重新启动，接收数据</span>    <span class="token function">MyI2C_SendBit</span><span class="token punctuation">(</span>MPU6050_ADDRESS <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向设备发送读取命令</span>    <span class="token function">MyI2C_ReceiveAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Data <span class="token operator">=</span> <span class="token function">MyI2C_ReceiveBit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读取数据</span>    <span class="token function">MyI2C_SendAck</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 发送是否继续读取数据的命令</span>    <span class="token function">MyI2C_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*MPu6050初始化 */</span><span class="token keyword">void</span> <span class="token function">MPU6050_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MyI2C_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_PWR_MGMT_1<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接除睡眠，选择陀螺仪时钟</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_PWR_MGMT_2<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 6个轴均不待机</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_SMPLRT_DIV<span class="token punctuation">,</span> <span class="token number">0x09</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 采样分频位10</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_CONFIG<span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 外部不同步，平滑滤波</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_GYRO_CONFIG<span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不自测，最大量程</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_CONFIG<span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不自测，最大量程</span><span class="token punctuation">}</span><span class="token class-name">uint8_t</span> <span class="token function">MPU6050_GetID</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_WHO_AM_I<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取传感器的值（由于要返回多个传感器的值，不能直接返回，需用指针或结构体来返回所需值 */</span><span class="token keyword">void</span> <span class="token function">MPU6050_GetData</span><span class="token punctuation">(</span><span class="token class-name">int16_t</span> <span class="token operator">*</span>AccX<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>AccY<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>AccZ<span class="token punctuation">,</span>                    <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroX<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroY<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroZ<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> Data_H<span class="token punctuation">,</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_XOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_XOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccX <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_YOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_YOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccY <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_ZOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_ZOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccZ <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_XOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_XOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroX <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_YOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_YOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroY <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_ZOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_ZOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroZ <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="STM32Z中I2C通信外设"><a href="#STM32Z中I2C通信外设" class="headerlink" title="STM32Z中I2C通信外设"></a>STM32Z中I2C通信外设</h3><p>STM32内部集成了硬件I2C收发电路，可以有硬件自动执行时钟生成，起始终止条件生成、应答收发、数据收发等功能。<br>支持多主机模型（多主多从，可变多主机）<br>支持7位/10位地址模式<br>支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)<br>支持DMA<br>兼容SMBus协议<br>STM32F103C8T6 硬件I2C资源：I2C1、I2C2</p><ul><li>I2C框图<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E6%A1%86%E5%9B%BE.png"><ul><li>数据寄存器存放要发送的数据和接收的数据。数据从数据寄存器移入移位寄存器后，置TXE标志位为1，即发送寄存器为空，可以放数据。</li><li>移位寄存器发送和接收数据。数据收齐后从移位寄存器转入数据寄存器，置RXNE为1，表示发送寄存器非空，可以取数据。</li><li>数据控制：控制着I2C的通信流程</li></ul></li><li>主机发送<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E4%B8%BB%E6%9C%BA%E5%8F%91%E9%80%81.png"></li><li>主机接受<br><img src="/IMAGE/I2C%E7%A1%AC%E4%BB%B6%E4%B8%BB%E6%9C%BA%E6%8E%A5%E5%8F%97.png"></li></ul><h4 id="硬件I2C读写数据"><a href="#硬件I2C读写数据" class="headerlink" title="硬件I2C读写数据"></a>硬件I2C读写数据</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MPU6050_REG.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU6050_ADDRESS</span>     <span class="token expression"><span class="token number">0xD0</span></span></span><span class="token comment">/* 超时等待， 如果函数执行错误或超时，则直接退出（可替代为错误处理模块）*/</span><span class="token keyword">void</span> <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> I2C_EVENT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> Timeout <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">I2C_CheckEvent</span><span class="token punctuation">(</span>I2Cx<span class="token punctuation">,</span> I2C_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> SUCCESS<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Timeout <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Timeout <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/* 写寄存器操作 */</span><span class="token keyword">void</span> <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> RegAddress<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> Data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">I2C_GenerateSTART</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_MODE_SELECT<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// I2C通信主模式选择（EV5）</span>    <span class="token function">I2C_Send7bitAddress</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> MPU6050_ADDRESS<span class="token punctuation">,</span> I2C_Direction_Transmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待发送模式选择完成（EV6）</span>    <span class="token function">I2C_SendData</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> RegAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_BYTE_TRANSMITTING<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// EV8_2</span>    <span class="token function">I2C_SendData</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_BYTE_TRANSMITTED<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 等待数据发送完成（EV8）</span>    <span class="token function">I2C_GenerateSTOP</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 停止发送</span><span class="token punctuation">}</span><span class="token class-name">uint8_t</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> RegAddress<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">I2C_GenerateSTART</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_MODE_SELECT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_Send7bitAddress</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> MPU6050_ADDRESS<span class="token punctuation">,</span> I2C_Direction_Transmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_SendData</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> RegAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_BYTE_TRANSMITTED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_GenerateSTART</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重启动</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_MODE_SELECT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_Send7bitAddress</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> MPU6050_ADDRESS<span class="token punctuation">,</span> I2C_Direction_Receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// EV6</span>    <span class="token function">I2C_AcknowledgeConfig</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_GenerateSTOP</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_WaitEvent</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> I2C_EVENT_MASTER_BYTE_RECEIVED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// EV6_1</span>    <span class="token class-name">uint8_t</span> Data <span class="token operator">=</span> <span class="token function">I2C_ReceiveData</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_AcknowledgeConfig</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">MPU6050_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_OD<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_10 <span class="token operator">|</span> GPIO_Pin_11<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    I2C_InitTypeDef I2C_InitStructure<span class="token punctuation">;</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_Ack <span class="token operator">=</span> I2C_Ack_Enable<span class="token punctuation">;</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_AcknowledgedAddress <span class="token operator">=</span> I2C_AcknowledgedAddress_7bit<span class="token punctuation">;</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_ClockSpeed <span class="token operator">=</span> <span class="token number">50000</span><span class="token punctuation">;</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_DutyCycle <span class="token operator">=</span> I2C_DutyCycle_2<span class="token punctuation">;</span>  <span class="token comment">// 在高频模式下为低电平分配更多的资源，已完成数据的改变</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_Mode <span class="token operator">=</span> I2C_Mode_I2C<span class="token punctuation">;</span>    I2C_InitStructure<span class="token punctuation">.</span>I2C_OwnAddress1 <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>    <span class="token function">I2C_Init</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>I2C_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">I2C_Cmd</span><span class="token punctuation">(</span>I2C2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_PWR_MGMT_1<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 接除睡眠，选择陀螺仪时钟</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_PWR_MGMT_2<span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 6个轴均不待机</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_SMPLRT_DIV<span class="token punctuation">,</span> <span class="token number">0x09</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 采样分频位10</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_CONFIG<span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 外部不同步，平滑滤波</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_GYRO_CONFIG<span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不自测，最大量程</span>    <span class="token function">MPU6050_writeReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_CONFIG<span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不自测，最大量程</span><span class="token punctuation">}</span><span class="token class-name">uint8_t</span> <span class="token function">MPU6050_GetID</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_WHO_AM_I<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">MPU6050_GetData</span><span class="token punctuation">(</span><span class="token class-name">int16_t</span> <span class="token operator">*</span>AccX<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>AccY<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>AccZ<span class="token punctuation">,</span>                    <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroX<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroY<span class="token punctuation">,</span> <span class="token class-name">int16_t</span> <span class="token operator">*</span>GyroZ<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> Data_H<span class="token punctuation">,</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_XOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_XOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccX <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_YOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_YOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccY <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_ZOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_ACCEL_ZOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>AccZ <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_XOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_XOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroX <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_YOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_YOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroY <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span>    Data_H <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_ZOUT_H<span class="token punctuation">)</span><span class="token punctuation">;</span>    Data_L <span class="token operator">=</span> <span class="token function">MPU6050_ReadReg</span><span class="token punctuation">(</span>MPU6050_GYRO_ZOUT_L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>GyroZ <span class="token operator">=</span> <span class="token punctuation">(</span>Data_H <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> Data_L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SPI（serial-peripheral-interface）通信"><a href="#SPI（serial-peripheral-interface）通信" class="headerlink" title="SPI（serial peripheral interface）通信"></a>SPI（serial peripheral interface）通信</h2><p>SPI通信是一种同步式串行通信，它可以在同一时间发送和接收数据，常用于EEPROM或传感器等外围设备与主控制器之间的数据交换。<br>SPI通信需要四根线，分别是时钟（SCLK）、数据输入（SIN）、数据输出（SOUT）和片选（CS）</p><ul><li><p>工作原理<br>主控制器（Master）通过时钟线（SCLK）向外围设备（Slave）发送时钟信号，同时通过数据输出线（SOUT）发送数据，外围设备通过数据输入线（SIN）接收数据。<br>反之，外围设备也可以通过SOUT发送数据，主控制器通过SIN接收数据。片选线（CS）用于选择要通信的外围设备，一般由主控制器控制。</p></li><li><p>优点<br>SPI通信的优点是速度快，全双工，硬件简单，不需要地址识别。</p></li><li><p>缺点<br>SPI通信的缺点是需要多根线，不适合长距离传输，不支持多主控制器，需要额外的片选线来区分不同的外围设备。</p></li><li><p>硬件电路<br>输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入</p></li><li><p>起始条件：CS从高电平切换为低电平</p></li><li><p>终止条件：CS从低电平切换为高电平</p></li><li><p>SPI时序</p><ul><li>CPOL(clock plority)时钟极性<ul><li>CPOL=0的时候是上升沿采集数据。SCLK在空闲时为低电平。</li><li>CPOL=1的时候是下降沿采集数据。SCLK在空闲时为高电平。</li></ul></li><li>CPHA(clock phase)时钟相位<ul><li>CPOL=0的时候是第一次跳变沿采集数据。</li><li>CPOL=1的时候是第二次跳变沿采集数据。</li></ul></li><li>模式<ul><li>模式0（CPOL = 0; CPHA = 0）<br>时钟空闲时为低电平，第一个跳变沿为上升沿，第二个跳变沿为下降沿。在第一次跳变时采集数据，即上升沿采集数据</li><li>模式1（CPOL = 0; CPHA = 1）<br>时钟空闲时为低电平，第一个跳变沿为上升沿，第二个跳变沿为下降沿。在第二次跳变时采集数据，即在下降沿采集数据</li><li>模式2（CPOL = 1; CPHA = 0）<br>时钟空闲时为高电平，第一个跳变沿为下降沿，第二个跳变沿为上升沿。在第一次跳变时采集数据，即下降沿采集数据</li><li>模式3（CPOL = 1; CPHA = 1）<br>时钟空闲时为高电平，第一个跳变沿为下降沿，第二个跳变沿为上升沿。在第二次跳变时采集数据，即下降沿采集数据</li></ul></li></ul></li><li><p>Flash操作</p><ul><li>写入操作时：<br>写入操作前，必须先进行写使能<br>每个数据位只能由1改写为0，不能由0改写为1<br>写入数据前必须先擦除，擦除后，所有数据位变为1<br>擦除必须按最小擦除单元（一个扇区，4kb，4096字节）进行<br>连续写入多字节时，最多写入一页（256字节）的数据，超过页尾位置的数据，会回到页首覆盖写入<br>写入操作结束后，芯片进入忙状态，不响应新的读写操作</li><li>读取操作时：<br>直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取</li></ul></li></ul><h3 id="软件SPI读写W25Q64"><a href="#软件SPI读写W25Q64" class="headerlink" title="软件SPI读写W25Q64"></a>软件SPI读写W25Q64</h3><ul><li>SPI通信模块<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token comment">/* 设置CS的电平 */</span><span class="token keyword">void</span> <span class="token function">MySPI_W_CS</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_4<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span>BitValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*设置MOSI的电平 */</span><span class="token keyword">void</span> <span class="token function">MySPI_W_MOSI</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_7<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span>BitValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*设置CLK的电平 */</span><span class="token keyword">void</span> <span class="token function">MySPI_W_CLK</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> BitValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_5<span class="token punctuation">,</span> <span class="token punctuation">(</span>BitAction<span class="token punctuation">)</span>BitValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 设置MISO的电平 */</span><span class="token class-name">uint8_t</span> <span class="token function">MySPI_R_MISO</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> GPIO_Pin_6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 引脚初始化 */</span><span class="token keyword">void</span> <span class="token function">MySPI_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>  <span class="token comment">// 配置CLK、MISO、CS为推挽输出</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_4 <span class="token operator">|</span> GPIO_Pin_5 <span class="token operator">|</span> GPIO_Pin_7<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>   <span class="token comment">// 配置MISO为上拉输入</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_W_CS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 片选默认值为高电平，低电平时选中从机开始数据传输</span>    <span class="token function">MySPI_W_CLK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模式0：CLK空闲时为高电平</span><span class="token punctuation">}</span><span class="token comment">/* SPI时序开始标志 */</span><span class="token keyword">void</span> <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MySPI_W_CS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 片选信号为低电平，选中从机开始数据传输</span><span class="token punctuation">}</span><span class="token comment">/* SPI时序结束标志 */</span><span class="token keyword">void</span> <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MySPI_W_CS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 片选信号为高电平，为选中从机，不传输数据</span><span class="token punctuation">}</span><span class="token comment">/* SPI时序交换字节 */</span><span class="token class-name">uint8_t</span> <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> SendByte<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> i<span class="token punctuation">,</span> ReceiveByte <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">MySPI_W_MOSI</span><span class="token punctuation">(</span>SendByte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 通过掩码，依次对每一位进行操作</span>        <span class="token function">MySPI_W_CLK</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MySPI_R_MISO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ReceiveByte <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token function">MySPI_W_CLK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ReceiveByte<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>W25Q64读写数据模块<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span>                  <span class="token comment">// Device header</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MySPI.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"W25Q64_Ins.h"</span></span><span class="token keyword">void</span> <span class="token function">W25Q64_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MySPI_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 读取设备ID号 */</span><span class="token keyword">void</span> <span class="token function">W25Q64_ReadID</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>MID<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> <span class="token operator">*</span>DID<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 开始标志</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_JEDEC_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送读取设备ID的指令</span>    <span class="token operator">*</span>MID <span class="token operator">=</span> <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q62_DUMMY_BYTE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 读取厂商ID</span>    <span class="token operator">*</span>DID <span class="token operator">=</span> <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q62_DUMMY_BYTE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 读取设备ID高8位</span>    <span class="token operator">*</span>DID <span class="token operator">&lt;&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token operator">*</span>DID <span class="token operator">|=</span> <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q62_DUMMY_BYTE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读取设备ID低8位</span>    <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 结束标志</span><span class="token punctuation">}</span><span class="token comment">/* 写入使能（W25Q64默认不能写入数据）*/</span><span class="token keyword">void</span> <span class="token function">W25Q62_WriteEnable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_WRITE_ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送写入使能指令</span>    <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 等待忙状态结束 */</span><span class="token keyword">void</span> <span class="token function">W25Q64_WaitBusy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> Timeout <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_READ_STATUS_REGISTER_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送读取状态寄存器指令</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q62_DUMMY_BYTE<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x01</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Timeout <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Timeout <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 向指定页写入数据 */</span><span class="token keyword">void</span> <span class="token function">W25Q64_PageProgram</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> Address<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>DataArray<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> i<span class="token punctuation">;</span>    <span class="token function">W25Q62_WriteEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_PAGE_PROGRAM<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 发送页写入指令</span>    <span class="token comment">/* 发送写入地址 */</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 写入数据 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Count<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>DataArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">W25Q64_WaitBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 事后等待</span><span class="token punctuation">}</span><span class="token comment">/* 扇区擦除 */</span><span class="token keyword">void</span> <span class="token function">W25Q64_SectorErase</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> Address<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">W25Q62_WriteEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_SECTOR_ERASE_4KB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">W25Q64_WaitBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 读取数据 */</span><span class="token keyword">void</span> <span class="token function">W25Q64_ReadData</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> Address<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>DataArray<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> Count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> i<span class="token punctuation">;</span>    <span class="token function">MySPI_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q64_READ_DATA<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 发送读取数据指令</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>Address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Count<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        DataArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">MySPI_SwapByte</span><span class="token punctuation">(</span>W25Q62_DUMMY_BYTE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">MySPI_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>PID(proportion integration differentiation)其实就是指比例，积分，微分控制。</p><ul><li><p>连续型：<br>$$U(t) = k_P(err(t) + \frac {1}{T_{I}} \int \operatorname {err}(t)dt + \frac {T_{D}derr(t)}{dt})$$<br>$K_p$：比例增益，是调适参数；<br>$K_I = \frac {1} {T_{I}} $：积分增益，也是调适参数；<br>$K_D = T_{D}$：微分增益，也是调适参数；<br>err：误差=设定值（SP）- 回授值（PV）；<br>t：目前时间。</p></li><li><p>离散型：<br>$$U(k)=K_{P}(err(k)+ \frac{T}{T_{I}}\sum err(k)+ \frac{T_{D}}{T}(err(k)-err(k-1)))$$</p><blockquote><p>比例增益将误差线性放大，微分环增益将误差的变化率放大，积分增益将过去误差值的总和放大</p></blockquote><ul><li>位置型<br>$$U(k)=K_{p}err(k)+K_{i}\sum err(k)+K_{d}(err(k)-err(k-1))$$<blockquote></blockquote></li><li>增量型<br>$$ \Delta U(k)=K_{p}(err(k)-err(k-1))+K_{i}err(k)+K_{d}(err(k)-2err(k-1)+err(k-2))$$<blockquote></blockquote></li></ul></li><li><p>比例控制：<br>比例增益的作用是对偏差瞬间作出反应。<br>偏差一旦产生控制器立即产生控制作用， 使控制量向减少偏差的方向变化。<br>控制作用的强弱取决于比例系数Kp， 比例系数Kp越大，控制作用越强， 则过渡过程越快， 控制过程的静态偏差也就越小；<br>但是Kp越大，也越容易产生振荡， 破坏系统的稳定性。<br>缺点：存在稳态误差。</p></li><li><p>积分控制：<br>能够消除稳态误差，但会超调，即在设定值附近来回抖动。<br>缺点：存在饱和效应。在非线性系统中需要判断执行器是否达到饱和状态（判断执行器的输入和输出是否相等以及执行器的输入符号和误差的符号是否相等）</p></li><li><p>微分控制：<br>它是根据偏差的变化趋势（变化速度）进行控制。偏差变化的越快，微分控制器的输出就越大，并能在偏差值变大之前进行修正。<br>产生刹车效应。可以解决超调现象，但会降低达到预设值的速度<br>缺点：噪声会对微分分控制有很大的影响，需要滤掉频率较高的噪声。</p></li></ul><blockquote><p>需要调节这三条控制路径的增益，来达到稳定的控制效果</p></blockquote><h3 id="PID代码实现"><a href="#PID代码实现" class="headerlink" title="PID代码实现"></a>PID代码实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">float</span> SetValue<span class="token punctuation">;</span>            <span class="token comment">//定义设定值</span>    <span class="token keyword">float</span> ActualValue<span class="token punctuation">;</span>        <span class="token comment">//定义实际值</span>    <span class="token keyword">float</span> err<span class="token punctuation">;</span>                <span class="token comment">//定义当前偏差值</span>    <span class="token keyword">float</span> err_1<span class="token punctuation">;</span>            <span class="token comment">//定义上一个偏差值</span>    <span class="token keyword">float</span> err_2<span class="token punctuation">;</span>    <span class="token keyword">float</span> Kp<span class="token punctuation">,</span> Ki<span class="token punctuation">,</span> Kd<span class="token punctuation">;</span>            <span class="token comment">//定义比例、积分、微分系数</span>    <span class="token keyword">float</span> Actuator<span class="token punctuation">;</span>          <span class="token comment">//定义电压值（控制执行器的变量）</span>    <span class="token keyword">float</span> integral<span class="token punctuation">;</span>            <span class="token comment">//定义积分值</span><span class="token punctuation">}</span>PIDTypeDef<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">PID_init</span><span class="token punctuation">(</span>PIDTypeDef <span class="token operator">*</span>PID<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"PID_init begin \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>SetValue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>ActualValue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err_1 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>Actuator <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>integral <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>Kp <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>Ki <span class="token operator">=</span> <span class="token number">0.015</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>Kd <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"PID_init end \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 位置型 */</span><span class="token keyword">float</span> <span class="token function">PID_Location</span><span class="token punctuation">(</span><span class="token keyword">float</span> setvalue<span class="token punctuation">,</span> PIdTypeDef <span class="token operator">*</span>PID<span class="token punctuation">)</span><span class="token punctuation">{</span>    PID<span class="token punctuation">.</span>SetValue <span class="token operator">=</span> setvalue<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err <span class="token operator">=</span> PID<span class="token punctuation">.</span>SetValue <span class="token operator">-</span> PID<span class="token punctuation">.</span>ActualValue<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>integral <span class="token operator">+=</span> PID<span class="token punctuation">.</span>err<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>Actuator <span class="token operator">=</span> PID<span class="token punctuation">.</span>Kp <span class="token operator">*</span> PID<span class="token punctuation">.</span>err <span class="token operator">+</span> PID<span class="token punctuation">.</span>Ki <span class="token operator">*</span> PID<span class="token punctuation">.</span>integral <span class="token operator">+</span> PID<span class="token punctuation">.</span>Kd <span class="token operator">*</span> <span class="token punctuation">(</span>PID<span class="token punctuation">.</span>err <span class="token operator">-</span> PID<span class="token punctuation">.</span>err_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err_1 <span class="token operator">=</span> PID<span class="token punctuation">.</span>err<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>ActualValue <span class="token operator">=</span> PID<span class="token punctuation">.</span>Actuator <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> PID<span class="token punctuation">.</span>ActualValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 增量型 */</span><span class="token keyword">float</span> <span class="token function">PID_Increment</span><span class="token punctuation">(</span><span class="token keyword">float</span> setvalue<span class="token punctuation">,</span> PIdTypeDef <span class="token operator">*</span>PID<span class="token punctuation">)</span><span class="token punctuation">{</span>    PID<span class="token punctuation">.</span>SetValue<span class="token operator">=</span>setvalue<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err<span class="token operator">=</span>PID<span class="token punctuation">.</span>SetValue <span class="token operator">-</span> PID<span class="token punctuation">.</span>Actualvalue<span class="token punctuation">;</span>    <span class="token keyword">float</span> incrementvalue <span class="token operator">=</span> PID<span class="token punctuation">.</span>Kp <span class="token operator">*</span> <span class="token punctuation">(</span>PID<span class="token punctuation">.</span>err <span class="token operator">-</span> PID<span class="token punctuation">.</span>err_1<span class="token punctuation">)</span> <span class="token operator">+</span> PID<span class="token punctuation">.</span>Ki <span class="token operator">*</span> PID<span class="token punctuation">.</span>err <span class="token operator">+</span> PID<span class="token punctuation">.</span>Kd <span class="token operator">*</span> <span class="token punctuation">(</span>PID<span class="token punctuation">.</span>err <span class="token operator">-</span>PID<span class="token punctuation">.</span>err_1 <span class="token operator">+</span> PID<span class="token punctuation">.</span>err_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>ActualValue <span class="token operator">+=</span> incrementvalue<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err_2<span class="token operator">=</span>PID<span class="token punctuation">.</span>err_1<span class="token punctuation">;</span>    PID<span class="token punctuation">.</span>err_1<span class="token operator">=</span>PID<span class="token punctuation">.</span>err<span class="token punctuation">;</span>    <span class="token keyword">return</span> PID<span class="token punctuation">.</span>ActualValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PID调整"><a href="#PID调整" class="headerlink" title="PID调整"></a>PID调整</h3><p>对于不同的系统，不同的环境，所需的PID参数也不同，所以不存在适用于万物的PID参数。</p><ul><li>调整方法：<ol><li>对系统建立模型，根据模型来调整</li><li>直接观察系统，手动调整</li><li>系统自动调整</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/03/22/markdown-study-note/"/>
      <url>/2023/03/22/markdown-study-note/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><p><a href="https://markdown.com.cn/" title="教程">Markdown语法教程</a></p><h2 id="代码块书写"><a href="#代码块书写" class="headerlink" title="代码块书写"></a>代码块书写</h2><ol><li><p><strong>四个空格或一个tab键书写代码块（在列表中要用八个空格键或一个tab键）</strong></p><pre><code> #include&lt;stdio.h&gt; int main(void) {     printf("hello world！")；     return 0; }</code></pre></li><li><p><strong>反引号书写代码块</strong>  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li><p><strong>有序列表</strong><br> 例子：</p><ol><li>first item</li><li>second item</li><li>third item</li></ol></li><li><p><strong>无序列表</strong><br>例子:  </p><ul><li>first ietm</li><li>second item</li><li>third item</li></ul></li><li><p><strong>待办书写</strong></p></li></ol><ul><li><input checked="" disabled="" type="checkbox"> 任务一</li><li><input disabled="" type="checkbox"> 任务二<ul><li><input disabled="" type="checkbox"> 分布任务一</li><li><input checked="" disabled="" type="checkbox"> 分布任务二</li></ul></li></ul><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>引用一句话</p><p>引用第二句话</p><blockquote><p>嵌套引用第三句话</p></blockquote></blockquote><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="left">第一列</th><th align="right">第二列</th><th align="center">第三列</th></tr></thead><tbody><tr><td align="left">元素1</td><td align="right">元素2</td><td align="center">元素3</td></tr><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中对齐</td></tr></tbody></table><p>注：符号需要用英文字符打</p><hr><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><ul><li><p>网址：<a href="https://www.baidu.com/">https://www.baidu.com</a></p></li><li><p>邮件：<a href="mailto:username@outlook.com">username@outlook.com</a></p></li><li><p>引用链接<br><a href="https://markdown.com.cn/" title="教程">Markdown语法教程</a>  </p></li><li><p>跳转：教程见<a href="#markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">Markdown基本语法教程</a>  </p></li><li><p>插入图片：<img src="/image/ChMkJ1fJQfuIKbAtAAHcR1shWEEAAU7jgMK2KkAAdxf426.jpg" alt="插入图片名称" title="坂田银时"></p></li></ul><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong>  ：快捷键<code>ctrl+b</code><br><strong>加粗</strong><br><u>下划线</u><br>==文本高亮==  <!--未实现，需安装markdown preview enhanced插件--><br><del>删除线</del><br>上标：x^2^<br>下标：H<del>2</del>O<br>脚注：脚注<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8">^1</a></p><h2 id="设置文件跳转链接"><a href="#设置文件跳转链接" class="headerlink" title="设置文件跳转链接"></a><a href="https://blog.csdn.net/weixin_43031092/article/details/105322677">设置文件跳转链接</a></h2><p><a href="./MarkdownStudyNote.html">./MarkdownStudyNote.html</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
