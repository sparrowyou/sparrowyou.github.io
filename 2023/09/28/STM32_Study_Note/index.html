<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="STM32学习, Sparrow">
    <meta name="description" content="STM32入门学习STM32学习基于STM32F103C8T6芯片
STM32开发环境搭建
安装keil5 MDK软件
安装STM32器件支持包
安装STlink驱动
安装USB转串口CH340驱动
在vscode中配置STM32开发环境
">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>STM32学习 | Sparrow</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Sparrow</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Sparrow</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">STM32学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">
                                <span class="chip bg-color">嵌入式</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-09-28
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="STM32入门学习"><a href="#STM32入门学习" class="headerlink" title="STM32入门学习"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1th411z7sn?p=1&vd_source=0a3e5759a1072cc76091a2b54f770f13" title="江科大自化协教程">STM32入门学习</a></h1><p><em><strong>STM32学习基于STM32F103C8T6芯片</strong></em></p>
<h2 id="STM32开发环境搭建"><a href="#STM32开发环境搭建" class="headerlink" title="STM32开发环境搭建"></a>STM32开发环境搭建</h2><ul>
<li>安装keil5 MDK软件</li>
<li>安装STM32器件支持包</li>
<li>安装STlink驱动</li>
<li>安装USB转串口CH340驱动</li>
<li>在vscode中配置STM32开发环境<ul>
<li>安装C&#x2F;C++插件</li>
<li>安装keil assistant插件</li>
<li>在keil assistant插件中添加keil可执行文件UV4.exe的绝对路径</li>
<li>在vscode中打开keil的工程文件</li>
</ul>
</li>
</ul>
<h2 id="认识STM32最小系统的基本结构"><a href="#认识STM32最小系统的基本结构" class="headerlink" title="认识STM32最小系统的基本结构"></a>认识STM32最小系统的基本结构</h2><ul>
<li><strong>STM32F103C8T6</strong><br>@import “image\STM32F1.jpg”<ul>
<li>系列：主流系列STM32F1</li>
<li>内核：ARM Cortex-M3</li>
<li>主频：72MHz</li>
<li>RAM：20K（SRAM）</li>
<li>ROM：64K（Flash）</li>
<li>供电：2.0~3.6V（标准3.3V）</li>
<li>封装：LQFP48</li>
</ul>
</li>
<li>最小系统板上的资源<br><img src="/image%5CSTM32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E8%B5%84%E6%BA%90.jpg" alt="STM32"></li>
<li>STM32F01系列系统结构<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a><br><img src="/image/STM32%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg" alt="系统结构"><ul>
<li>驱动单元：<br>Cortex^TM^-M3内核DCode总线(D-bus),和系统总线(S-bus),控制总线（ICode）<br>通用DMA1和通用DMA2</li>
<li>被动单元<br>内部SRAM<br>内部闪存存储器<br>FSMC<br>AHB到APB的桥(AHB2APBx),它连接所有的APB设备</li>
<li>ICode总线<br>该总线将CortexTM-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成。</li>
<li>DCode总线<br>该总线将Cortex TM.-M3内核的DCode总线与闪存存储器的数据接口相连接（常量加载和调试访问）。</li>
<li>系统总线<br>此总线连接Cortex TM-M3内核的系统总线（外设总线）到总线矩阵，总线矩阵协调着内核和DMA间的访问。</li>
<li>DMA总线<br>此总线将DMA的AHB主控接口与总线矩阵相联，总线矩阵协调着CPU的DCode和DMA到SRAM、闪存和外设的访问。</li>
<li>总线矩阵<br>总线矩阵协调内核系统总线和DMA主控总线之间的访问仲裁，仲裁利用轮换算法。<br>AHB外设通过总线矩阵与系统总线相连，允许DMA访问。</li>
<li>AHB&#x2F;APB桥(APB)<br>两个AHB&#x2F;APB桥在AHB和2个APB总线间提供同步连接。APB1操作速度限于36MHz，APB2操作于全速(最高72MHz)。</li>
</ul>
</li>
<li>引脚定义<a href="%5BSTM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^2</a><br><img src="/image%5C%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png" alt="引脚定义"></li>
<li>启动配置<br><img src="/image/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" alt="启动配置"></li>
<li>最小系统电路<br><img src="/image/%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E8%B7%AF.png" alt="最小系统电路"></li>
</ul>
<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><ol>
<li><p>建立工程文件夹，Keil中新建工程，选择型号</p>
</li>
<li><p>在工程文件夹中添加必要的固件库文件</p>
<ol>
<li>添加启动文件（start）<br> 根据所选芯片添加对应的启动文件、系统文件、内核文件<br> <img src="/image/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.jpg" alt="启动文件"></li>
<li>在工程中创建Start文件夹，并将工程文件夹中的文件添加到对应的工程分组里</li>
<li>工程选项，C&#x2F;C++，Include Paths内声明所有包含头文件的文件夹</li>
<li>编译，看是否操作正确</li>
<li>在工程文件夹中创建User文件夹，工程中创建同名文件夹，并新建main.c文件</li>
<li>在main.c中写个死循环，编译，看是否能成功</li>
<li>在工程文件夹中创建Library文件夹，并将库函数文件放入</li>
<li>将*_conf.h, *_it.h, *_it.c放入User文件夹，并在工程中也同样添加</li>
<li>工程选项，C&#x2F;C++，Define内定义USE_STDPERIPH_DRIVER</li>
<li>工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run</li>
</ol>
</li>
<li><p>点灯</p>
<ol>
<li>通过控制寄存器来点灯</li>
</ol>
<ul>
<li>在官方文档中<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a>查找GPIOC所在的APB2外设寄存器RCC_APB2ENR配置信息<br>为LEDpc13端口设置时钟：<code>RCC-&gt;APB2ENR = 0x00000010;</code></li>
<li>查找端口配置高寄存器GPIOC_ARH的端口配置信息<br>为LEDpc13端口配置端口模式：<code>GPIOC-&gt;CRH = 0x00300000;</code></li>
<li>查找端口输出数据寄存器GPIOC_ODR的端口配置信息<br>为为LEDpc13端口配置输出：<code>GPIOC-&gt;ODR = 0x00000000;</code></li>
<li>编译，下载，实现点灯<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC-&gt;APB2ENR = <span class="number">0x00000010</span>;</span><br><span class="line">  GPIOC-&gt;CRH = <span class="number">0x00300000</span>;</span><br><span class="line">  GPIOC-&gt;ODR = <span class="number">0x00002000</span>;</span><br><span class="line"><span class="comment">//	GPIOC-&gt;ODR = 0x00000000;</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>利用库函数来点灯<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line">  GPIO_SetBits(GPIOC, GPIO_Pin_13);</span><br><span class="line"><span class="comment">//	GPIO_ResetBits(GPIOC, GPIO_Pin_13);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="GPIO（通用输入输出口）"><a href="#GPIO（通用输入输出口）" class="headerlink" title="GPIO（通用输入输出口）"></a>GPIO（通用输入输出口）</h2><ul>
<li>可配置为8种输入输出模式<br><img src="/image/GPIO%E6%A8%A1%E5%BC%8F.jpg" alt="GPIO模式"></li>
<li>引脚电平：0V~3.3V，部分引脚可容忍5V</li>
<li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</li>
<li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="/image/GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="GPIO基本结构"></p>
<ul>
<li>寄存器每一位对应一个引脚</li>
<li>输出寄存器为1，引脚输出为高电平；为0，则为低电平</li>
<li>引脚输入为高电平，输入寄存器为1；为低电平，则为0</li>
<li>驱动器负责增大驱动能力</li>
</ul>
<h3 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h3><p><img src="/image/GPIO%E4%BD%8D%E7%BB%93%E6%9E%84.png" alt="GPIO位结构"><br>GPIO位结构可分为两个部分：上面的输入部分，下面的输出部分。</p>
<ul>
<li>保护二极管：对输入电压限幅<br>若输入电压大于VDD，上方的二极管导通，则电流直接流入VDD，避免电压过高损坏内部电路。<br>若输入电压小于VSS，下方的二极管导通则电流从VSS流出到IO引脚，保护内部电路。</li>
<li>输入部分<ul>
<li>上拉电阻与下拉电阻<br>在IO引脚无输入时，输入处于浮空状态，容易受到外界干扰。<br>上拉电阻接通时，可为输入提供高电平，即高电平输入模式。<br>下拉电阻接通时，可为输入提供低电平，即低电平输入模式。</li>
<li>TTL肖特基触发器（施密特触发器）<br>为输入电压整形：若输入大于阈值，则会直接变为高电平；若输入电压小于阈值，则会直接变为低电平。<br>整形后的电平传入输入寄存器，即可读取外部输入电平信号。</li>
<li>模拟输入：连接至ADC</li>
<li>复用功能输入：连接其他需要读取端口电平的外设上</li>
</ul>
</li>
<li>输出部分<ul>
<li>位设置&#x2F;清除寄存器：能够只操作输出寄存器的某一位而不影响其它位的状态</li>
<li>推挽输出：控制P-MOS和N-MOS的通断输出高低电平，且有较强的驱动力<br>（单片机一般都是高电平驱动能力弱，低电平驱动能力强）</li>
<li>开漏输出：只能输出低电平，可作为通信协议的驱动方式</li>
<li>关闭：转为输入模式</li>
</ul>
</li>
</ul>
<h3 id="GPIO口输出控制"><a href="#GPIO口输出控制" class="headerlink" title="GPIO口输出控制"></a>GPIO口输出控制</h3><h4 id="LED闪烁"><a href="#LED闪烁" class="headerlink" title="LED闪烁"></a>LED闪烁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	GPIO_ResetBits(GPIOA, GPIO_Pin_0);</span></span><br><span class="line"><span class="comment">//	GPIO_SetBits(GPIOA, GPIO_Pin_0);</span></span><br><span class="line"><span class="comment">//	GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);</span></span><br><span class="line"><span class="comment">//	GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_0);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_0);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">0</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">1</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>了解RCC_APB2PeriphClockCmd、GPIO_Init、GPIO_ResetBits、GPIO_SetBits、GPIO_WriteBit、GPIO_WriteBit库函数的使用。</p>
</blockquote>
<h4 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0001</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0002</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0004</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0008</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0010</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0020</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0040</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOA, ~<span class="number">0x0080</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>了解GPIO_Write库函数的使用</p>
</blockquote>
<h3 id="GPIO输入控制"><a href="#GPIO输入控制" class="headerlink" title="GPIO输入控制"></a>GPIO输入控制</h3><h4 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h4><ul>
<li>学习模块化编程</li>
<li>编写功能功能模块*.c和*.h代码，来实现具体的功能</li>
<li>在主程序头文件声明、引用功能模块，并在程序中调用，简化主程序代码。</li>
</ul>
<h4 id="光敏电阻控制蜂鸣器"><a href="#光敏电阻控制蜂鸣器" class="headerlink" title="光敏电阻控制蜂鸣器"></a>光敏电阻控制蜂鸣器</h4><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li>串口调试<br>通过串口通信，将调试信息发送至电脑，在电脑上用调试助手显示调试信息。</li>
<li>显示屏调试<br>用显示屏直接连接至单片机，调试信息直接显示在显示屏上。</li>
<li>keil调试模式<br>借助Keil软件的调试模式，可使用单步运行、设置断点、查看寄存器及变量等功能。</li>
</ul>
<h3 id="OLED显示屏"><a href="#OLED显示屏" class="headerlink" title="OLED显示屏"></a>OLED显示屏</h3><p>@import “image&#x2F;1680176826998.jpg” {width&#x3D;”400px” height&#x3D;”300px” title&#x3D;”OLED显示屏” alt&#x3D;”我的 alt”}</p>
<h2 id="中断系统-1"><a href="#中断系统-1" class="headerlink" title="中断系统^1"></a>中断系统<a href="%5BSTM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^1</a></h2><ul>
<li>中断<br>在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。</li>
<li>中断优先级<br>当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源。</li>
<li>中断嵌套<br>当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。</li>
</ul>
<h3 id="中断源与中断管理"><a href="#中断源与中断管理" class="headerlink" title="中断源与中断管理"></a>中断源与中断管理</h3><ul>
<li>中断源<ul>
<li>EXIT外部中断</li>
<li>TIM定时器</li>
<li>ADC模数转换器</li>
<li>USTART串口</li>
<li>SPI通信</li>
<li>I2C通信</li>
<li>RTC实时时钟</li>
</ul>
</li>
<li>NVIC管理<a href="%5BSTM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf)">^2</a><br>NVIC中断、分配中断优先级（16个等级）、设置抢断优先级和响应优先级。<br>NVIC的中断优先级由4位优先级寄存器决定，可分为高n位的抢占优先级和低4-n的响应优先级。<table>
<thead>
<tr>
<th align="center">分组方式</th>
<th align="center">抢占优先级</th>
<th align="center">响应优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分组0</td>
<td align="center">0位，取值为0</td>
<td align="center">4位，取值为0~15</td>
</tr>
<tr>
<td align="center">分组1</td>
<td align="center">1位，取值为0-1</td>
<td align="center">3位，取值为0~7</td>
</tr>
<tr>
<td align="center">分组2</td>
<td align="center">2位，取值为0-3</td>
<td align="center">2位，取值为0-3</td>
</tr>
<tr>
<td align="center">分组3</td>
<td align="center">3位，取值为0~7</td>
<td align="center">1位，取值为0-1</td>
</tr>
<tr>
<td align="center">分组4</td>
<td align="center">4位，取值为0~15</td>
<td align="center">0位，取值为0</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请。<br>经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序<br>支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发<br>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断<br>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒<br>触发响应方式：中断响应&#x2F;事件响应</p>
<ul>
<li>EXIT基本结构<br>@import “image&#x2F;EXIT基本结构.jpg” {width&#x3D;60%}</li>
<li><strong>AFIO复用IO口</strong><br>AFIO主要用于引脚复用功能的选择和重定义.<br>在STM32中，AFIO主要完成两个任务：&#x3D;&#x3D;复用功能引脚重映射、中断引脚选择&#x3D;&#x3D;.</li>
</ul>
<h4 id="对射式红外计次"><a href="#对射式红外计次" class="headerlink" title="对射式红外计次"></a>对射式红外计次</h4><ol>
<li>配置RCC：开启GPIO和AFIO的时钟（EXTI,NVIC不需要配置时钟）</li>
<li>配置GPIO</li>
<li>配置AFIO</li>
<li>配置EXIT</li>
<li>配置NVIC<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> countsensor_num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 配置RCC：开启GPIO和AFIO的时钟（EXTI,NVIC不需要配置时钟）*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruture;</span><br><span class="line">    GPIO_InitStruture.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStruture.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">    GPIO_InitStruture.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStruture);</span><br><span class="line"></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);  <span class="comment">//配置AFIO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置EXIT */</span></span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line14;</span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置NVIC */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStruture;</span><br><span class="line">    NVIC_InitStruture.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">    NVIC_InitStruture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStruture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStruture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStruture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取计数值 */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> countsensor_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置进入中断执行的计数条件 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        countsensor_num ++;</span><br><span class="line">        EXTI_ClearITPendingBit(EXTI_Line14);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="旋转编码计次"><a href="#旋转编码计次" class="headerlink" title="旋转编码计次"></a>旋转编码计次</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStruture;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruture);</span><br><span class="line"></span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannel = EXTI1_IRQn;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStruture.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruture);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个端口的nvic初始化都需要用<code>NVIC_Init(&amp;NVIC_InitStruture);</code></p>
</blockquote>
<h2 id="TIM定时中断"><a href="#TIM定时中断" class="headerlink" title="TIM定时中断"></a>TIM定时中断</h2><ul>
<li>TIM（Timer）定时器<br>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</li>
<li>定时器类型<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编号</th>
<th align="center">总线</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高级定时器</td>
<td align="center">TIM1、TIM8</td>
<td align="center">APB2</td>
<td align="left">拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td>
</tr>
<tr>
<td align="center">通用定时器</td>
<td align="center">TIM2、TIM3、TIM4、TIM5</td>
<td align="center">APB1</td>
<td align="left">拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td>
</tr>
<tr>
<td align="center">基本定时器</td>
<td align="center">TIM6、TIM7</td>
<td align="center">APB1</td>
<td align="left">拥有定时中断、主模式触发DAC的功能</td>
</tr>
</tbody></table>
</li>
<li>基本计时器<br><img src="/image/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E6%97%B6%E5%99%A8.png"><ul>
<li>CNT计数器向上计数（最大值：2^16^-1）</li>
<li>只能选择内部时钟（72Hz）</li>
<li>自动重装寄存器存储计数的目标值</li>
<li>PSC预分频器可对时钟信号分频</li>
<li>UI更新中断：计数器的值与自动重装寄存器的值相同时触发，可通向NVIC</li>
<li>U更新事件：不会触发中断，但会触发内部器件的工作</li>
<li>主模式出发DAC：更新事件通过主模式映射到TAGO，然后通过TAGO触发DAC(硬件自动化)</li>
</ul>
</li>
<li>通用计时器<br><img src="/image/%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8.png"><ul>
<li>支持向上计数、向下计数、中央对齐计数</li>
<li>可以选择内部时钟和外部时钟<br>外部时钟模式1：ETRF<br>外部时钟模式2：ETR引脚、其它定时器、CH1引脚的边缘触发、CH1引脚、CH2引脚</li>
<li>输出比较电路：可用于输出PWM波形</li>
<li>输出捕获电路：</li>
</ul>
</li>
<li>高级定时器<br><img src="/image/%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8.png"><ul>
<li>可实现每个几个更新周期更新一次，相当于对更新信号做了一次分频</li>
<li>互补PWM输出</li>
<li>死区生成寄存器</li>
<li>刹车输入</li>
</ul>
</li>
<li>定时中断基本结构<br><img src="/image/%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84.png"></li>
</ul>
<h3 id="定时器定时中断"><a href="#定时器定时中断" class="headerlink" title="定时器定时中断"></a>定时器定时中断</h3><ol>
<li>打开RCC时钟</li>
<li>时钟源选择<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,</span></span><br><span class="line"><span class="params">                                <span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,</span></span><br><span class="line"><span class="params">                            <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, </span></span><br><span class="line"><span class="params">                            <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,</span></span><br><span class="line"><span class="params">                  <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure></li>
<li>配置时基单元<br><code>void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</code><blockquote>
<p>初始化时基单元后会立刻生成更新事件来重新装载预分频器和重复寄存器的值，更新中断会置更新标志位，即初始化后里刻进入中断</p>
</blockquote>
</li>
<li>配置输出中断控制，允许更新中断输出到 NVIC<br>  <code>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</code>   </li>
<li>配置nvic，打开定时器中断通道，设置优先级</li>
<li>运行控制</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extern uint16_t NUM;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_ClearFlag(TIM2, TIM_FLAG_Update);</span><br><span class="line">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);  </span><br><span class="line"></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitSructure;</span><br><span class="line">    NVIC_InitSructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">    NVIC_InitSructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitSructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">    NVIC_InitSructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitSructure);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        NUM ++;</span></span><br><span class="line"><span class="comment">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="定时器外部中断"><a href="#定时器外部中断" class="headerlink" title="定时器外部中断"></a>定时器外部中断</h3><p>基本步骤与定时中断相同，但需要配置GPIO引脚的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, <span class="number">0x00</span>);</span><br></pre></td></tr></table></figure>
<h3 id="TIM输出比较"><a href="#TIM输出比较" class="headerlink" title="TIM输出比较"></a>TIM输出比较</h3><p>输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形<br>每个高级定时器和通用定时器都拥有4个输出比较通道<br>高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p>
<ul>
<li>PWM（Pulse Width Modulation）脉冲宽度调制<br>在具有&#x3D;&#x3D;惯性的系统&#x3D;&#x3D;中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量</li>
<li>PWM参数<ul>
<li>频率：1&#x2F;T<del>S</del></li>
<li>占空比：T<del>ON</del>&#x2F;T<del>S</del></li>
<li>分辨率：占空比变化步距</li>
</ul>
</li>
<li>输出比较通路（通用）<br><img src="/image/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%94%B5%E8%B7%AF%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89png.png"></li>
<li>输出比较通路（高级）<br><img src="/image/%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%94%B5%E8%B7%AF%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89.png"></li>
<li>输出比较模式<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">冻结</td>
<td align="center">CNT&#x3D;CCR时，REF保持为原状态</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">匹配时置有效电平</td>
<td align="center">CNT&#x3D;CCR时，REF置有效电平</td>
<td align="center">高级定时器</td>
</tr>
<tr>
<td align="center">匹配时置无效电平</td>
<td align="center">CNT&#x3D;CCR时，REF置无效电平</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">匹配时电平反转</td>
<td align="center">CNT&#x3D;CCR时，REF电平翻转</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">强制为有效电平</td>
<td align="center">CNT与CCR无效，REF强制为有效电平</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">强制为无效电平</td>
<td align="center">CNT与CCR无效，REF强制为无效电平</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PWM模式1</td>
<td align="center">向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PWM模式2</td>
<td align="center">向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li>参数计算<ul>
<li>PWM频率：Freq &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</li>
<li>PWM占空比：	Duty &#x3D; CCR &#x2F; (ARR + 1)</li>
<li>PWM分辨率：	Reso &#x3D; 1 &#x2F; (ARR + 1)</li>
</ul>
</li>
</ul>
<h4 id="PWM驱动呼吸灯"><a href="#PWM驱动呼吸灯" class="headerlink" title="PWM驱动呼吸灯"></a>PWM驱动呼吸灯</h4><ol>
<li>开启RCC时钟</li>
<li>配置时基单元</li>
<li>配置输出比较单元</li>
<li>配置GPIO</li>
<li>运行控制</li>
<li>改变运行时占空比<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;   <span class="comment">// ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>; <span class="comment">// PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">    TIM_OCStructInit(&amp;TIM_OCInitStructure); <span class="comment">// 结构体内的变量没有都用到，但为了防止不赋值导致的结构体变量取值不确定或无法使用，先给结构体所有变量赋初始值</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;   <span class="comment">// CCR</span></span><br><span class="line">    TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过设置CCR来调整占空比，从而控制LED亮度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_SetCompare1(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>通过设置CCR来调整占空比，从而控制LED亮度</li>
<li>端口重映射<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2Periphclockcmnd (RCC_APB2Periph_AFIO, ENABLE);  <span class="comment">// 打开AFIO时钟</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);   <span class="comment">// 重映射引脚</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); <span class="comment">// 解除端口调试</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PWM驱动舵机"><a href="#PWM驱动舵机" class="headerlink" title="PWM驱动舵机"></a>PWM驱动舵机</h4><p>舵机的周期为20ms，频率即为50Hz，高电平取值范围0.5ms ~ 2.5ms。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span> - <span class="number">1</span>;   <span class="comment">// ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>; <span class="comment">// PSC</span></span><br></pre></td></tr></table></figure>
<ul>
<li>控制舵机角度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">    PWM_SetCompare2(Angle * <span class="number">2000</span> / <span class="number">180</span> + <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PWM驱动直流电机"><a href="#PWM驱动直流电机" class="headerlink" title="PWM驱动直流电机"></a>PWM驱动直流电机</h4><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转<br>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作<br>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    PWM_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_SetValue</span><span class="params">(<span class="type">int8_t</span> Speed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Speed &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 控制电机旋转方向 */</span></span><br><span class="line">        GPIO_SetBits(GPIOA, GPIO_Pin_4);</span><br><span class="line">        GPIO_ResetBits(GPIOA, GPIO_Pin_5);</span><br><span class="line">        <span class="comment">/* 控制电机速度 */</span></span><br><span class="line">        PWM_SetCompare3(Speed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOA, GPIO_Pin_5);</span><br><span class="line">        GPIO_ResetBits(GPIOA, GPIO_Pin_4);</span><br><span class="line">        PWM_SetCompare3(-Speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="TIM-IC（Input-Capture）输入捕获"><a href="#TIM-IC（Input-Capture）输入捕获" class="headerlink" title="TIM IC（Input Capture）输入捕获"></a>TIM IC（Input Capture）输入捕获</h3><p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数<br>每个高级定时器和通用定时器都拥有4个输入捕获通道<br>可配置为PWMI模式，同时测量频率和占空比<br>可配合主从触发模式，实现硬件全自动测量</p>
<ul>
<li>频率测量方法<ul>
<li>测频法：在闸门时间T内，对上升沿计次，得到N，则频率$𝑓_𝑥&#x3D;𝑁 &#x2F; 𝑇$</li>
<li>测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率$𝑓_𝑥&#x3D;𝑓_𝑐  &#x2F; 𝑁$<br>标准频率 &#x3D; 预分频器频率，CNT计次即为N。</li>
<li>中界频率：测频法与测周法误差相等的频率点$𝑓_𝑚&#x3D;\sqrt{𝑓_𝑐  &#x2F; 𝑇}$<blockquote>
<p>高频使用测频法，低频使用测周法</p>
</blockquote>
</li>
</ul>
</li>
<li>捕获输入通道<br>@import “image&#x2F;捕获输入通道.png”{width&#x3D;60%}</li>
<li>主从触发模式<br>@import “image&#x2F;主从触发模式.jpg”{width&#x3D;60%}</li>
<li>输入捕获基本结构<br><img src="/image/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li>
<li>PWMI基本结构<br><img src="/image/PWMI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li>
</ul>
<h4 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h4><ol>
<li>打开RCC时钟</li>
<li>GPIO初始化，配置成输入模式</li>
<li>配置时基单元，让CNT计数器在内部时钟下自增运行</li>
<li>配置输入捕获单元（滤波器、极性、直连通道或交叉通道、分频器）</li>
<li>选择触发源（TI1FP1</li>
<li>触发后的操作</li>
<li>开启定时器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM3);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;   <span class="comment">// ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>; <span class="comment">// PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span> / TIM_GetCapture1(TIM3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="TIMI模式测量频率占空比"><a href="#TIMI模式测量频率占空比" class="headerlink" title="TIMI模式测量频率占空比"></a>TIMI模式测量频率占空比</h4><ol>
<li>分别在上升沿和下降沿捕获</li>
<li>配置PWMI模式</li>
<li>测量频率和占空比<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM3);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;   <span class="comment">// ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>; <span class="comment">// PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">    TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="number">1</span>) * <span class="number">100</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="TIM编码器接口"><a href="#TIM编码器接口" class="headerlink" title="TIM编码器接口"></a>TIM编码器接口</h3><p>编码器接口可接收增量（正交）编码器信号，根据编码器的旋转产生正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向、旋转速度<br>相当于带有方向控制的外部时钟，同时控制着CNT的计数时钟和计数方向<br>每个高级定时器和通用定时器都有一个编码器接口<br>两个输入引脚借用输入捕获的通道1和通道2</p>
<ul>
<li>编码器基本结构<br><img src="/image/%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li>
<li>编码器工作模式<br><img src="/image/%E7%BC%96%E7%A0%81%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png"></li>
</ul>
<h4 id="TIM编码器接口测速"><a href="#TIM编码器接口测速" class="headerlink" title="TIM编码器接口测速"></a>TIM编码器接口测速</h4><ol>
<li>开启RCC时钟 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br></pre></td></tr></table></figure></li>
<li>配置GPIO<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置时基单元<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;   <span class="comment">// ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>; <span class="comment">// PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置输入捕获单元<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置编码器接口模式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Falling, TIM_ICPolarity_Rising);</span><br></pre></td></tr></table></figure></li>
<li>启动定时器<br><code>TIM_Cmd(TIM3,ENABLE);</code></li>
</ol>
<ul>
<li>测速<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> Temp;</span><br><span class="line">    Temp = TIM_GetCounter(TIM3);</span><br><span class="line">    TIM_SetCounter(TIM3, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Speed = Encoder_Get();</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ADC-Analog-Digital-Cocerter-模拟-数字转换器"><a href="#ADC-Analog-Digital-Cocerter-模拟-数字转换器" class="headerlink" title="ADC(Analog Digital Cocerter)模拟-数字转换器"></a>ADC(Analog Digital Cocerter)模拟-数字转换器</h2><p>ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁<br>STM32的ADC为12位逼近型ADC，转换时间需要1$\mu s$，转换频率1MHz<br>输入电压范围：0 ~ 3.3V，转换结果：0 ~ 4095<br>18个输入通道，可测量16个外部和2个内部信号源（内部温度传感器、内部参考电压1.2V）<br>&#x3D;&#x3D;规则组和注入组两个转换单元&#x3D;&#x3D;<br>模拟看门狗自动监测输入电压范围<br>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<ul>
<li>逐次逼近型ADC<br>@import “image&#x2F;逐次逼近型ADC.jpg”{width&#x3D;60%}</li>
<li>ADC框图<br><img src="/image/ADC%E6%A1%86%E5%9B%BE.png"></li>
<li>转换模式<ul>
<li>单次转换，非扫描模式</li>
<li>连续转换，非扫描模式</li>
<li>单次转换，扫描模式</li>
<li>连续转换，扫描模式</li>
</ul>
</li>
<li>数据对齐方式<ul>
<li>右对齐</li>
<li>左对齐</li>
</ul>
</li>
<li>校准<br>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。<br>校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差<br>ADC每次上电后需执行一次校准<br>启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</li>
</ul>
<h3 id="AD单通道"><a href="#AD单通道" class="headerlink" title="AD单通道"></a>AD单通道</h3><ol>
<li>开启RCC时钟<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br></pre></td></tr></table></figure></li>
<li>配置GPIO输入模式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置转换单元<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br></pre></td></tr></table></figure></li>
<li>配置ADC转换器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>开启ADC<br><code>ADC_Cmd(ADC1, ENABLE);</code></li>
<li>校准<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>得到转换值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);   <span class="comment">// 软件触发ADC</span></span><br><span class="line">    <span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) ==RESET);</span><br><span class="line">    <span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h3><h2 id="DMA-Direct-Memory-Access-直接存储器访问"><a href="#DMA-Direct-Memory-Access-直接存储器访问" class="headerlink" title="DMA(Direct Memory Access)直接存储器访问"></a>DMA(Direct Memory Access)直接存储器访问</h2><p>DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源<br>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>每个通道都支持软件触发和特定的硬件触发<br>STM32F103C8T6 DMA资源：DMA1（7个通道）</p>
<ul>
<li>存储器映像<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">起始地址</th>
<th align="center">存储器</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ROM</td>
<td align="center">0x0800 0000</td>
<td align="center">程序存储器Flash</td>
<td align="center">存储C语言编译后的程序代码</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">0x1FFF F000</td>
<td align="center">系统存储器</td>
<td align="center">存储BootLoader，用于串口下载</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">0x1FFF F800</td>
<td align="center">选项字节</td>
<td align="center">存储独立于程序代码的配置参数</td>
</tr>
<tr>
<td align="center">RAM</td>
<td align="center">0x2000 0000</td>
<td align="center">运行内存SRANM</td>
<td align="center">存储程序运行时的临时变量</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">0x4000 0000</td>
<td align="center">外设寄存器</td>
<td align="center">存储各个外设的配置参数</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">0xE000 0000</td>
<td align="center">内核外设寄存器</td>
<td align="center">存储内核各个外设的配置参数</td>
</tr>
</tbody></table>
</li>
<li>DAM基本结构<br><img src="/image/DMA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg"></li>
<li>触发源<ul>
<li>硬件触发：外设寄存器和存储器之间的数据转运</li>
<li>软件触发：存储器之间的数据转运（不可设置自动重装）</li>
</ul>
</li>
<li>传输计数器：传输计数器大于0时才转运数据（可设置自动重装来连续触发）</li>
<li>DMA开关控制</li>
<li>DMA请求<br><img src="/image/DMA%E8%AF%B7%E6%B1%82.png"></li>
<li>数据宽度与对齐<ul>
<li>若数据宽度一样：正常转运</li>
<li>小数据到大数据：高位补0</li>
<li>大数据到小数据：高位舍弃</li>
</ul>
</li>
</ul>
<h3 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运 + DMA"></a>数据转运 + DMA</h3><ol>
<li>开启RCC的DMA时钟<br><code>RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</code><blockquote>
<p>DMA外设在AHB上</p>
</blockquote>
</li>
<li>初始化DAM的参数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = Size;  <span class="comment">// 传输计数器</span></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  <span class="comment">// 传输方向</span></span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;   <span class="comment">// 触发源选择</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;</span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>开关控制<br><code>DMA_Cmd(DMA1_Channel1, DISABLE);</code></li>
</ol>
<ul>
<li>数据转运<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">    DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);  <span class="comment">// 只能在DMA关闭状态下 才能设置传输计数器</span></span><br><span class="line">    DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET); <span class="comment">// 等待转换完成</span></span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG_TC1);   <span class="comment">// 需要手动清除标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式 + DMA"></a>ADC扫描模式 + DMA</h3><ol>
<li>开启RCC时钟<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br></pre></td></tr></table></figure></li>
<li>配置ADC时钟<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br></pre></td></tr></table></figure></li>
<li>配置GPIO<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置转换单元<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_4, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br></pre></td></tr></table></figure></li>
<li>配置ADC转换器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE;</span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置DMA传输模式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;</span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value;  <span class="comment">// 传输目标地址</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR; <span class="comment">// ADC转换后的值所处地址</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>开关控制<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1, ENABLE);</span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br></pre></td></tr></table></figure></li>
<li>ADC校准<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>转换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">    DMA_SetCurrDataCounter(DMA1_Channel1, <span class="number">4</span>);</span><br><span class="line">    DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line"></span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ADC连续扫描 + DMA循环运转<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>转换一直进行，直接读取即可得转换和转移后的数据。转换部分代码不再需要</p>
</blockquote>
</li>
</ul>
<h2 id="USART串口通信"><a href="#USART串口通信" class="headerlink" title="USART串口通信"></a>USART串口通信</h2><ul>
<li>通信协议<table>
<thead>
<tr>
<th>名称</th>
<th>引脚</th>
<th>双工</th>
<th>时钟</th>
<th>电平</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td>USART</td>
<td>TX、RX</td>
<td>全双工</td>
<td>异步</td>
<td>单端</td>
<td>点对点</td>
</tr>
<tr>
<td>I2C</td>
<td>SCL、SDA</td>
<td>半双工</td>
<td>同步</td>
<td>单端</td>
<td>多设备</td>
</tr>
<tr>
<td>SPI</td>
<td>SCLK、MOSI、MISO、CS</td>
<td>全双工</td>
<td>同步</td>
<td>单端</td>
<td>多设备</td>
</tr>
<tr>
<td>CAN</td>
<td>CAN_H、CAN_L</td>
<td>半双工</td>
<td>异步</td>
<td>差分</td>
<td>多设备</td>
</tr>
<tr>
<td>USB</td>
<td>DP、DM</td>
<td>半双工</td>
<td>异步</td>
<td>差分</td>
<td>点对点</td>
</tr>
</tbody></table>
</li>
<li>串口通信<br>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力<br>简单双向串口通信有两根通信线（发送端TX和接收端RX）<br>TX与RX要交叉连接<br>当只需单向的数据传输时，可以只接一根通信线<br>当电平标准不一致时，需要加电平转换芯片<ul>
<li>电平标准<br>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：<ul>
<li>TTL电平：+3.3V或+5V表示1，0V表示0</li>
<li>RS232电平：-3<del>-15V表示1，+3</del>+15V表示0</li>
<li>RS485电平：两线压差+2<del>+6V表示1，-2</del>-6V表示0（差分信号）</li>
</ul>
</li>
<li>串口参数与时序<br>波特率：串口通信的速率<br>起始位：标志一个数据帧的开始，固定为低电平<br>数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行<br>校验位：用于数据验证，根据数据位计算得来（奇偶校验）<br>停止位：用于数据帧间隔，固定为高电平</li>
</ul>
</li>
<li>USARTUniversal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器<br>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里<br>自带波特率发生器，最高达4.5Mbits&#x2F;s<br>可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2）<br>可选校验位（无校验&#x2F;奇校验&#x2F;偶校验）<br>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN<br>STM32F103C8T6 USART资源： USART1、 USART2、 USART3</li>
<li>USART框图<br><img src="/image/USART%E6%A1%86%E5%9B%BE.jpg"></li>
<li>波特率发生器<br>发送器和接收器的波特率由波特率寄存器BRR里的DIV确定<br>计算公式：波特率 &#x3D; fPCLK2&#x2F;1 &#x2F; (16 * DIV)</li>
</ul>
<h3 id="串口发送"><a href="#串口发送" class="headerlink" title="串口发送"></a>串口发送</h3><ol>
<li>开启RCC时钟（GPIO，USART）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br></pre></td></tr></table></figure></li>
<li>GPIO初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置USART<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Tx;</span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);</span><br></pre></td></tr></table></figure></li>
<li>配置中断（接收时）</li>
<li>开关控制<br><code>USART_Cmd(USART1, ENABLE);</code></li>
</ol>
<ul>
<li>发送功能实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendBit</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line"> &#123;</span><br><span class="line">     USART_SendData(USART1, Byte);</span><br><span class="line">     <span class="keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">uint8_t</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">     &#123;</span><br><span class="line">         USART_SendData(USART1, Array[i]);</span><br><span class="line">         <span class="keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">uint8_t</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">     &#123;</span><br><span class="line">         USART_SendData(USART1, String[i]);</span><br><span class="line">         <span class="keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">uint32_t</span> Resualt = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(Y --)</span><br><span class="line">     &#123;</span><br><span class="line">         Resualt *= X;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Resualt;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Serial_Send_Number</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint32_t</span> Length)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">uint8_t</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">     &#123;</span><br><span class="line">         Serial_SendBit((Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>)) % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>printf功能移植<ul>
<li>在keil中打开MicroLIB</li>
</ul>
<ol>
<li>对printf打印功能重定向，使其输出到串口 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    Serial_SendBit(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只能重定向一个串口</p>
</blockquote>
</li>
<li>格式化打印 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String, <span class="string">&quot;Num:%d\r\n&quot;</span>, <span class="number">666</span>);</span><br><span class="line">Serial_SendString(String);</span><br></pre></td></tr></table></figure></li>
<li>封装格式化打印,利用<a href="/C_Study_Note.md#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, format);</span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    Serial_SendString(String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="串口接收"><a href="#串口接收" class="headerlink" title="串口接收"></a>串口接收</h3><ol>
<li>查询<br>不断查询RXNE标志位。若标志位为1，则表示接收了数据，直接调用<code>ReciveData</code>读取DR寄存器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == SET)</span><br><span class="line">&#123;</span><br><span class="line">	RxData = USART_ReceiveData(USART1);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>中断<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == SET)</span><br><span class="line">     &#123;</span><br><span class="line">         Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">         Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">         USART_ClearFlag(USART1, USART_FLAG_RXNE);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="USART串口收发数据包"><a href="#USART串口收发数据包" class="headerlink" title="USART串口收发数据包"></a>USART串口收发数据包</h3><p>在数据包前后加上包头和包尾以识别数据包的起始与结束。<br>载荷数据与包头包尾重复会导致数据识别错误。</p>
<ul>
<li>解决方案：<ul>
<li>对载荷数据进行限幅，使载荷数据与包头包尾不同</li>
<li>使用固定长度的数据包</li>
<li>增加包头和包尾的长度</li>
</ul>
</li>
<li>数据包接收（状态机表示）<br>@import “image&#x2F;接收数据状态转移.jpg”{width&#x3D;70%}</li>
</ul>
<h4 id="串口收发HEX数据包"><a href="#串口收发HEX数据包" class="headerlink" title="串口收发HEX数据包"></a>串口收发HEX数据包</h4><ol>
<li>定义缓冲区</li>
<li>发送数据包</li>
<li>接收数据包(状态转移)  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> Serial_RxState = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> Serial_RxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Serial_RxState == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Serial_RxState = <span class="number">1</span>;</span><br><span class="line">                Serial_RxNum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Serial_RxState == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Serial_RxPacket[Serial_RxNum] = RxData;</span><br><span class="line">            Serial_RxNum ++;</span><br><span class="line">            <span class="keyword">if</span>(Serial_RxNum &gt;= <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Serial_RxState = <span class="number">2</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Serial_RxState == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(RxData == <span class="number">0xFE</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Serial_RxState = <span class="number">0</span>;</span><br><span class="line">                Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        USART_ClearFlag(USART1, USART_FLAG_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="串口收发文本数据包"><a href="#串口收发文本数据包" class="headerlink" title="串口收发文本数据包"></a>串口收发文本数据包</h4><p>收数据包状态转移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == SET)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Serial_RxState == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>) <span class="comment">// 避免数据包错位</span></span><br><span class="line">        &#123;</span><br><span class="line">            Serial_RxState = <span class="number">1</span>;</span><br><span class="line">            Serial_RxNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Serial_RxState == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Serial_RxState = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Serial_RxPacket[Serial_RxNum] = RxData;</span><br><span class="line">            Serial_RxNum ++;</span><br><span class="line">        &#125;                     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Serial_RxState == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Serial_RxState = <span class="number">0</span>;</span><br><span class="line">            Serial_RxPacket[Serial_RxNum] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    USART_ClearFlag(USART1, USART_FLAG_RXNE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FlyMcu串口下载"><a href="#FlyMcu串口下载" class="headerlink" title="FlyMcu串口下载"></a>FlyMcu串口下载</h3><ol>
<li>在工程中生成.HEX文件</li>
<li>配置BOOT引脚：将BOOT0置1</li>
<li>复位后可以下载程序到单片机中</li>
</ol>
<ul>
<li>选项字节<ul>
<li>读保护</li>
<li>写保护</li>
<li>硬件参数</li>
<li>用户参数</li>
</ul>
</li>
</ul>
<h3 id="STLINK-Utility"><a href="#STLINK-Utility" class="headerlink" title="STLINK Utility"></a>STLINK Utility</h3><h2 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h2><p>目的：通过通信线读写外挂模块寄存器（在指定的位置写寄存器和读寄存器）</p>
<ul>
<li>I2C(Inter－Integrated Circuit)<br>需要两根信号线完成信息交换，SCL(Serial Clock)时钟信号线，SDA(Serial Data)数据输入&#x2F;输出线<br>属于同步通信，由于输入输出数据均使用一根线，因此通信方向为半双工<br>一个I2C理论上最多可挂载127个设备，但除去保留地址，最多可挂载112个设备<br>有一主多从和多主多从两个模式</li>
<li>硬件电路<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF.jpg"><br>所有设备的SCL线连接在一起（SCL由CPU控制），SDA线连在一起<br>设备的SCL和SDA均要配置成开漏输出模式<br>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右<br>设备输出低电平时，三极管导通，输出为低电平<br>设备不输出低电平时，三极管断开，此时电压有上拉电阻控制，上拉为高电平。即设备不输出时的闲置状态都为高电平<blockquote>
<p>开漏加上拉电阻的输出模式杜绝了电源短路的风险，保证电路的安全<br>避免了引脚模式的频繁切换<br>线与线像：只要有一个设备输出低电平，总线就处于低电平。只有所有设备都输出高电平，总线才处于高电平</p>
</blockquote>
</li>
<li>I2C时序基本单元<ul>
<li>起始条件：SCL高电平期间，SDA从高电平变换到低电平</li>
<li>终止条件：SCL高电平期间，SDA从低电平变换到高电平</li>
<li>发送字节<br><img src="/image/I2C%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82.jpg"><br>SCL低电平期间，主机将数据依次放到SDA总线上（高位先行），然后释放SCL。<br>从机在SCL高电平期间接收数据位，在接受时SDA不允许有数据变化。<br>循环8次发送一个字节。</li>
<li>接收一个字节<br>SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL。<br>主机将在SCL高电平期间读取数据位，期间SDA不允许有数据变化。<br>依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）。</li>
<li>发送应答<br>主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</li>
<li>接收应答<br>主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答。<br>数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</li>
</ul>
</li>
<li>I2C时序<ul>
<li>指定地址写数据<br>对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）。<br>流程：发送7位设备地址位+1位读写位（0），判断从机应答。然后发送寄存器地址或指令控制地址，从机应答。发送数据，停止。</li>
<li>当前地址读数据<br>对于指定设备（Slave Address），在&#x3D;&#x3D;当前指针指示&#x3D;&#x3D;的地址下读取从机数据。</li>
<li>指定地址读数据<br>对于指定设备（Slave Address），在指定的地址下，读取从机数据（Data）。<br>流程：发送7位设备地址位+1位读写位（0），判断从机应答。然后发送寄存器地址或指令控制地址，从机应答。再重复起始，发送数据，停止。<br>如要连续读写，主机在接收数据后发送应答信号，从机则继续发送数据；若发送非应答信号，则从机停止发送数据。</li>
</ul>
</li>
<li>缺点：高电平驱动能力比较弱，时钟上升沿耗时比较长，限制I2C的最大通信速度。</li>
</ul>
<h3 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h3><p>MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景<a href="%5BMPU6050%E4%BA%A7%E5%93%81%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/PS-MPU-6000A.pdf)">^3</a><br>3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度，静态稳定，动态不稳定<br>3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度，动态稳定，静态不稳定</p>
<ul>
<li>参数<br>16位ADC采集传感器的模拟信号，量化范围：$-32768~32767$<br>加速度计满量程选择：$±2、±4、±8、±16（g）$<br>陀螺仪满量程选择： $±250、±500、±1000、±2000(°&#x2F;sec)$<br>可配置的数字低通滤波器<br>可配置的时钟源<br>可配置的采样分频<br>I2C从机地址：<br>1101000（AD0&#x3D;0）<br>  1101001（AD0&#x3D;1）</li>
<li>硬件电路<br><img src="/image/MPU6050%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF.jpg"><table>
<thead>
<tr>
<th>引脚</th>
<th>描述</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>VCC、GND</td>
<td>电源</td>
<td>供电</td>
</tr>
<tr>
<td>SCL、SDA</td>
<td>I2C通信引脚</td>
<td>作为从设备进行通信</td>
</tr>
<tr>
<td>XCL、XDA</td>
<td>主机i2c通信引脚</td>
<td>扩展外接其他芯片（磁力计或气压计）</td>
</tr>
<tr>
<td>AD0</td>
<td>从机地址最低位</td>
<td>改变从机地址</td>
</tr>
<tr>
<td>INT</td>
<td>中断信号输出</td>
<td>触发中断</td>
</tr>
</tbody></table>
<ul>
<li>LDO稳压电路：获取稳定的$3.3V$供电</li>
</ul>
</li>
<li>内部结构<br><img src="/image/MPU6050%E6%A1%86%E5%9B%BE.png"></li>
<li>寄存器操作<a href="%5BMPU6050%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%83%8F%5D(/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/RM-MPU-6000A.pdf)">^4</a><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td>SMPLRT_DIV</td>
<td>采样频率分频器</td>
<td align="left"></td>
</tr>
<tr>
<td>CONFIG</td>
<td>配置寄存器外部</td>
<td align="left">同步和低通滤波器</td>
</tr>
<tr>
<td>CYRO_CONFIG</td>
<td>陀螺仪配置寄存器</td>
<td align="left">自测和量程选择</td>
</tr>
<tr>
<td>ACCEL_CONFIG</td>
<td>加速度计配置寄存器</td>
<td align="left">自测、量程选择、高通滤波器</td>
</tr>
<tr>
<td>ACCEL_XOUT_H</td>
<td>加速度计XYZ轴数据（_l低8位，_H高8位）</td>
<td align="left"></td>
</tr>
<tr>
<td>ACCEL_XOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>ACCEL_YOUT_H</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>ACCEL_YOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>ACCEL_ZOUT_H</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>ACCEL_ZOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>TEMP_OUT_H</td>
<td>温度传感器数据</td>
<td align="left"></td>
</tr>
<tr>
<td>TEMP_OUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_XOUT_H</td>
<td>陀螺仪XYZ数据</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_XOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_YOUT_H</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_YOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_ZOUT_H</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>GYRO_ZOUT_L</td>
<td>^</td>
<td align="left"></td>
</tr>
<tr>
<td>PWR_MGMT_1</td>
<td>电源管理寄存器</td>
<td align="left">复位，睡眠，循环，温度传感器失能，系统时钟选择</td>
</tr>
<tr>
<td>PWR_MGMT_2</td>
<td>^</td>
<td align="left">睡眠唤醒，6个轴待机选择</td>
</tr>
<tr>
<td>WHO_AM_I</td>
<td>器件ID号</td>
<td align="left">I2C地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="软件I2C读写MPU6050"><a href="#软件I2C读写MPU6050" class="headerlink" title="软件I2C读写MPU6050"></a>软件I2C读写MPU6050</h3><ol>
<li>配置I2C模块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 设置SCL的高低电平 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue);</span><br><span class="line">    Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置SDA的高低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue);</span><br><span class="line">    Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 读取SDA的值*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> BitValue;</span><br><span class="line">    BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);</span><br><span class="line">    Delay_us(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> BitValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">  </span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">  </span><br><span class="line">  GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 起始条件 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 终止条件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 发送一个字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendBit</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">        MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">        MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 接受一个字节 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveBit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i, Byte = <span class="number">0x00</span>;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(MyI2C_R_SDA() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Byte |= (<span class="number">0x80</span> &gt;&gt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 发送应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(AckBit);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 接收应答信号*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> AckBit;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    AckBit = MyI2C_R_SDA();</span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>配置MPU模块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_REG.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS     0xD0    <span class="comment">// MPU6050设备的地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_writeReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_Start();      <span class="comment">// 启动</span></span><br><span class="line">    MyI2C_SendBit(MPU6050_ADDRESS);     <span class="comment">// 发送要写数据的设备地址</span></span><br><span class="line">    MyI2C_ReceiveAck();     <span class="comment">// 接受设备应答</span></span><br><span class="line">    MyI2C_SendBit(RegAddress);  <span class="comment">// 发送读取设备寄存器的地址</span></span><br><span class="line">    MyI2C_ReceiveAck();     <span class="comment">// 接受设备应答</span></span><br><span class="line">    MyI2C_SendBit(Data);    <span class="comment">// 发送数据</span></span><br><span class="line">    MyI2C_ReceiveAck();     <span class="comment">// 接受设备应答，判断是否继续发送数据</span></span><br><span class="line">    MyI2C_Stop();       <span class="comment">// 停止发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Data;</span><br><span class="line">    MyI2C_Start();      <span class="comment">// 启动</span></span><br><span class="line">    MyI2C_SendBit(MPU6050_ADDRESS);  <span class="comment">// 发送操作指定设备的命令</span></span><br><span class="line">    MyI2C_ReceiveAck();     <span class="comment">// 接受设备应答</span></span><br><span class="line">    MyI2C_SendBit(RegAddress);      <span class="comment">// 发送操作设备寄存器的地址</span></span><br><span class="line">    MyI2C_ReceiveAck();     <span class="comment">// 接受设备应答</span></span><br><span class="line"></span><br><span class="line">    MyI2C_Start();      <span class="comment">// 重新启动，接收数据</span></span><br><span class="line">    MyI2C_SendBit(MPU6050_ADDRESS | <span class="number">0x01</span>); <span class="comment">// 向设备发送读取命令</span></span><br><span class="line">    MyI2C_ReceiveAck();</span><br><span class="line">    Data = MyI2C_ReceiveBit();  <span class="comment">// 读取数据</span></span><br><span class="line">    MyI2C_SendAck(<span class="number">1</span>);       <span class="comment">// 发送是否继续读取数据的命令</span></span><br><span class="line">    MyI2C_Stop();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*MPu6050初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_Init();</span><br><span class="line">    MPU6050_writeReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);     <span class="comment">// 接除睡眠，选择陀螺仪时钟</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);     <span class="comment">// 6个轴均不待机</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);     <span class="comment">// 采样分频位10</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_CONFIG, <span class="number">0x06</span>);         <span class="comment">// 外部不同步，平滑滤波</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);    <span class="comment">// 不自测，最大量程</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);   <span class="comment">// 不自测，最大量程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取传感器的值（由于要返回多个传感器的值，不能直接返回，需用指针或结构体来返回所需值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params">                    <span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Data_H, Data_L;</span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">    *AccX = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">    *AccY = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">    *AccZ = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">    *GyroX = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">    *GyroY = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">    *GyroZ = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="STM32Z中I2C通信外设"><a href="#STM32Z中I2C通信外设" class="headerlink" title="STM32Z中I2C通信外设"></a>STM32Z中I2C通信外设</h3><p>STM32内部集成了硬件I2C收发电路，可以有硬件自动执行时钟生成，起始终止条件生成、应答收发、数据收发等功能。<br>支持多主机模型（多主多从，可变多主机）<br>支持7位&#x2F;10位地址模式<br>支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)<br>支持DMA<br>兼容SMBus协议<br>STM32F103C8T6 硬件I2C资源：I2C1、I2C2</p>
<ul>
<li>I2C框图<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E6%A1%86%E5%9B%BE.png"><ul>
<li>数据寄存器存放要发送的数据和接收的数据。数据从数据寄存器移入移位寄存器后，置TXE标志位为1，即发送寄存器为空，可以放数据。</li>
<li>移位寄存器发送和接收数据。数据收齐后从移位寄存器转入数据寄存器，置RXNE为1，表示发送寄存器非空，可以取数据。</li>
<li>数据控制：控制着I2C的通信流程</li>
</ul>
</li>
<li>主机发送<br><img src="/image/I2C%E7%A1%AC%E4%BB%B6%E4%B8%BB%E6%9C%BA%E5%8F%91%E9%80%81.png"></li>
<li>主机接受<br><img src="/IMAGE/I2C%E7%A1%AC%E4%BB%B6%E4%B8%BB%E6%9C%BA%E6%8E%A5%E5%8F%97.png"></li>
</ul>
<h4 id="硬件I2C读写数据"><a href="#硬件I2C读写数据" class="headerlink" title="硬件I2C读写数据"></a>硬件I2C读写数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_REG.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS     0xD0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 超时等待， 如果函数执行错误或超时，则直接退出（可替代为错误处理模块）*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Timeout = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        Timeout --;</span><br><span class="line">        <span class="keyword">if</span>(Timeout == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写寄存器操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_writeReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);      <span class="comment">// I2C通信主模式选择（EV5）</span></span><br><span class="line"></span><br><span class="line">    I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);    <span class="comment">// 等待发送模式选择完成（EV6）</span></span><br><span class="line"></span><br><span class="line">    I2C_SendData(I2C2, RegAddress);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);    <span class="comment">// EV8_2</span></span><br><span class="line"></span><br><span class="line">    I2C_SendData(I2C2, Data);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);     <span class="comment">// 等待数据发送完成（EV8）</span></span><br><span class="line"></span><br><span class="line">    I2C_GenerateSTOP(I2C2, ENABLE);     <span class="comment">// 停止发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);</span><br><span class="line"></span><br><span class="line">    I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);</span><br><span class="line"></span><br><span class="line">    I2C_SendData(I2C2, RegAddress);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);</span><br><span class="line"></span><br><span class="line">    I2C_GenerateSTART(I2C2, ENABLE);    <span class="comment">// 重启动</span></span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);</span><br><span class="line"></span><br><span class="line">    I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Receiver);</span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);   <span class="comment">// EV6</span></span><br><span class="line"></span><br><span class="line">    I2C_AcknowledgeConfig(I2C2, DISABLE);</span><br><span class="line">    I2C_GenerateSTOP(I2C2, ENABLE);</span><br><span class="line"></span><br><span class="line">    MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);        <span class="comment">// EV6_1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> Data = I2C_ReceiveData(I2C2);</span><br><span class="line"></span><br><span class="line">    I2C_AcknowledgeConfig(I2C2, DISABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class="line">    I2C_InitStructure.I2C_ClockSpeed = <span class="number">50000</span>;</span><br><span class="line">    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;  <span class="comment">// 在高频模式下为低电平分配更多的资源，已完成数据的改变</span></span><br><span class="line">    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">    I2C_InitStructure.I2C_OwnAddress1 = <span class="number">0x00</span>;</span><br><span class="line">    I2C_Init(I2C2, &amp;I2C_InitStructure);</span><br><span class="line"></span><br><span class="line">    I2C_Cmd(I2C2, ENABLE);</span><br><span class="line"></span><br><span class="line">    MPU6050_writeReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);     <span class="comment">// 接除睡眠，选择陀螺仪时钟</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);     <span class="comment">// 6个轴均不待机</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);     <span class="comment">// 采样分频位10</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_CONFIG, <span class="number">0x06</span>);         <span class="comment">// 外部不同步，平滑滤波</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);    <span class="comment">// 不自测，最大量程</span></span><br><span class="line">    MPU6050_writeReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);   <span class="comment">// 不自测，最大量程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params">                    <span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Data_H, Data_L;</span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">    *AccX = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">    *AccY = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">    *AccZ = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">    *GyroX = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">    *GyroY = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line"></span><br><span class="line">    Data_H = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">    Data_L = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">    *GyroZ = (Data_H &lt;&lt; <span class="number">8</span>) | Data_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SPI（serial-peripheral-interface）通信"><a href="#SPI（serial-peripheral-interface）通信" class="headerlink" title="SPI（serial peripheral interface）通信"></a>SPI（serial peripheral interface）通信</h2><p>SPI通信是一种同步式串行通信，它可以在同一时间发送和接收数据，常用于EEPROM或传感器等外围设备与主控制器之间的数据交换。<br>SPI通信需要四根线，分别是时钟（SCLK）、数据输入（SIN）、数据输出（SOUT）和片选（CS）</p>
<ul>
<li><p>工作原理<br>主控制器（Master）通过时钟线（SCLK）向外围设备（Slave）发送时钟信号，同时通过数据输出线（SOUT）发送数据，外围设备通过数据输入线（SIN）接收数据。<br>反之，外围设备也可以通过SOUT发送数据，主控制器通过SIN接收数据。片选线（CS）用于选择要通信的外围设备，一般由主控制器控制。</p>
</li>
<li><p>优点<br>SPI通信的优点是速度快，全双工，硬件简单，不需要地址识别。</p>
</li>
<li><p>缺点<br>SPI通信的缺点是需要多根线，不适合长距离传输，不支持多主控制器，需要额外的片选线来区分不同的外围设备。</p>
</li>
<li><p>硬件电路<br>输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入</p>
</li>
<li><p>起始条件：CS从高电平切换为低电平</p>
</li>
<li><p>终止条件：CS从低电平切换为高电平</p>
</li>
<li><p>SPI时序</p>
<ul>
<li>CPOL(clock plority)时钟极性<ul>
<li>CPOL&#x3D;0的时候是上升沿采集数据。SCLK在空闲时为低电平。</li>
<li>CPOL&#x3D;1的时候是下降沿采集数据。SCLK在空闲时为高电平。</li>
</ul>
</li>
<li>CPHA(clock phase)时钟相位<ul>
<li>CPOL&#x3D;0的时候是第一次跳变沿采集数据。</li>
<li>CPOL&#x3D;1的时候是第二次跳变沿采集数据。</li>
</ul>
</li>
<li>模式<ul>
<li>模式0（CPOL &#x3D; 0; CPHA &#x3D; 0）<br>时钟空闲时为低电平，第一个跳变沿为上升沿，第二个跳变沿为下降沿。在第一次跳变时采集数据，即上升沿采集数据</li>
<li>模式1（CPOL &#x3D; 0; CPHA &#x3D; 1）<br>时钟空闲时为低电平，第一个跳变沿为上升沿，第二个跳变沿为下降沿。在第二次跳变时采集数据，即在下降沿采集数据</li>
<li>模式2（CPOL &#x3D; 1; CPHA &#x3D; 0）<br>时钟空闲时为高电平，第一个跳变沿为下降沿，第二个跳变沿为上升沿。在第一次跳变时采集数据，即下降沿采集数据</li>
<li>模式3（CPOL &#x3D; 1; CPHA &#x3D; 1）<br>时钟空闲时为高电平，第一个跳变沿为下降沿，第二个跳变沿为上升沿。在第二次跳变时采集数据，即下降沿采集数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Flash操作</p>
<ul>
<li>写入操作时：<br>写入操作前，必须先进行写使能<br>每个数据位只能由1改写为0，不能由0改写为1<br>写入数据前必须先擦除，擦除后，所有数据位变为1<br>擦除必须按最小擦除单元（一个扇区，4kb，4096字节）进行<br>连续写入多字节时，最多写入一页（256字节）的数据，超过页尾位置的数据，会回到页首覆盖写入<br>写入操作结束后，芯片进入忙状态，不响应新的读写操作</li>
<li>读取操作时：<br>直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取</li>
</ul>
</li>
</ul>
<h3 id="软件SPI读写W25Q64"><a href="#软件SPI读写W25Q64" class="headerlink" title="软件SPI读写W25Q64"></a>软件SPI读写W25Q64</h3><ul>
<li>SPI通信模块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置CS的电平 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_CS</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置MOSI的电平 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置CLK的电平 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_CLK</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置MISO的电平 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引脚初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">// 配置CLK、MISO、CS为推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;   <span class="comment">// 配置MISO为上拉输入</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    MySPI_W_CS(<span class="number">1</span>);    <span class="comment">// 片选默认值为高电平，低电平时选中从机开始数据传输</span></span><br><span class="line">    MySPI_W_CLK(<span class="number">0</span>);  <span class="comment">// 模式0：CLK空闲时为高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI时序开始标志 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySPI_W_CS(<span class="number">0</span>);  <span class="comment">// 片选信号为低电平，选中从机开始数据传输</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI时序结束标志 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySPI_W_CS(<span class="number">1</span>);  <span class="comment">// 片选信号为高电平，为选中从机，不传输数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI时序交换字节 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> SendByte)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i, ReceiveByte = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        MySPI_W_MOSI(SendByte &amp; (<span class="number">0x80</span> &gt;&gt; i));   <span class="comment">// 通过掩码，依次对每一位进行操作</span></span><br><span class="line">        MySPI_W_CLK(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(MySPI_R_MISO() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ReceiveByte |= (<span class="number">0x80</span> &gt;&gt; i); </span><br><span class="line">        &#125;</span><br><span class="line">        MySPI_W_CLK(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReceiveByte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>W25Q64读写数据模块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取设备ID号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span> *MID, <span class="type">uint16_t</span> *DID)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySPI_Start();  <span class="comment">// 开始标志</span></span><br><span class="line">    MySPI_SwapByte(W25Q64_JEDEC_ID);  <span class="comment">// 发送读取设备ID的指令</span></span><br><span class="line">    *MID = MySPI_SwapByte(W25Q62_DUMMY_BYTE);   <span class="comment">// 读取厂商ID</span></span><br><span class="line">    *DID = MySPI_SwapByte(W25Q62_DUMMY_BYTE);   <span class="comment">// 读取设备ID高8位</span></span><br><span class="line">    *DID &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">    *DID |= MySPI_SwapByte(W25Q62_DUMMY_BYTE);  <span class="comment">// 读取设备ID低8位</span></span><br><span class="line">    MySPI_Stop();   <span class="comment">// 结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入使能（W25Q64默认不能写入数据）*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q62_WriteEnable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MySPI_Start();</span><br><span class="line">    MySPI_SwapByte(W25Q64_WRITE_ENABLE);  <span class="comment">// 发送写入使能指令</span></span><br><span class="line">    MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待忙状态结束 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Timeout = <span class="number">100000</span>;</span><br><span class="line">    MySPI_Start();</span><br><span class="line">    MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);  <span class="comment">// 发送读取状态寄存器指令</span></span><br><span class="line">    <span class="keyword">while</span> ((MySPI_SwapByte(W25Q62_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Timeout --;</span><br><span class="line">        <span class="keyword">if</span>(Timeout == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向指定页写入数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint16_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    W25Q62_WriteEnable();</span><br><span class="line">    MySPI_Start();</span><br><span class="line">    MySPI_SwapByte(W25Q64_PAGE_PROGRAM);  <span class="comment">// 发送页写入指令</span></span><br><span class="line">    <span class="comment">/* 发送写入地址 */</span></span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    MySPI_SwapByte(Address);</span><br><span class="line">    <span class="comment">/* 写入数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; Count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        MySPI_SwapByte(DataArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    MySPI_Stop();</span><br><span class="line">    </span><br><span class="line">    W25Q64_WaitBusy();  <span class="comment">// 事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扇区擦除 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">    W25Q62_WriteEnable();</span><br><span class="line">    MySPI_Start();</span><br><span class="line">    MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    MySPI_SwapByte(Address);</span><br><span class="line">       </span><br><span class="line">    W25Q64_WaitBusy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint32_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    MySPI_Start();</span><br><span class="line">    MySPI_SwapByte(W25Q64_READ_DATA);   <span class="comment">// 发送读取数据指令</span></span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    MySPI_SwapByte(Address);</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; Count; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        DataArray[i] = MySPI_SwapByte(W25Q62_DUMMY_BYTE);</span><br><span class="line">    &#125;</span><br><span class="line">    MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>PID(proportion integration differentiation)其实就是指比例，积分，微分控制。</p>
<ul>
<li><p>连续型：<br>$$U(t) &#x3D; k_P(err(t) + \frac {1}{T_{I}} \int \operatorname {err}(t)dt + \frac {T_{D}derr(t)}{dt})$$<br>$K_p$：比例增益，是调适参数；<br>$K_I &#x3D; \frac {1} {T_{I}} $：积分增益，也是调适参数；<br>$K_D &#x3D; T_{D}$：微分增益，也是调适参数；<br>err：误差&#x3D;设定值（SP）- 回授值（PV）；<br>t：目前时间。</p>
</li>
<li><p>离散型：<br>$$U(k)&#x3D;K_{P}(err(k)+ \frac{T}{T_{I}}\sum err(k)+ \frac{T_{D}}{T}(err(k)-err(k-1)))$$</p>
<blockquote>
<p>比例增益将误差线性放大，微分环增益将误差的变化率放大，积分增益将过去误差值的总和放大</p>
</blockquote>
<ul>
<li>位置型<br>$$U(k)&#x3D;K_{p}err(k)+K_{i}\sum err(k)+K_{d}(err(k)-err(k-1))$$<blockquote>
</blockquote>
</li>
<li>增量型<br>$$ \Delta U(k)&#x3D;K_{p}(err(k)-err(k-1))+K_{i}err(k)+K_{d}(err(k)-2err(k-1)+err(k-2))$$<blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>比例控制：<br>比例增益的作用是对偏差瞬间作出反应。<br>偏差一旦产生控制器立即产生控制作用， 使控制量向减少偏差的方向变化。<br>控制作用的强弱取决于比例系数Kp， 比例系数Kp越大，控制作用越强， 则过渡过程越快， 控制过程的静态偏差也就越小；<br>但是Kp越大，也越容易产生振荡， 破坏系统的稳定性。<br>缺点：存在稳态误差。</p>
</li>
<li><p>积分控制：<br>能够消除稳态误差，但会超调，即在设定值附近来回抖动。<br>缺点：存在饱和效应。在非线性系统中需要判断执行器是否达到饱和状态（判断执行器的输入和输出是否相等以及执行器的输入符号和误差的符号是否相等）</p>
</li>
<li><p>微分控制：<br>它是根据偏差的变化趋势（变化速度）进行控制。偏差变化的越快，微分控制器的输出就越大，并能在偏差值变大之前进行修正。<br>产生刹车效应。可以解决超调现象，但会降低达到预设值的速度<br>缺点：噪声会对微分分控制有很大的影响，需要滤掉频率较高的噪声。</p>
</li>
</ul>
<blockquote>
<p>需要调节这三条控制路径的增益，来达到稳定的控制效果</p>
</blockquote>
<h3 id="PID代码实现"><a href="#PID代码实现" class="headerlink" title="PID代码实现"></a>PID代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> SetValue;            <span class="comment">//定义设定值</span></span><br><span class="line">    <span class="type">float</span> ActualValue;        <span class="comment">//定义实际值</span></span><br><span class="line">    <span class="type">float</span> err;                <span class="comment">//定义当前偏差值</span></span><br><span class="line">    <span class="type">float</span> err_1;            <span class="comment">//定义上一个偏差值</span></span><br><span class="line">    <span class="type">float</span> err_2;</span><br><span class="line">    <span class="type">float</span> Kp, Ki, Kd;            <span class="comment">//定义比例、积分、微分系数</span></span><br><span class="line">    <span class="type">float</span> Actuator;          <span class="comment">//定义电压值（控制执行器的变量）</span></span><br><span class="line">    <span class="type">float</span> integral;            <span class="comment">//定义积分值</span></span><br><span class="line">&#125;PIDTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_init</span><span class="params">(PIDTypeDef *PID)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID_init begin \n&quot;</span>);</span><br><span class="line">    PID.SetValue = <span class="number">0.0</span>;</span><br><span class="line">    PID.ActualValue = <span class="number">0.0</span>;</span><br><span class="line">    PID.err = <span class="number">0.0</span>;</span><br><span class="line">    PID.err_1 = <span class="number">0.0</span>;</span><br><span class="line">    PID.Actuator = <span class="number">0.0</span>;</span><br><span class="line">    PID.integral = <span class="number">0.0</span>;</span><br><span class="line">    PID.Kp = <span class="number">0.2</span>;</span><br><span class="line">    PID.Ki = <span class="number">0.015</span>;</span><br><span class="line">    PID.Kd = <span class="number">0.2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID_init end \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位置型 */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Location</span><span class="params">(<span class="type">float</span> setvalue, PIdTypeDef *PID)</span></span><br><span class="line">&#123;</span><br><span class="line">    PID.SetValue = setvalue;</span><br><span class="line">    PID.err = PID.SetValue - PID.ActualValue;</span><br><span class="line">    PID.integral += PID.err;</span><br><span class="line">    PID.Actuator = PID.Kp * PID.err + PID.Ki * PID.integral + PID.Kd * (PID.err - PID.err_1);</span><br><span class="line">    PID.err_1 = PID.err;</span><br><span class="line">    PID.ActualValue = PID.Actuator * <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> PID.ActualValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 增量型 */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Increment</span><span class="params">(<span class="type">float</span> setvalue, PIdTypeDef *PID)</span></span><br><span class="line">&#123;</span><br><span class="line">    PID.SetValue=setvalue;</span><br><span class="line">    PID.err=PID.SetValue - PID.Actualvalue;</span><br><span class="line">    <span class="type">float</span> incrementvalue = PID.Kp * (PID.err - PID.err_1) + PID.Ki * PID.err + PID.Kd * (PID.err -PID.err_1 + PID.err_2);</span><br><span class="line">    PID.ActualValue += incrementvalue;</span><br><span class="line">    PID.err_2=PID.err_1;</span><br><span class="line">    PID.err_1=PID.err;</span><br><span class="line">    <span class="keyword">return</span> PID.ActualValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PID调整"><a href="#PID调整" class="headerlink" title="PID调整"></a>PID调整</h3><p>对于不同的系统，不同的环境，所需的PID参数也不同，所以不存在适用于万物的PID参数。</p>
<ul>
<li>调整方法：<ol>
<li>对系统建立模型，根据模型来调整</li>
<li>直接观察系统，手动调整</li>
<li>系统自动调整</li>
</ol>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">John Doe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/09/28/STM32_Study_Note/">http://example.com/2023/09/28/STM32_Study_Note/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">John Doe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">
                                    <span class="chip bg-color">嵌入式</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;Current
            </div>
            <div class="card">
                <a href="/2023/09/28/STM32_Study_Note/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="STM32学习">
                        
                        <span class="card-title">STM32学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">
                        <span class="chip bg-color">嵌入式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/09/28/Git_Study_Note/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="git使用">
                        
                        <span class="card-title">git使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/code/">
                        <span class="chip bg-color">code</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">John Doe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
